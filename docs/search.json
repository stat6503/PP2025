[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python프로그래밍",
    "section": "",
    "text": "본 강의에서는 파이썬을 이용한 프로그래밍 방법을 학습하고, 데이터 분석에 필수적인 몇 가지 패키지를 소개한다.\n또한 클래스와 객체지향적 프로그래밍의 개념을 설명한다."
  },
  {
    "objectID": "index.html#강의-소개",
    "href": "index.html#강의-소개",
    "title": "Python프로그래밍",
    "section": "",
    "text": "본 강의에서는 파이썬을 이용한 프로그래밍 방법을 학습하고, 데이터 분석에 필수적인 몇 가지 패키지를 소개한다.\n또한 클래스와 객체지향적 프로그래밍의 개념을 설명한다."
  },
  {
    "objectID": "index.html#학습-평가",
    "href": "index.html#학습-평가",
    "title": "Python프로그래밍",
    "section": "학습 평가",
    "text": "학습 평가\n\n중간 30%, 기말 40%, 출석 10%, 과제 20%\n결석 1회 1점 감점, 지각 3회 1점 감점(1/4 이상 결석하면 F학점)"
  },
  {
    "objectID": "index.html#설문조사",
    "href": "index.html#설문조사",
    "title": "Python프로그래밍",
    "section": "설문조사",
    "text": "설문조사\n\nPython 프로그래밍에 대한 기초적인 이해도와 경험을 파악하기 위해 설문조사를 실시함\n25-1 Python프로그래밍 사전 설문조사"
  },
  {
    "objectID": "index.html#문의",
    "href": "index.html#문의",
    "title": "Python프로그래밍",
    "section": "문의",
    "text": "문의\n\nE-mail: stat6503@gmail.com\nLMS는 파일 제출용으로만 사용하니 쪽지 보내지 말 것"
  },
  {
    "objectID": "index.html#참고문헌",
    "href": "index.html#참고문헌",
    "title": "Python프로그래밍",
    "section": "참고문헌",
    "text": "참고문헌\n\n실생활 융합 예제로 배우는 파이썬 마스터 / 김종훈, 김동건 / 2025 / 한빛아카데미\n데이터 과학을 위한 파이썬 프로그래밍 / 최성철 / 2023 / 한빛아카데미\n혼자 공부하는 파이썬(개정판) / 윤인성 / 2022 / 한빛아카데미\nwebsite : 점프 투 파이썬"
  },
  {
    "objectID": "4_3_matplotlib.html",
    "href": "4_3_matplotlib.html",
    "title": "4. 라이브러리",
    "section": "",
    "text": "데이터 시각화(data visualization)\n\n데이터 분석 결과를 쉽게 이해할 수 있도록 표현하고 전달되는 과정\n복잡한 정보를 한 눈에 파악하고, 숨겨진 패턴이나 관계를 드러냄\n탐색적 자료 분석(EDA), 결과 해석, 의사결정 등에 폭넓게 활용\n\n\n\n\nMatplotLib\n\n넘파이 배열을 기반으로 만들어진 다중 플랫폼 데이터 시각화 라이브러리\n다양한 운영체제와 그래픽 백엔드에서 안정적으로 작동\n\n\n\n\n\n\n\n\n\n\n\n\n\n유형\n설명\n\n\n\n\n선 그래프 (line plot)\n- 시계열 데이터의 추세 표현 - 색상(color), 선 종류(linestyle), 마커(marker) 등\n\n\n막대 그래프 (bar plot)\n- 범주형 데이터의 값 비교 - 색상(color), 너비(width), 정렬(align) 등\n\n\n히스토그램 (histogram)\n- 수치형 데이터의 분포 파악 - 색상(color), 구간 수(bins), 누적 여부(cumulative) 등\n\n\n산점도 (scatter plot)\n- 두 수치형 변수 사이의 관계 표현 - 색상(c), 점 크기(s), 투명도(alpha) 등\n\n\n\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n\n## 실습 데이터 : air_quality 데이터셋\nair_quality = pd.read_csv(\"https://raw.githubusercontent.com/pandas-dev/pandas/main/doc/data/air_quality_no2_long.csv\")\n\n\n# city : 측정 도시\n# country : 측정 국가\n# date.utc : 측정 일시(UTC)\n# location : 측정 위치\n# parameter : 측정 항목\n# value : 측정 값\n# unit : 측정 단위\nprint(air_quality.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 2068 entries, 0 to 2067\nData columns (total 7 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   city       2068 non-null   object \n 1   country    2068 non-null   object \n 2   date.utc   2068 non-null   object \n 3   location   2068 non-null   object \n 4   parameter  2068 non-null   object \n 5   value      2068 non-null   float64\n 6   unit       2068 non-null   object \ndtypes: float64(1), object(6)\nmemory usage: 113.2+ KB\nNone\n\n\n\nprint(air_quality.head())\n\n    city country                   date.utc location parameter  value   unit\n0  Paris      FR  2019-06-21 00:00:00+00:00  FR04014       no2   20.0  µg/m³\n1  Paris      FR  2019-06-20 23:00:00+00:00  FR04014       no2   21.8  µg/m³\n2  Paris      FR  2019-06-20 22:00:00+00:00  FR04014       no2   26.5  µg/m³\n3  Paris      FR  2019-06-20 21:00:00+00:00  FR04014       no2   24.9  µg/m³\n4  Paris      FR  2019-06-20 20:00:00+00:00  FR04014       no2   21.4  µg/m³\n\n\n\nair_quality['city'].value_counts()\n\ncity\nParis        1004\nLondon        969\nAntwerpen      95\nName: count, dtype: int64\n\n\n\nair_quality['parameter'].value_counts()\n\nparameter\nno2    2068\nName: count, dtype: int64\n\n\n\n# date.utc 열을 datetime 형식으로 변환\nair_quality['date.utc'] = pd.to_datetime(air_quality['date.utc'])\n\n\nprint(air_quality.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 2068 entries, 0 to 2067\nData columns (total 7 columns):\n #   Column     Non-Null Count  Dtype              \n---  ------     --------------  -----              \n 0   city       2068 non-null   object             \n 1   country    2068 non-null   object             \n 2   date.utc   2068 non-null   datetime64[ns, UTC]\n 3   location   2068 non-null   object             \n 4   parameter  2068 non-null   object             \n 5   value      2068 non-null   float64            \n 6   unit       2068 non-null   object             \ndtypes: datetime64[ns, UTC](1), float64(1), object(5)\nmemory usage: 113.2+ KB\nNone\n\n\n\nprint(air_quality.head())\n\n    city country                  date.utc location parameter  value   unit\n0  Paris      FR 2019-06-21 00:00:00+00:00  FR04014       no2   20.0  µg/m³\n1  Paris      FR 2019-06-20 23:00:00+00:00  FR04014       no2   21.8  µg/m³\n2  Paris      FR 2019-06-20 22:00:00+00:00  FR04014       no2   26.5  µg/m³\n3  Paris      FR 2019-06-20 21:00:00+00:00  FR04014       no2   24.9  µg/m³\n4  Paris      FR 2019-06-20 20:00:00+00:00  FR04014       no2   21.4  µg/m³\n\n\n\n## 선 그래프\n# 1) Paris의 NO2 농도 변화: 기본 선 그래프\nparis_data = air_quality[air_quality[\"city\"] == \"Paris\"]\n\nplt.figure(figsize=(8, 3))\nplt.plot(paris_data[\"date.utc\"], paris_data[\"value\"])\nplt.title(\"NO₂ levels in Paris\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"NO₂ (µg/m³)\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 선 그래프\n# 2) Paris의 NO2 농도 변화: 리샘플링(1시간 → 일간), 커스터마이징(색상, 선 종류, 마커)\n# 색상: r, g, b, c, m, y, k, w\n# 선 종류: -, --, -., :\n# 마커: o, +, D, s, ^, v, .\nvalue_day = paris_data.set_index('date.utc')['value'].resample('D').mean()\n\nplt.figure(figsize=(8, 3))\n#plt.plot(value_day.index, value_day, color=\"green\", linestyle=\"--\", marker=\"o\")\nplt.plot(value_day.index, value_day, \"g--o\")\nplt.title(\"NO₂ levels in Paris\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"NO₂ (µg/m³)\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 선 그래프\n# 3) 세 도시의 NO2 농도 변화\ncities = ['Paris', 'London', 'Antwerpen']\ncolors = ['steelblue', 'green', 'indianred']\n\nplt.figure(figsize=(8, 3))\n\nfor i, city in enumerate(cities):\n    city_data = air_quality[air_quality[\"city\"] == city]\n    plt.plot(city_data['date.utc'], city_data['value'],\n             label=city, color=colors[i],\n             linewidth=1, alpha=0.7)\n\nplt.title(\"NO₂ levels in Paris, London, and Antwerpen\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"NO₂ (µg/m³)\")\nplt.legend(loc = 'upper right', fontsize=7)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 막대 그래프\n# 1) 도시의 측정 빈도\ncity_counts = air_quality['city'].value_counts()\n\nplt.figure(figsize=(5, 3))\nplt.bar(city_counts.index, city_counts.values, color=['steelblue', 'seagreen', 'indianred'])\nplt.title(\"Frequency of Measurements by City\")\nplt.xlabel(\"City\")\nplt.ylabel(\"Frequency\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 막대 그래프\n# 2) 도시별 평균 NO₂ 농도\ncity_avg = air_quality.groupby('city')['value'].mean()\n\nplt.figure(figsize=(5, 3))\nplt.bar(city_avg.index, city_avg.values, color=['steelblue', 'seagreen', 'indianred'])\nplt.title(\"Average NO₂ Levels by City\")\nplt.xlabel(\"City\")\nplt.ylabel(\"Average NO₂ (µg/m³)\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 히스토그램\n# 1) Paris의 NO2 농도 분포\nparis_data = air_quality[air_quality[\"city\"] == \"Paris\"]\n\nplt.figure(figsize=(5, 3))\nplt.hist(paris_data[\"value\"], bins=15)\nplt.title(\"Distribution of NO₂ in Paris\")\nplt.xlabel(\"NO₂ (µg/m³)\")\nplt.ylabel(\"Frequency\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 히스토그램, 다중 그래프\n# 2) 세 도시의 NO2 농도 분포\ncities = ['Paris', 'London', 'Antwerpen']\ncolors = ['steelblue', 'green', 'indianred']\n\nplt.figure(figsize=(8, 3))\n\nfor i, city in enumerate(cities):\n    city_data = air_quality[air_quality[\"city\"] == city]\n    plt.subplot(1, 3, i+1)\n    plt.hist(city_data['value'], density=True,\n             label=city, color=colors[i])\n    \n    plt.xlabel(\"NO₂ (µg/m³)\")\n    plt.ylabel(\"Frequency\")\n    plt.legend(loc = 'upper right')\n    plt.xlim(0, 100)\n    plt.ylim(0, 0.05)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 산점도\n# 전체 금액과 팁 금액 관계\nimport seaborn as sns\ntips = sns.load_dataset(\"tips\")\n\nplt.figure(figsize=(4, 4))\nplt.scatter(tips['total_bill'], tips['tip'],\n           c=tips['time'].map({'Lunch': 'orange', 'Dinner': 'gray'}), alpha=0.7)\nplt.title('Scatter Plot of Total Bill vs Tip')\nplt.xlabel('Total Bill')\nplt.ylabel('Tip')\nplt.tight_layout()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n이미지(image)\n\n디지털 이미지는 수 많은 픽셀(pixel)로 이루어져 있으며, 각 픽셀은 하나의 색상을 나타냄\n픽셀들이 모여 하나의 이미지를 구성하며, 전체적으로 모자이크 구조와 비슷함\n각 픽셀은 하나의 숫자 값(흑백) 또는 세 개의 값(R, G, B)을 가지며, 이를 통해 색상을 표현함\n\n흑백 이미지 : 2차원 배열 → 행(높이), 열(너비)\n컬러 이미지(RGB) : 3차원 배열 → 행(높이), 열(너비), 채널\n\n색의 3요소 RGB\n\n컬러 이미지는 보통 RGB 색상 모델을 따름\n각 픽셀은 R, G, B 세 가지 값(0~255)을 조합하여 색상을 나타내며, 각각의 값을 채널(channel)이라 함\nRGB 이미지는 관례적으로 (height, width, channel) 형태의 배열 구조를 가짐\n\n3차원 배열(높이, 너비, 3)에서 배열의 세 번째 축(axis=2)이 채널 방향임\narray[:, :, 0] : R 채널\narray[:, :, 1] : G 채널\narray[:, :, 2] : B 채널\n\n\n이미지는 결국 숫자로 이루어진 배열이며, 넘파이 배열로 변환하여 수치 연산이 가능함\n이미지 데이터는 수치적으로 처리하거나 분석할 수 있으며, 머신러닝/딥러닝 모델에 입력하기 위해 배열 형태로 변환하는 것이 일반적임\n\n\n\n \n\n\nPIL 라이브러리\n\n다양한 이미지 파일 형식을 지원하는 이미지 처리 라이브러리(Pillow)\n이미지 불러오기, 배열 변환, 크기 조절, 회전, 흑백 전환 등 다양한 처리 가능\n\n\n\nfrom PIL import Image\n\n\n\n예제 이미지 : Unsplash의 stefanus fandhy\n\n\n# 이미지 불러오기 및 시각화\nimg = Image.open('./images/puppy.jpg')\nplt.imshow(img)\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 넘파이 배열로 변환\nimg_array = np.array(img)\nimg_array.shape\n\n(3781, 5671, 3)\n\n\n\n\n\n\n\n컬러 이미지의 각 채널(R, G, B)은 배열의 세 번째 축(axis=2)으로 구분됨\n각 채널은 분리하여 별도로 저장하거나 다시 합칠 수 있음\n각 채널의 픽셀 값을 직접 수정하거나 덧셈, 곱셈 등 연산을 적용하여 다양한 효과를 줄 수 있음\n\n[주의] 픽셀 값이 0~255 범위를 벗어나지 않도록 해야 함\n\n조건문과 불리언 인덱싱(마스킹)을 이용하여 원하는 영역만 선택하거나 조작할 수 있음\n\n\n# 채널 분리\nr = img_array[:, :, 0]\ng = img_array[:, :, 1]\nb = img_array[:, :, 2]\n\n\n# 단일 채널만 유지\nr_img = img_array.copy()\ng_img = img_array.copy()\nb_img = img_array.copy()\n\nr_img[:, :, [1,2]] = 0\ng_img[:, :, [0,2]] = 0\nb_img[:, :, [0,1]] = 0\n\n# np.concatenate() : 여러 배열을 지정한 축(axis)을 따라 이어 붙이는 함수\ncombined_img = np.concatenate([r_img, g_img, b_img], axis=1)\n\nplt.imshow(combined_img)\nplt.title(\"Single Channel Images (R / G / B)\")\nplt.axis(\"off\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n# 흑백 변환 : 채널 평균으로 밝기 계산(simple average)\ngray_img = img_array.mean(axis=2)\n\nplt.figure(figsize=(4, 4))\nplt.imshow(gray_img, cmap='gray')\nplt.title('Grayscale Image')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 흑백 변환 : 가중 평균으로 밝기 계산(weighted average)\ngray_img_weighted = r * 0.2989 + g * 0.5870 + b * 0.1140    # ITU-R BT.601 표준 가중치\n\nplt.figure(figsize=(4, 4))\nplt.imshow(gray_img_weighted, cmap='gray')\nplt.title('Grayscale Image')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n## 정규화 : 픽셀 값을 0~1 사이의 실수로 변환\n# 일반적으로 머신러닝/딥러닝 모델 입력 시 이미지를 정규화하여 사용함\n# 학습 안정성과 성능 향상을 위한 필수적인 전처리 과정\nimg_normalized = img_array / 255.0\n\nplt.figure(figsize=(4, 4))\nplt.imshow(img_normalized)\nplt.title('Normalized Image (pixel values 0~1)')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 특정 채널만 교체하고, 나머지 채널은 0으로 만드는 함수\ndef isolate_channel(img_array, channel_idx, channel_array):\n    \"\"\"\n    원본 이미지를 복사한 뒤,\n    지정한 채널만 channel_data 값으로 바꾸고\n    나머지 채널은 0으로 설정해서 반환하는 함수\n    \n    Args:\n        img_array (ndarray): 원본 이미지 배열 (H, W, 3)\n        channel_idx (int): 변경할 채널 인덱스 (0: R, 1: G, 2: B)\n        channel_array (ndarray): 교체할 채널 배열 (H, W)\n        \n    Returns:\n        ndarray: 채널이 교체되고 나머지는 0인 이미지\n    \"\"\"\n    img_copy = img_array.copy()\n    img_copy[:, :, :] = 0\n    img_copy[:, :, channel_idx] = channel_array\n    \n    return img_copy\n\n\n?isolate_channel\n\n\n# 특정 채널 강조 : Red Channel\n# np.clip() : 넘파이 배열의 값들을 지정한 최소값, 최대값 사이로 제한하는 함수\nr_enhanced = np.clip(r * 1.5, 0, 255).astype(np.uint8)\n\nimg_red_original = isolate_channel(img_array, 0, r)\nimg_red_enhanced = isolate_channel(img_array, 0, r_enhanced)\n\nplt.subplot(1, 2, 1)\nplt.imshow(img_red_original)\nplt.title('Original Red Channel')\nplt.axis('off')\n\nplt.subplot(1, 2, 2)\nplt.imshow(img_red_enhanced)\nplt.title('Enhanced Red Channel')\nplt.axis('off')\n\nplt.show()\n\n\n\n\n\n\n\n\n\n# 채널 합성\n# np.stack() : 여러 배열을 새로운 축(axis)을 추가하여 쌓아 3차원 이상의 배열을 만드는 함수\nmodified_img = np.stack([r_enhanced, g, b], axis=2)\n\nplt.figure(figsize=(4, 4))\nplt.imshow(modified_img)\nplt.title('Modified Image')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 색상 반전\ninverted = 255 - img_array\n\nplt.figure(figsize=(4, 4))\nplt.imshow(inverted)\nplt.title('Inverted Image')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 밝은 영역만 추출 : 조건문과 마스킹 사용\n# 마스킹(masking) : 불리언 배열로 조건에 맞는 데이터만 선택하거나 조작하는 방법\ngray = img_array.mean(axis=2)\nmask = gray &gt; gray_img.mean()\n\nbright_part = img_array.copy()\nbright_part[~mask] = 0                       # 어두운 부분은 검정으로 처리\n\nplt.figure(figsize=(4, 4))\nplt.imshow(bright_part)\nplt.title('Bright Regions Only')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n디지털 이미지의 크기, 방향, 위치 등을 변경하는 작업\n머신러닝/딥러닝에서 입력 이미지를 정해진 크기로 맞추거나, 데이터 증강(data augmentation)을 위해 변형을 적용함\nPIL(Pillow) 라이브러리를 이용하면 다양한 변형 작업을 간단히 수행할 수 있음\n\n\n\n\n\n\n\n\n\n구분\n설명\n\n\n\n\n크기 조절(resize)\n- 이미지의 너비(width)와 높이(height)를 원하는 크기로 변경 - 학습 모델에 입력되는 이미지 크기가 고정되어 있는 경우에 필수적인 전처리 작업 - 보간법(interpolation)에 따라 이미지 품질에 차이가 발생할 수 있음\n\n\n회전 및 뒤집기(rotate & flip)\n- 회전(rotation) : 이미지를 특정 각도만큼 회전 - 좌우/상하 뒤집기(flip) : 이미지를 반전시켜 대칭 구조로 만듦 - 데이터 다양성을 높이기 위한 증강 기법으로 자주 사용됨\n\n\n잘라내기(crop)\n- 이미지의 일부분만 선택하여 잘라냄 - 관심 영역(Region of Interest, ROI)만 추출할 때 유용 - 정사각형으로 자르거나 특정 좌표를 기준으로 잘라내기 가능\n\n\n\n\n# 크기 조절 : 너비 200px, 높이 100px\nresized_img = img.resize((200, 100))\n\nplt.imshow(resized_img)\nplt.title('Resized Image')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 45도 회전\nrotated_img = img.rotate(45)\n\nplt.figure(figsize=(4, 4))\nplt.imshow(rotated_img)\nplt.title('Rotated(45°) Image')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 좌우 반전 뒤집기\nflipped_img1 = img.transpose(Image.FLIP_LEFT_RIGHT)\n\nplt.figure(figsize=(4, 4))\nplt.imshow(flipped_img1)\nplt.title(\"Flipped (Left ↔ Right) Image\")\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 상하 반전 뒤집기\nflipped_img2 = img.transpose(Image.FLIP_TOP_BOTTOM)\n\nplt.figure(figsize=(4, 4))\nplt.imshow(flipped_img2)\nplt.title(\"Flipped (Top ↔ Bottom) Image\")\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.imshow(img)\nplt.show()\n\n\n\n\n\n\n\n\n\n# 잘라내기 : (left, top, right, bottom)\ncropped_img = img.crop((2200, 1500, 3000, 2000))\n# plt.imshow(img_array[1500:2000, 2200:3000, ])\n\nplt.figure(figsize=(4, 4))\nplt.imshow(cropped_img)\nplt.title(\"Croppeed Image\")\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n이미지의 색상은 숫자로 표현되며, 각 채널의 평균과 표준편차를 통해 전체적인 색감과 색상 다양성을 파악할 수 있음\n히스토그램을 이용하면 각 채널의 밝기 분포를 시각적으로 확인하고, 특정 색이 어느 정도로 포함되어 있는지 쉽게 이해할 수 있음\n이는 이미지 분류, 전처리, 피처(feature) 추출 등에 유용하게 활용됨\n\n\n## 각 채널의 평균\n# 평균이 가장 높은 초록색 계열이 이미지에 가장 많이 포함되어 있음\n# 다음으로는 빨간색 계열, 파란색 계열 순임\nmean_values = np.mean(img, axis=(0, 1))\nprint(np.around(mean_values, 2))\n\n[162.37 200.03 129.56]\n\n\n\n## 각 채널의 표준편차\n# 표준편차가 가장 큰 파란색 계열이 밝기 면에서 가장 다양하게 분포하고 있음\n# → 밝고 어두운 부분에 걸쳐 넓게 처져 있어 이미지 내에서 변동이 큼\n# 초록색 계열은 상대적으로 균일한 밝기 분포를 가짐\nstd_values = np.std(img, axis=(0, 1))\nprint(np.around(std_values, 2))\n\n[70.62 45.88 84.55]\n\n\n\n## 각 채널의 히스토그램\ncolors = ('red', 'green', 'blue')\n\n# 히스토그램에서 최대 빈도 찾기\n# np.histogram() : 수치형 데이터의 구간별 빈도를 계산하는 함수\ny_max = 0\nfor i in range(3):\n    hist, _ = np.histogram(img_array[:, :, i], bins=np.arange(257))\n    y_max = max(y_max, hist.max())\n\nplt.figure(figsize=(8, 3))\nfor i, color in enumerate(colors):\n    plt.subplot(1, 3, i+1)\n    plt.hist(img_array[:, :, i].ravel(), bins=np.arange(257), color=color, alpha=0.7)\n    plt.ylim([0, y_max * 1.01])\n    plt.title(f\"{color} channel\")\n    plt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n# [빨간색 계열]은 중간 밝기 구간에 은은하게 퍼져있고, 밝은 영역도 일부 포함됨\n# → 색감이 다양하지만 극단적인 밝기 변화는 아님(표준편차 중간 수준)\n\n# [초록색 계열]은 밝은 색상이 넓게 분포하고 있으며, 비교적 균일한 색감을 유지함\n\n# [파란색 계열]은 밝은 색상과 어두운 색상이 모두 존재하며, 명암 대비가 큼\n# → 그림자나 반사광 효과가 강하게 작용했을 가능성이 있음\n\n## 각 채널의 히스토그램2\ncolors = ('red', 'green', 'blue')\n\nplt.figure(figsize=(8, 3))\nfor i, color in enumerate(colors):\n    plt.hist(img_array[:, :, i].ravel(), bins=np.arange(257), color=color, alpha=0.5, label=color)\n    \nplt.title('RGB Histogram')\nplt.xlabel('Pixel Value')\nplt.ylabel('Frequency')\nplt.legend()\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "4_3_matplotlib.html#matplotlib-라이브러리",
    "href": "4_3_matplotlib.html#matplotlib-라이브러리",
    "title": "4. 라이브러리",
    "section": "",
    "text": "데이터 시각화(data visualization)\n\n데이터 분석 결과를 쉽게 이해할 수 있도록 표현하고 전달되는 과정\n복잡한 정보를 한 눈에 파악하고, 숨겨진 패턴이나 관계를 드러냄\n탐색적 자료 분석(EDA), 결과 해석, 의사결정 등에 폭넓게 활용\n\n\n\n\nMatplotLib\n\n넘파이 배열을 기반으로 만들어진 다중 플랫폼 데이터 시각화 라이브러리\n다양한 운영체제와 그래픽 백엔드에서 안정적으로 작동\n\n\n\n\n\n\n\n\n\n\n\n\n\n유형\n설명\n\n\n\n\n선 그래프 (line plot)\n- 시계열 데이터의 추세 표현 - 색상(color), 선 종류(linestyle), 마커(marker) 등\n\n\n막대 그래프 (bar plot)\n- 범주형 데이터의 값 비교 - 색상(color), 너비(width), 정렬(align) 등\n\n\n히스토그램 (histogram)\n- 수치형 데이터의 분포 파악 - 색상(color), 구간 수(bins), 누적 여부(cumulative) 등\n\n\n산점도 (scatter plot)\n- 두 수치형 변수 사이의 관계 표현 - 색상(c), 점 크기(s), 투명도(alpha) 등\n\n\n\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n\n## 실습 데이터 : air_quality 데이터셋\nair_quality = pd.read_csv(\"https://raw.githubusercontent.com/pandas-dev/pandas/main/doc/data/air_quality_no2_long.csv\")\n\n\n# city : 측정 도시\n# country : 측정 국가\n# date.utc : 측정 일시(UTC)\n# location : 측정 위치\n# parameter : 측정 항목\n# value : 측정 값\n# unit : 측정 단위\nprint(air_quality.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 2068 entries, 0 to 2067\nData columns (total 7 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   city       2068 non-null   object \n 1   country    2068 non-null   object \n 2   date.utc   2068 non-null   object \n 3   location   2068 non-null   object \n 4   parameter  2068 non-null   object \n 5   value      2068 non-null   float64\n 6   unit       2068 non-null   object \ndtypes: float64(1), object(6)\nmemory usage: 113.2+ KB\nNone\n\n\n\nprint(air_quality.head())\n\n    city country                   date.utc location parameter  value   unit\n0  Paris      FR  2019-06-21 00:00:00+00:00  FR04014       no2   20.0  µg/m³\n1  Paris      FR  2019-06-20 23:00:00+00:00  FR04014       no2   21.8  µg/m³\n2  Paris      FR  2019-06-20 22:00:00+00:00  FR04014       no2   26.5  µg/m³\n3  Paris      FR  2019-06-20 21:00:00+00:00  FR04014       no2   24.9  µg/m³\n4  Paris      FR  2019-06-20 20:00:00+00:00  FR04014       no2   21.4  µg/m³\n\n\n\nair_quality['city'].value_counts()\n\ncity\nParis        1004\nLondon        969\nAntwerpen      95\nName: count, dtype: int64\n\n\n\nair_quality['parameter'].value_counts()\n\nparameter\nno2    2068\nName: count, dtype: int64\n\n\n\n# date.utc 열을 datetime 형식으로 변환\nair_quality['date.utc'] = pd.to_datetime(air_quality['date.utc'])\n\n\nprint(air_quality.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 2068 entries, 0 to 2067\nData columns (total 7 columns):\n #   Column     Non-Null Count  Dtype              \n---  ------     --------------  -----              \n 0   city       2068 non-null   object             \n 1   country    2068 non-null   object             \n 2   date.utc   2068 non-null   datetime64[ns, UTC]\n 3   location   2068 non-null   object             \n 4   parameter  2068 non-null   object             \n 5   value      2068 non-null   float64            \n 6   unit       2068 non-null   object             \ndtypes: datetime64[ns, UTC](1), float64(1), object(5)\nmemory usage: 113.2+ KB\nNone\n\n\n\nprint(air_quality.head())\n\n    city country                  date.utc location parameter  value   unit\n0  Paris      FR 2019-06-21 00:00:00+00:00  FR04014       no2   20.0  µg/m³\n1  Paris      FR 2019-06-20 23:00:00+00:00  FR04014       no2   21.8  µg/m³\n2  Paris      FR 2019-06-20 22:00:00+00:00  FR04014       no2   26.5  µg/m³\n3  Paris      FR 2019-06-20 21:00:00+00:00  FR04014       no2   24.9  µg/m³\n4  Paris      FR 2019-06-20 20:00:00+00:00  FR04014       no2   21.4  µg/m³\n\n\n\n## 선 그래프\n# 1) Paris의 NO2 농도 변화: 기본 선 그래프\nparis_data = air_quality[air_quality[\"city\"] == \"Paris\"]\n\nplt.figure(figsize=(8, 3))\nplt.plot(paris_data[\"date.utc\"], paris_data[\"value\"])\nplt.title(\"NO₂ levels in Paris\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"NO₂ (µg/m³)\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 선 그래프\n# 2) Paris의 NO2 농도 변화: 리샘플링(1시간 → 일간), 커스터마이징(색상, 선 종류, 마커)\n# 색상: r, g, b, c, m, y, k, w\n# 선 종류: -, --, -., :\n# 마커: o, +, D, s, ^, v, .\nvalue_day = paris_data.set_index('date.utc')['value'].resample('D').mean()\n\nplt.figure(figsize=(8, 3))\n#plt.plot(value_day.index, value_day, color=\"green\", linestyle=\"--\", marker=\"o\")\nplt.plot(value_day.index, value_day, \"g--o\")\nplt.title(\"NO₂ levels in Paris\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"NO₂ (µg/m³)\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 선 그래프\n# 3) 세 도시의 NO2 농도 변화\ncities = ['Paris', 'London', 'Antwerpen']\ncolors = ['steelblue', 'green', 'indianred']\n\nplt.figure(figsize=(8, 3))\n\nfor i, city in enumerate(cities):\n    city_data = air_quality[air_quality[\"city\"] == city]\n    plt.plot(city_data['date.utc'], city_data['value'],\n             label=city, color=colors[i],\n             linewidth=1, alpha=0.7)\n\nplt.title(\"NO₂ levels in Paris, London, and Antwerpen\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"NO₂ (µg/m³)\")\nplt.legend(loc = 'upper right', fontsize=7)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 막대 그래프\n# 1) 도시의 측정 빈도\ncity_counts = air_quality['city'].value_counts()\n\nplt.figure(figsize=(5, 3))\nplt.bar(city_counts.index, city_counts.values, color=['steelblue', 'seagreen', 'indianred'])\nplt.title(\"Frequency of Measurements by City\")\nplt.xlabel(\"City\")\nplt.ylabel(\"Frequency\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 막대 그래프\n# 2) 도시별 평균 NO₂ 농도\ncity_avg = air_quality.groupby('city')['value'].mean()\n\nplt.figure(figsize=(5, 3))\nplt.bar(city_avg.index, city_avg.values, color=['steelblue', 'seagreen', 'indianred'])\nplt.title(\"Average NO₂ Levels by City\")\nplt.xlabel(\"City\")\nplt.ylabel(\"Average NO₂ (µg/m³)\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 히스토그램\n# 1) Paris의 NO2 농도 분포\nparis_data = air_quality[air_quality[\"city\"] == \"Paris\"]\n\nplt.figure(figsize=(5, 3))\nplt.hist(paris_data[\"value\"], bins=15)\nplt.title(\"Distribution of NO₂ in Paris\")\nplt.xlabel(\"NO₂ (µg/m³)\")\nplt.ylabel(\"Frequency\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 히스토그램, 다중 그래프\n# 2) 세 도시의 NO2 농도 분포\ncities = ['Paris', 'London', 'Antwerpen']\ncolors = ['steelblue', 'green', 'indianred']\n\nplt.figure(figsize=(8, 3))\n\nfor i, city in enumerate(cities):\n    city_data = air_quality[air_quality[\"city\"] == city]\n    plt.subplot(1, 3, i+1)\n    plt.hist(city_data['value'], density=True,\n             label=city, color=colors[i])\n    \n    plt.xlabel(\"NO₂ (µg/m³)\")\n    plt.ylabel(\"Frequency\")\n    plt.legend(loc = 'upper right')\n    plt.xlim(0, 100)\n    plt.ylim(0, 0.05)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n## 산점도\n# 전체 금액과 팁 금액 관계\nimport seaborn as sns\ntips = sns.load_dataset(\"tips\")\n\nplt.figure(figsize=(4, 4))\nplt.scatter(tips['total_bill'], tips['tip'],\n           c=tips['time'].map({'Lunch': 'orange', 'Dinner': 'gray'}), alpha=0.7)\nplt.title('Scatter Plot of Total Bill vs Tip')\nplt.xlabel('Total Bill')\nplt.ylabel('Tip')\nplt.tight_layout()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n이미지(image)\n\n디지털 이미지는 수 많은 픽셀(pixel)로 이루어져 있으며, 각 픽셀은 하나의 색상을 나타냄\n픽셀들이 모여 하나의 이미지를 구성하며, 전체적으로 모자이크 구조와 비슷함\n각 픽셀은 하나의 숫자 값(흑백) 또는 세 개의 값(R, G, B)을 가지며, 이를 통해 색상을 표현함\n\n흑백 이미지 : 2차원 배열 → 행(높이), 열(너비)\n컬러 이미지(RGB) : 3차원 배열 → 행(높이), 열(너비), 채널\n\n색의 3요소 RGB\n\n컬러 이미지는 보통 RGB 색상 모델을 따름\n각 픽셀은 R, G, B 세 가지 값(0~255)을 조합하여 색상을 나타내며, 각각의 값을 채널(channel)이라 함\nRGB 이미지는 관례적으로 (height, width, channel) 형태의 배열 구조를 가짐\n\n3차원 배열(높이, 너비, 3)에서 배열의 세 번째 축(axis=2)이 채널 방향임\narray[:, :, 0] : R 채널\narray[:, :, 1] : G 채널\narray[:, :, 2] : B 채널\n\n\n이미지는 결국 숫자로 이루어진 배열이며, 넘파이 배열로 변환하여 수치 연산이 가능함\n이미지 데이터는 수치적으로 처리하거나 분석할 수 있으며, 머신러닝/딥러닝 모델에 입력하기 위해 배열 형태로 변환하는 것이 일반적임\n\n\n\n \n\n\nPIL 라이브러리\n\n다양한 이미지 파일 형식을 지원하는 이미지 처리 라이브러리(Pillow)\n이미지 불러오기, 배열 변환, 크기 조절, 회전, 흑백 전환 등 다양한 처리 가능\n\n\n\nfrom PIL import Image\n\n\n\n예제 이미지 : Unsplash의 stefanus fandhy\n\n\n# 이미지 불러오기 및 시각화\nimg = Image.open('./images/puppy.jpg')\nplt.imshow(img)\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 넘파이 배열로 변환\nimg_array = np.array(img)\nimg_array.shape\n\n(3781, 5671, 3)\n\n\n\n\n\n\n\n컬러 이미지의 각 채널(R, G, B)은 배열의 세 번째 축(axis=2)으로 구분됨\n각 채널은 분리하여 별도로 저장하거나 다시 합칠 수 있음\n각 채널의 픽셀 값을 직접 수정하거나 덧셈, 곱셈 등 연산을 적용하여 다양한 효과를 줄 수 있음\n\n[주의] 픽셀 값이 0~255 범위를 벗어나지 않도록 해야 함\n\n조건문과 불리언 인덱싱(마스킹)을 이용하여 원하는 영역만 선택하거나 조작할 수 있음\n\n\n# 채널 분리\nr = img_array[:, :, 0]\ng = img_array[:, :, 1]\nb = img_array[:, :, 2]\n\n\n# 단일 채널만 유지\nr_img = img_array.copy()\ng_img = img_array.copy()\nb_img = img_array.copy()\n\nr_img[:, :, [1,2]] = 0\ng_img[:, :, [0,2]] = 0\nb_img[:, :, [0,1]] = 0\n\n# np.concatenate() : 여러 배열을 지정한 축(axis)을 따라 이어 붙이는 함수\ncombined_img = np.concatenate([r_img, g_img, b_img], axis=1)\n\nplt.imshow(combined_img)\nplt.title(\"Single Channel Images (R / G / B)\")\nplt.axis(\"off\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n# 흑백 변환 : 채널 평균으로 밝기 계산(simple average)\ngray_img = img_array.mean(axis=2)\n\nplt.figure(figsize=(4, 4))\nplt.imshow(gray_img, cmap='gray')\nplt.title('Grayscale Image')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 흑백 변환 : 가중 평균으로 밝기 계산(weighted average)\ngray_img_weighted = r * 0.2989 + g * 0.5870 + b * 0.1140    # ITU-R BT.601 표준 가중치\n\nplt.figure(figsize=(4, 4))\nplt.imshow(gray_img_weighted, cmap='gray')\nplt.title('Grayscale Image')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n## 정규화 : 픽셀 값을 0~1 사이의 실수로 변환\n# 일반적으로 머신러닝/딥러닝 모델 입력 시 이미지를 정규화하여 사용함\n# 학습 안정성과 성능 향상을 위한 필수적인 전처리 과정\nimg_normalized = img_array / 255.0\n\nplt.figure(figsize=(4, 4))\nplt.imshow(img_normalized)\nplt.title('Normalized Image (pixel values 0~1)')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 특정 채널만 교체하고, 나머지 채널은 0으로 만드는 함수\ndef isolate_channel(img_array, channel_idx, channel_array):\n    \"\"\"\n    원본 이미지를 복사한 뒤,\n    지정한 채널만 channel_data 값으로 바꾸고\n    나머지 채널은 0으로 설정해서 반환하는 함수\n    \n    Args:\n        img_array (ndarray): 원본 이미지 배열 (H, W, 3)\n        channel_idx (int): 변경할 채널 인덱스 (0: R, 1: G, 2: B)\n        channel_array (ndarray): 교체할 채널 배열 (H, W)\n        \n    Returns:\n        ndarray: 채널이 교체되고 나머지는 0인 이미지\n    \"\"\"\n    img_copy = img_array.copy()\n    img_copy[:, :, :] = 0\n    img_copy[:, :, channel_idx] = channel_array\n    \n    return img_copy\n\n\n?isolate_channel\n\n\n# 특정 채널 강조 : Red Channel\n# np.clip() : 넘파이 배열의 값들을 지정한 최소값, 최대값 사이로 제한하는 함수\nr_enhanced = np.clip(r * 1.5, 0, 255).astype(np.uint8)\n\nimg_red_original = isolate_channel(img_array, 0, r)\nimg_red_enhanced = isolate_channel(img_array, 0, r_enhanced)\n\nplt.subplot(1, 2, 1)\nplt.imshow(img_red_original)\nplt.title('Original Red Channel')\nplt.axis('off')\n\nplt.subplot(1, 2, 2)\nplt.imshow(img_red_enhanced)\nplt.title('Enhanced Red Channel')\nplt.axis('off')\n\nplt.show()\n\n\n\n\n\n\n\n\n\n# 채널 합성\n# np.stack() : 여러 배열을 새로운 축(axis)을 추가하여 쌓아 3차원 이상의 배열을 만드는 함수\nmodified_img = np.stack([r_enhanced, g, b], axis=2)\n\nplt.figure(figsize=(4, 4))\nplt.imshow(modified_img)\nplt.title('Modified Image')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 색상 반전\ninverted = 255 - img_array\n\nplt.figure(figsize=(4, 4))\nplt.imshow(inverted)\nplt.title('Inverted Image')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 밝은 영역만 추출 : 조건문과 마스킹 사용\n# 마스킹(masking) : 불리언 배열로 조건에 맞는 데이터만 선택하거나 조작하는 방법\ngray = img_array.mean(axis=2)\nmask = gray &gt; gray_img.mean()\n\nbright_part = img_array.copy()\nbright_part[~mask] = 0                       # 어두운 부분은 검정으로 처리\n\nplt.figure(figsize=(4, 4))\nplt.imshow(bright_part)\nplt.title('Bright Regions Only')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n디지털 이미지의 크기, 방향, 위치 등을 변경하는 작업\n머신러닝/딥러닝에서 입력 이미지를 정해진 크기로 맞추거나, 데이터 증강(data augmentation)을 위해 변형을 적용함\nPIL(Pillow) 라이브러리를 이용하면 다양한 변형 작업을 간단히 수행할 수 있음\n\n\n\n\n\n\n\n\n\n구분\n설명\n\n\n\n\n크기 조절(resize)\n- 이미지의 너비(width)와 높이(height)를 원하는 크기로 변경 - 학습 모델에 입력되는 이미지 크기가 고정되어 있는 경우에 필수적인 전처리 작업 - 보간법(interpolation)에 따라 이미지 품질에 차이가 발생할 수 있음\n\n\n회전 및 뒤집기(rotate & flip)\n- 회전(rotation) : 이미지를 특정 각도만큼 회전 - 좌우/상하 뒤집기(flip) : 이미지를 반전시켜 대칭 구조로 만듦 - 데이터 다양성을 높이기 위한 증강 기법으로 자주 사용됨\n\n\n잘라내기(crop)\n- 이미지의 일부분만 선택하여 잘라냄 - 관심 영역(Region of Interest, ROI)만 추출할 때 유용 - 정사각형으로 자르거나 특정 좌표를 기준으로 잘라내기 가능\n\n\n\n\n# 크기 조절 : 너비 200px, 높이 100px\nresized_img = img.resize((200, 100))\n\nplt.imshow(resized_img)\nplt.title('Resized Image')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 45도 회전\nrotated_img = img.rotate(45)\n\nplt.figure(figsize=(4, 4))\nplt.imshow(rotated_img)\nplt.title('Rotated(45°) Image')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 좌우 반전 뒤집기\nflipped_img1 = img.transpose(Image.FLIP_LEFT_RIGHT)\n\nplt.figure(figsize=(4, 4))\nplt.imshow(flipped_img1)\nplt.title(\"Flipped (Left ↔ Right) Image\")\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 상하 반전 뒤집기\nflipped_img2 = img.transpose(Image.FLIP_TOP_BOTTOM)\n\nplt.figure(figsize=(4, 4))\nplt.imshow(flipped_img2)\nplt.title(\"Flipped (Top ↔ Bottom) Image\")\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\nplt.imshow(img)\nplt.show()\n\n\n\n\n\n\n\n\n\n# 잘라내기 : (left, top, right, bottom)\ncropped_img = img.crop((2200, 1500, 3000, 2000))\n# plt.imshow(img_array[1500:2000, 2200:3000, ])\n\nplt.figure(figsize=(4, 4))\nplt.imshow(cropped_img)\nplt.title(\"Croppeed Image\")\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n이미지의 색상은 숫자로 표현되며, 각 채널의 평균과 표준편차를 통해 전체적인 색감과 색상 다양성을 파악할 수 있음\n히스토그램을 이용하면 각 채널의 밝기 분포를 시각적으로 확인하고, 특정 색이 어느 정도로 포함되어 있는지 쉽게 이해할 수 있음\n이는 이미지 분류, 전처리, 피처(feature) 추출 등에 유용하게 활용됨\n\n\n## 각 채널의 평균\n# 평균이 가장 높은 초록색 계열이 이미지에 가장 많이 포함되어 있음\n# 다음으로는 빨간색 계열, 파란색 계열 순임\nmean_values = np.mean(img, axis=(0, 1))\nprint(np.around(mean_values, 2))\n\n[162.37 200.03 129.56]\n\n\n\n## 각 채널의 표준편차\n# 표준편차가 가장 큰 파란색 계열이 밝기 면에서 가장 다양하게 분포하고 있음\n# → 밝고 어두운 부분에 걸쳐 넓게 처져 있어 이미지 내에서 변동이 큼\n# 초록색 계열은 상대적으로 균일한 밝기 분포를 가짐\nstd_values = np.std(img, axis=(0, 1))\nprint(np.around(std_values, 2))\n\n[70.62 45.88 84.55]\n\n\n\n## 각 채널의 히스토그램\ncolors = ('red', 'green', 'blue')\n\n# 히스토그램에서 최대 빈도 찾기\n# np.histogram() : 수치형 데이터의 구간별 빈도를 계산하는 함수\ny_max = 0\nfor i in range(3):\n    hist, _ = np.histogram(img_array[:, :, i], bins=np.arange(257))\n    y_max = max(y_max, hist.max())\n\nplt.figure(figsize=(8, 3))\nfor i, color in enumerate(colors):\n    plt.subplot(1, 3, i+1)\n    plt.hist(img_array[:, :, i].ravel(), bins=np.arange(257), color=color, alpha=0.7)\n    plt.ylim([0, y_max * 1.01])\n    plt.title(f\"{color} channel\")\n    plt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n# [빨간색 계열]은 중간 밝기 구간에 은은하게 퍼져있고, 밝은 영역도 일부 포함됨\n# → 색감이 다양하지만 극단적인 밝기 변화는 아님(표준편차 중간 수준)\n\n# [초록색 계열]은 밝은 색상이 넓게 분포하고 있으며, 비교적 균일한 색감을 유지함\n\n# [파란색 계열]은 밝은 색상과 어두운 색상이 모두 존재하며, 명암 대비가 큼\n# → 그림자나 반사광 효과가 강하게 작용했을 가능성이 있음\n\n## 각 채널의 히스토그램2\ncolors = ('red', 'green', 'blue')\n\nplt.figure(figsize=(8, 3))\nfor i, color in enumerate(colors):\n    plt.hist(img_array[:, :, i].ravel(), bins=np.arange(257), color=color, alpha=0.5, label=color)\n    \nplt.title('RGB Histogram')\nplt.xlabel('Pixel Value')\nplt.ylabel('Frequency')\nplt.legend()\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "4_1_numpy.html",
    "href": "4_1_numpy.html",
    "title": "4. 라이브러리",
    "section": "",
    "text": "NumPy\n\nNumerical Python의 약자로, C언어로 구현된 Python 라이브러리\n고성능 수치 계산, 대규모 다차원 배열 및 행렬 연산에 최적화\n\n\n\n\n넘파이 배열(ndarray)\n\n리스트처럼 데이터를 모아 저장하는 자료구조\n모든 원소가 동일한 자료형으로 저장(효율적인 메모리 관리 및 빠른 연산)\n대규모 데이터 처리에 유리함\n반복문 없이 배열 간 연산이 가능한 브로드캐스팅 및 벡터화 연산 지원\n다양한 수학 함수, 선형대수, 난수 생성 기능 제공\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nnp.array()\n리스트, 튜플 등으로부터 배열 생성\n\n\nnp.zeros()\n모든 값이 0인 배열 생성\n\n\nnp.ones()\n모든 값이 1인 배열 생성\n\n\nnp.full()\n지정한 값으로 이루어진 배열 생성\n\n\nnp.arange()\n범위를 지정하여 연속적인 값의 배열 생성(range()와 비슷)\n\n\nnp.linspace()\n시작과 끝을 기준으로, 지정한 개수만큼 일정 간격의 값으로 배열 생성\n\n\nnp.eye()\n행과 열의 크기를 지정할 수 있는 단위행렬(2차원 배열) 생성\n\n\nnp.identity()\n정방 단위행렬(2차원 배열) 생성\n\n\n\n\nimport numpy as np\n\n\n# 넘파이 배열 생성1\narr1 = np.array([1, 2, 3])\narr2 = np.array((6, 7, 8, 9))\nprint(arr1)\nprint(arr2)\n\n[1 2 3]\n[6 7 8 9]\n\n\n\n# 넘파이 배열 생성2\narr1 = np.zeros(5)\narr2 = np.ones(3)\narr3 = np.full(2, 5)\nprint(arr1)\nprint(arr2)\nprint(arr3)\n\n[0. 0. 0. 0. 0.]\n[1. 1. 1.]\n[5 5]\n\n\n\n# 넘파이 배열 생성3\narr1 = np.arange(10)\narr2 = np.arange(3, 6)\narr3 = np.arange(1, 11, 2)\narr4 = np.arange(0, 1, 0.1)\nprint(arr1)\nprint(arr2)\nprint(arr3)\nprint(arr4)\n\n[0 1 2 3 4 5 6 7 8 9]\n[3 4 5]\n[1 3 5 7 9]\n[0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]\n\n\n\n# 넘파이 배열 생성4\narr = np.linspace(0, 1, 5)\nprint(arr)\n\n[0.   0.25 0.5  0.75 1.  ]\n\n\n\n# 넘파이 배열 생성5\narr1 = np.eye(3)\narr2 = np.eye(3, 4, k=1)\nprint(arr1)\nprint(arr2)\n\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n[[0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n\n\n\n# 넘파이 배열 생성6 : np.identity()는 np.eye()의 특수한 경우\narr = np.identity(4)\nprint(arr)\n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n\n\n\n\n\n\n\n\n\n속성\n설명\n\n\n\n\n.dtype\n배열 원소의 자료형\n\n\n.ndim\n배열의 차원 수\n\n\n.shape\n배열의 모양(행, 열)\n\n\n.size\n배열의 전체 원소 개수\n\n\n.itemsize\n원소 하나의 메모리 크기\n\n\n\n\n# 넘파이 배열 속성\narr = np.array([[1, 2, 3], [4, 5, 6]])       # 2차원 배열\nprint(arr)\nprint(arr.dtype)\nprint(arr.ndim)\nprint(arr.shape)\nprint(arr.size)\nprint(arr.itemsize)\n\n[[1 2 3]\n [4 5 6]]\nint32\n2\n(2, 3)\n6\n4\n\n\n\n\n\n\n\n\n\n\n넘파이 배열의 차원\n\n관측하고자 하는 데이터의 속성의 수 또는 측정 항목의 수\n스칼라(scalar) : 0차원 배열, 배열에서 값을 표현하는 가장 기본 단위로 하나의 실수를 저장할 수 있음\n벡터(vector) : 1차원 배열, 스칼라 여러 개를 나열한 배열\n행렬(matrix) : 2차원 배열, 1차원 배열을 여러 개 묶은 배열\n텐서(tensor) : 3차원 이상의 배열, 벡터의 집합\n\n\n\n\narr0 = np.array(3.14)                        # 0차원 배열(스칼라)\narr1 = np.array([3.14])                      # 1차원 배열(벡터)\narr2 = np.array([[3.14]])                    # 2차원 배열(행렬)\narr3 = np.array([[[3.14]]])                  # 3차원 배열(텐서)\n\nprint(arr0.ndim, arr0.shape)\nprint(arr1.ndim, arr1.shape)\nprint(arr2.ndim, arr2.shape)\nprint(arr3.ndim, arr3.shape)\n\n0 ()\n1 (1,)\n2 (1, 1)\n3 (1, 1, 1)\n\n\n\n# 1차원 배열(벡터)\narr = np.array([1, 2, 3])\nprint(arr.ndim)\nprint(arr.shape)\n\n1\n(3,)\n\n\n\n# 2차원 배열(행렬)\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr.ndim)\nprint(arr.shape)\n\n2\n(2, 3)\n\n\n\n# 3차원 배열(텐서)\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[11, 12, 13], [14, 15, 16]]])\nprint(arr.ndim)\nprint(arr.shape)\n\n3\n(2, 2, 3)\n\n\n\n\n\n\n\n배열에서 데이터를 따라가는 방향\n\n차원이 있는 데이터에서 어느 방향으로 연산을 적용하는지 축으로 지정\n\naxis 0은 첫 번째 차원으로, 배열의 가장 바깥쪽 차원임\n\n차원이 늘어날수록 새로운 축이 axis=0가 되며, 기존 축들은 번호가 하나씩 뒤로 밀림\n\n축 번호는 배열의 차원에 따라 증가하며, 각 축은 shape에서 해당하는 차원의 크기를 나타냄\n\n(예) shape (2, 3, 4) → axis 0: 2(면), axis 1: 3(행), axis 2: 4(열)\n\n\n\n\n\n\n\n\n\n\n\n\n차원\n직관적인 구조\n축의 역할\n\n\n\n\n1차원\n벡터 → [1, 2, 3, 4]\naxis 0: 왼쪽 → 오른쪽\n\n\n2차원\n벡터들이 위아래로 쌓임 → 행렬\naxis 0: 위 → 아래(행) axis 1: 왼쪽 → 오른쪽(열)\n\n\n3차원\n행렬들이 앞뒤로 쌓임\naxis 0: 앞 → 뒤(면) axis 1: 위 → 아래(행) axis 2: 왼쪽 → 오른쪽(열)\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nsum()\n합계\n\n\nmean()\n평균\n\n\nstd()\n표준편차\n\n\nmin(), max()\n최소값, 최대값\n\n\ncumsum(), cumprod()\n누적 합계, 누적 곱\n\n\ntranspose()\n축 순서 변경\n\n\n\n\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\n# 합계\nprint(np.sum(arr))\nprint(np.sum(arr, axis=0))\nprint(np.sum(arr, axis=1))\n\n21\n[5 7 9]\n[ 6 15]\n\n\n\n# 누적합\nprint(np.cumsum(arr))\nprint(np.cumsum(arr, axis=0))\nprint(np.cumsum(arr, axis=1))\n\n[ 1  3  6 10 15 21]\n[[1 2 3]\n [5 7 9]]\n[[ 1  3  6]\n [ 4  9 15]]\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nreshape()\n배열을 데이터 변경없이 새로운 모양으로 변환\n\n\nflatten()\n다차원 배열을 1차원 배열로 복사하여 반환(원본 유지)\n\n\nravel()\n다차원 배열을 1차원 배열로 반환(가능하면 원본 공유, 더 효율적)\n\n\n\n\n# 1차원 배열 → 2차원 배열(3행 2열)\narr = np.array([1, 2, 3, 4, 5, 6])\n\nprint(arr.reshape(3, 2))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[[1 2]\n [3 4]\n [5 6]]\n[1 2 3 4 5 6]\n\n\n\n# 1차원 배열 → 3차원 배열\narr = np.arange(24)\n\nprint(arr.reshape(2, 3, 4))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[[[ 0  1  2  3]\n  [ 4  5  6  7]\n  [ 8  9 10 11]]\n\n [[12 13 14 15]\n  [16 17 18 19]\n  [20 21 22 23]]]\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]\n\n\n\n# 2차원 배열 → 1차원 배열 (복사본 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.flatten())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n\n\n\n# 2차원 배열 → 1차원 배열 (가능하면 뷰 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.ravel())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ntranspose()\n배열의 축 순서 변환(2차원 배열의 경우 행/열 전치)\n\n\nswaqaxes()\n지정한 두 축의 순서를 교환\n\n\n\n\n# 2차원 배열에서 transpose()\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.transpose())\n\n[[1 4]\n [2 5]\n [3 6]]\n\n\n\n# 3차원 배열에서 transpose()\narr = np.arange(24).reshape(2, 3, 4)\n\n# 축 순서 바꾸기 : (0, 1, 2) → (1, 0, 2)\nprint(arr.transpose(1, 0, 2))\nprint(arr.transpose(1, 0, 2).shape)\n\n[[[ 0  1  2  3]\n  [12 13 14 15]]\n\n [[ 4  5  6  7]\n  [16 17 18 19]]\n\n [[ 8  9 10 11]\n  [20 21 22 23]]]\n(3, 2, 4)\n\n\n\n# 3차원 배열에서 axis 0과 axis 2 교환\narr = np.array([\n    [[1, 2], [3, 4]],\n    [[5, 6], [7, 8]]\n])\n\nprint(np.swapaxes(arr, 0, 2))\nprint(np.swapaxes(arr, 0, 2).shape)\n\n[[[1 5]\n  [3 7]]\n\n [[2 6]\n  [4 8]]]\n(2, 2, 2)\n\n\n\n\n\n\n\n얕은 복사(shallow copy)\n\n데이터의 주소를 복사하여 원본과 메모리 공간을 공유\n원본을 수정하면 복사본이 바뀌며, 반대로 복사본을 수정해도 원본에 영향을 미침\nview(), reshape() (대부분), ravel() (대부분)\n\n\n\n\n깊은 복사(deep copy)\n\n완전히 새로운 메모리 공간에 데이터의 복사본을 생성\n원본을 수정해도 복사본이 바뀌지 않으며, 반대로 복사본을 수정해도 원본에 영향을 주지 않음\ncopy(), flatten()\n\n\n\n# 얕은 복사\narr = np.arange(6)\nprint(arr)\n\ncopy_arr = arr.view()\nprint(copy_arr)\n\ncopy_arr[0] = 10\nprint(arr)\nprint(copy_arr)\n\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n[10  1  2  3  4  5]\n[10  1  2  3  4  5]\n\n\n\n# 깊은 복사\narr = np.arange(6)\nprint(arr)\n\ncopy_arr = arr.copy()\nprint(copy_arr)\n\ncopy_arr[0] = 10\nprint(arr)\nprint(copy_arr)\n\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n[10  1  2  3  4  5]\n\n\n\n\n\n\n\n\n인덱싱(indexing)\n\n[index]를 사용하여 배열의 특정 위치에 있는 원소에 접근함\n얕은 복사(shallow copy)로 작동 → 원본과 메모리 공간을 공유\n팬시 인덱싱(fancy indexing)\n\n배열이나 리스트를 인덱스로 사용하여 원하는 위치의 값들을 한 번에 추출\n복사본을 반환(deep copy) → 원본과 메모리 공간을 공유하지 않음\n\n불리언 인덱싱(boolean indexing)\n\n조건식을 통해 bool형 배열을 생성하여 True인 원소만 추출\n복사본을 반환(deep copy) → 원본과 메모리 공간을 공유하지 않음\n\n\n\n\n\n슬라이싱(slicing)\n\n[(start index):(stop index)]를 사용하여 배열의 일부 원소를 추출함\n얕은 복사(shallow copy)로 작동하며 뷰(view)를 반환 → 원본과 메모리 공간을 공유\n\n\n\n# 1차원 인덱싱과 슬라이싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[0])\nprint(arr[-1])\nprint(arr[1:4])\nprint(arr[::2])\n\n10\n50\n[20 30 40]\n[10 30 50]\n\n\n\n# 슬라이싱은 기본적으로 뷰(view)임\narr = np.array([10, 20, 30, 40, 50])\nprint(arr)\n\nsub_arr = arr[1:4]\nprint(sub_arr)\n\nsub_arr[0] = 100\nprint(arr)\nprint(sub_arr)\n\n[10 20 30 40 50]\n[20 30 40]\n[ 10 100  30  40  50]\n[100  30  40]\n\n\n\n# copy() 함수를 이용해서 깊은 복사를 해야 원본이 변하지 않음\narr = np.array([10, 20, 30, 40, 50])\nprint(arr)\n\nsub_arr = arr[1:4].copy()\nprint(sub_arr)\n\nsub_arr[0] = 100\nprint(arr)\nprint(sub_arr)\n\n[10 20 30 40 50]\n[20 30 40]\n[10 20 30 40 50]\n[100  30  40]\n\n\n\n# 2차원 인덱싱과 슬라이싱\narr = np.array([[1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]])\nprint(arr[1, 2])                           # arr[1][2], 리스트에서는 안 됨\nprint(arr[0:2, 1:3])\nprint(arr[0])                              # 첫 번째 행의 모든 열\nprint(arr[:, 1])                           # 모든 행의 두 번째 열\nprint(arr[1:, :2])                         # 두 번째 행부터 끝까지, 처음부터 두 번째 열까지\n\n6\n[[2 3]\n [5 6]]\n[1 2 3]\n[2 5 8]\n[[4 5]\n [7 8]]\n\n\n\n# 3차원 인덱싱과 슬라이싱\narr = np.arange(24).reshape(2, 3, 4)\n\nprint(arr[1, 2])                           # arr[1][2], 리스트에서는 안 됨\nprint(arr[1, 2, 3])                        # 두 번째 면, 세 번째 행, 네 번째 열\nprint(arr[:, 1, :])                        # 모든 면의 두 번째 행 → shape(2, 4)\n\n[20 21 22 23]\n23\n[[ 4  5  6  7]\n [16 17 18 19]]\n\n\n\n# 팬시 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[[0, 3, 4]])\n\n[10 40 50]\n\n\n\n# 불리언 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr &gt; 30)\nprint(arr[arr &gt; 30])\n\n[False False False  True  True]\n[40 50]\n\n\n\n\n\n\n\n벡터화(vectorization)\n\n반복문을 사용하지 않고 배열 전체에 연산을 적용하는 기능\n동일한 shape을 가진 배열 간에 같은 인덱스에 위치한 원소들끼리(element-wise) 연산을 수행함\n\n두 배열의 shape가 다르더라도 브로드캐스팅이 가능한 경우에는 연산이 가능함\n\n이 경우 내부적으로 브로드캐스팅을 통해 shape를 맞춘 후, 벡터화 연산을 수행함\n\n\n\n\n\n브로드캐스팅(broadcasting)\n\n차원이 서로 다른 배열 간의 연산을 자동으로 처리해주는 기능\n더 작은 차원인 배열의 shape를 자동으로 확장하여 연산이 가능하도록 함\n브로드캐스팅이 적용되는 조건\n\n차원이 다르면, 더 작은 배열 앞쪽(왼쪽)에 1을 추가해서 맞춰줌\n차원이 같으면, 각 차원의 크기를 비교하여 두 값이 같거나 한 쪽이 1이면 브로드캐스팅 가능함\n\n\n\n\n\n\n# 벡터화\narr1 = np.array([1, 2, 3])\narr2 = np.array([10, 20, 30])\n\nprint(arr1 + arr2)\nprint(arr1 / arr2)\n\n[11 22 33]\n[0.1 0.1 0.1]\n\n\n\n# 브로드캐스팅1 : 1차원 + 스칼라\narr = np.array([1, 2, 3])\nprint(arr + 10)\n\n[11 12 13]\n\n\n\n# 브로드캐스팅2 : 차원 수가 다른 경우\narr1 = np.array([[1], [2], [3]])           # shape : (3, 1)\narr2 = np.array([10, 20, 30, 40])          # shape : (4,) → (1, 4)로 간주\n\nprint(arr1.shape, arr2.shape)\nprint(arr1 + arr2)                \n\n(3, 1) (4,)\n[[11 21 31 41]\n [12 22 32 42]\n [13 23 33 43]]\n\n\n\n# 브로드캐스팅3 : 두 배열의 열 크기가 다르므로 브로드캐스팅 불가능\n#arr1 = np.array([[1, 2, 3],\n#                 [4, 5, 6]])               # shape : (2, 3)\n#arr2 = np.array([10, 20, 30, 40])          # shape: (4,) → (1, 4)로 간주\n#\n#print(arr1.shape, arr2.shape)\n#print(arr1 + arr2)\n\n\n# 브로드캐스팅 : 3차원 + 1차원\narr1 = np.arange(24).reshape(2, 3, 4)      # shape : (2, 3, 4)\narr2 = np.array([10, 20, 30, 40])          # shape : (4,) → (1, 1, 4)로 간주\n\nprint(arr1.shape, arr2.shape)\nprint((arr1 + arr2).shape)                 # shaep : (2, 3, 4)\nprint(arr1 + arr2)\n\n(2, 3, 4) (4,)\n(2, 3, 4)\n[[[10 21 32 43]\n  [14 25 36 47]\n  [18 29 40 51]]\n\n [[22 33 44 55]\n  [26 37 48 59]\n  [30 41 52 63]]]"
  },
  {
    "objectID": "4_1_numpy.html#numpy-라이브러리",
    "href": "4_1_numpy.html#numpy-라이브러리",
    "title": "4. 라이브러리",
    "section": "",
    "text": "NumPy\n\nNumerical Python의 약자로, C언어로 구현된 Python 라이브러리\n고성능 수치 계산, 대규모 다차원 배열 및 행렬 연산에 최적화\n\n\n\n\n넘파이 배열(ndarray)\n\n리스트처럼 데이터를 모아 저장하는 자료구조\n모든 원소가 동일한 자료형으로 저장(효율적인 메모리 관리 및 빠른 연산)\n대규모 데이터 처리에 유리함\n반복문 없이 배열 간 연산이 가능한 브로드캐스팅 및 벡터화 연산 지원\n다양한 수학 함수, 선형대수, 난수 생성 기능 제공\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nnp.array()\n리스트, 튜플 등으로부터 배열 생성\n\n\nnp.zeros()\n모든 값이 0인 배열 생성\n\n\nnp.ones()\n모든 값이 1인 배열 생성\n\n\nnp.full()\n지정한 값으로 이루어진 배열 생성\n\n\nnp.arange()\n범위를 지정하여 연속적인 값의 배열 생성(range()와 비슷)\n\n\nnp.linspace()\n시작과 끝을 기준으로, 지정한 개수만큼 일정 간격의 값으로 배열 생성\n\n\nnp.eye()\n행과 열의 크기를 지정할 수 있는 단위행렬(2차원 배열) 생성\n\n\nnp.identity()\n정방 단위행렬(2차원 배열) 생성\n\n\n\n\nimport numpy as np\n\n\n# 넘파이 배열 생성1\narr1 = np.array([1, 2, 3])\narr2 = np.array((6, 7, 8, 9))\nprint(arr1)\nprint(arr2)\n\n[1 2 3]\n[6 7 8 9]\n\n\n\n# 넘파이 배열 생성2\narr1 = np.zeros(5)\narr2 = np.ones(3)\narr3 = np.full(2, 5)\nprint(arr1)\nprint(arr2)\nprint(arr3)\n\n[0. 0. 0. 0. 0.]\n[1. 1. 1.]\n[5 5]\n\n\n\n# 넘파이 배열 생성3\narr1 = np.arange(10)\narr2 = np.arange(3, 6)\narr3 = np.arange(1, 11, 2)\narr4 = np.arange(0, 1, 0.1)\nprint(arr1)\nprint(arr2)\nprint(arr3)\nprint(arr4)\n\n[0 1 2 3 4 5 6 7 8 9]\n[3 4 5]\n[1 3 5 7 9]\n[0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]\n\n\n\n# 넘파이 배열 생성4\narr = np.linspace(0, 1, 5)\nprint(arr)\n\n[0.   0.25 0.5  0.75 1.  ]\n\n\n\n# 넘파이 배열 생성5\narr1 = np.eye(3)\narr2 = np.eye(3, 4, k=1)\nprint(arr1)\nprint(arr2)\n\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n[[0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n\n\n\n# 넘파이 배열 생성6 : np.identity()는 np.eye()의 특수한 경우\narr = np.identity(4)\nprint(arr)\n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n\n\n\n\n\n\n\n\n\n속성\n설명\n\n\n\n\n.dtype\n배열 원소의 자료형\n\n\n.ndim\n배열의 차원 수\n\n\n.shape\n배열의 모양(행, 열)\n\n\n.size\n배열의 전체 원소 개수\n\n\n.itemsize\n원소 하나의 메모리 크기\n\n\n\n\n# 넘파이 배열 속성\narr = np.array([[1, 2, 3], [4, 5, 6]])       # 2차원 배열\nprint(arr)\nprint(arr.dtype)\nprint(arr.ndim)\nprint(arr.shape)\nprint(arr.size)\nprint(arr.itemsize)\n\n[[1 2 3]\n [4 5 6]]\nint32\n2\n(2, 3)\n6\n4\n\n\n\n\n\n\n\n\n\n\n넘파이 배열의 차원\n\n관측하고자 하는 데이터의 속성의 수 또는 측정 항목의 수\n스칼라(scalar) : 0차원 배열, 배열에서 값을 표현하는 가장 기본 단위로 하나의 실수를 저장할 수 있음\n벡터(vector) : 1차원 배열, 스칼라 여러 개를 나열한 배열\n행렬(matrix) : 2차원 배열, 1차원 배열을 여러 개 묶은 배열\n텐서(tensor) : 3차원 이상의 배열, 벡터의 집합\n\n\n\n\narr0 = np.array(3.14)                        # 0차원 배열(스칼라)\narr1 = np.array([3.14])                      # 1차원 배열(벡터)\narr2 = np.array([[3.14]])                    # 2차원 배열(행렬)\narr3 = np.array([[[3.14]]])                  # 3차원 배열(텐서)\n\nprint(arr0.ndim, arr0.shape)\nprint(arr1.ndim, arr1.shape)\nprint(arr2.ndim, arr2.shape)\nprint(arr3.ndim, arr3.shape)\n\n0 ()\n1 (1,)\n2 (1, 1)\n3 (1, 1, 1)\n\n\n\n# 1차원 배열(벡터)\narr = np.array([1, 2, 3])\nprint(arr.ndim)\nprint(arr.shape)\n\n1\n(3,)\n\n\n\n# 2차원 배열(행렬)\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr.ndim)\nprint(arr.shape)\n\n2\n(2, 3)\n\n\n\n# 3차원 배열(텐서)\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[11, 12, 13], [14, 15, 16]]])\nprint(arr.ndim)\nprint(arr.shape)\n\n3\n(2, 2, 3)\n\n\n\n\n\n\n\n배열에서 데이터를 따라가는 방향\n\n차원이 있는 데이터에서 어느 방향으로 연산을 적용하는지 축으로 지정\n\naxis 0은 첫 번째 차원으로, 배열의 가장 바깥쪽 차원임\n\n차원이 늘어날수록 새로운 축이 axis=0가 되며, 기존 축들은 번호가 하나씩 뒤로 밀림\n\n축 번호는 배열의 차원에 따라 증가하며, 각 축은 shape에서 해당하는 차원의 크기를 나타냄\n\n(예) shape (2, 3, 4) → axis 0: 2(면), axis 1: 3(행), axis 2: 4(열)\n\n\n\n\n\n\n\n\n\n\n\n\n차원\n직관적인 구조\n축의 역할\n\n\n\n\n1차원\n벡터 → [1, 2, 3, 4]\naxis 0: 왼쪽 → 오른쪽\n\n\n2차원\n벡터들이 위아래로 쌓임 → 행렬\naxis 0: 위 → 아래(행) axis 1: 왼쪽 → 오른쪽(열)\n\n\n3차원\n행렬들이 앞뒤로 쌓임\naxis 0: 앞 → 뒤(면) axis 1: 위 → 아래(행) axis 2: 왼쪽 → 오른쪽(열)\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nsum()\n합계\n\n\nmean()\n평균\n\n\nstd()\n표준편차\n\n\nmin(), max()\n최소값, 최대값\n\n\ncumsum(), cumprod()\n누적 합계, 누적 곱\n\n\ntranspose()\n축 순서 변경\n\n\n\n\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\n# 합계\nprint(np.sum(arr))\nprint(np.sum(arr, axis=0))\nprint(np.sum(arr, axis=1))\n\n21\n[5 7 9]\n[ 6 15]\n\n\n\n# 누적합\nprint(np.cumsum(arr))\nprint(np.cumsum(arr, axis=0))\nprint(np.cumsum(arr, axis=1))\n\n[ 1  3  6 10 15 21]\n[[1 2 3]\n [5 7 9]]\n[[ 1  3  6]\n [ 4  9 15]]\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nreshape()\n배열을 데이터 변경없이 새로운 모양으로 변환\n\n\nflatten()\n다차원 배열을 1차원 배열로 복사하여 반환(원본 유지)\n\n\nravel()\n다차원 배열을 1차원 배열로 반환(가능하면 원본 공유, 더 효율적)\n\n\n\n\n# 1차원 배열 → 2차원 배열(3행 2열)\narr = np.array([1, 2, 3, 4, 5, 6])\n\nprint(arr.reshape(3, 2))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[[1 2]\n [3 4]\n [5 6]]\n[1 2 3 4 5 6]\n\n\n\n# 1차원 배열 → 3차원 배열\narr = np.arange(24)\n\nprint(arr.reshape(2, 3, 4))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[[[ 0  1  2  3]\n  [ 4  5  6  7]\n  [ 8  9 10 11]]\n\n [[12 13 14 15]\n  [16 17 18 19]\n  [20 21 22 23]]]\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]\n\n\n\n# 2차원 배열 → 1차원 배열 (복사본 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.flatten())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n\n\n\n# 2차원 배열 → 1차원 배열 (가능하면 뷰 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.ravel())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ntranspose()\n배열의 축 순서 변환(2차원 배열의 경우 행/열 전치)\n\n\nswaqaxes()\n지정한 두 축의 순서를 교환\n\n\n\n\n# 2차원 배열에서 transpose()\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.transpose())\n\n[[1 4]\n [2 5]\n [3 6]]\n\n\n\n# 3차원 배열에서 transpose()\narr = np.arange(24).reshape(2, 3, 4)\n\n# 축 순서 바꾸기 : (0, 1, 2) → (1, 0, 2)\nprint(arr.transpose(1, 0, 2))\nprint(arr.transpose(1, 0, 2).shape)\n\n[[[ 0  1  2  3]\n  [12 13 14 15]]\n\n [[ 4  5  6  7]\n  [16 17 18 19]]\n\n [[ 8  9 10 11]\n  [20 21 22 23]]]\n(3, 2, 4)\n\n\n\n# 3차원 배열에서 axis 0과 axis 2 교환\narr = np.array([\n    [[1, 2], [3, 4]],\n    [[5, 6], [7, 8]]\n])\n\nprint(np.swapaxes(arr, 0, 2))\nprint(np.swapaxes(arr, 0, 2).shape)\n\n[[[1 5]\n  [3 7]]\n\n [[2 6]\n  [4 8]]]\n(2, 2, 2)\n\n\n\n\n\n\n\n얕은 복사(shallow copy)\n\n데이터의 주소를 복사하여 원본과 메모리 공간을 공유\n원본을 수정하면 복사본이 바뀌며, 반대로 복사본을 수정해도 원본에 영향을 미침\nview(), reshape() (대부분), ravel() (대부분)\n\n\n\n\n깊은 복사(deep copy)\n\n완전히 새로운 메모리 공간에 데이터의 복사본을 생성\n원본을 수정해도 복사본이 바뀌지 않으며, 반대로 복사본을 수정해도 원본에 영향을 주지 않음\ncopy(), flatten()\n\n\n\n# 얕은 복사\narr = np.arange(6)\nprint(arr)\n\ncopy_arr = arr.view()\nprint(copy_arr)\n\ncopy_arr[0] = 10\nprint(arr)\nprint(copy_arr)\n\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n[10  1  2  3  4  5]\n[10  1  2  3  4  5]\n\n\n\n# 깊은 복사\narr = np.arange(6)\nprint(arr)\n\ncopy_arr = arr.copy()\nprint(copy_arr)\n\ncopy_arr[0] = 10\nprint(arr)\nprint(copy_arr)\n\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n[10  1  2  3  4  5]\n\n\n\n\n\n\n\n\n인덱싱(indexing)\n\n[index]를 사용하여 배열의 특정 위치에 있는 원소에 접근함\n얕은 복사(shallow copy)로 작동 → 원본과 메모리 공간을 공유\n팬시 인덱싱(fancy indexing)\n\n배열이나 리스트를 인덱스로 사용하여 원하는 위치의 값들을 한 번에 추출\n복사본을 반환(deep copy) → 원본과 메모리 공간을 공유하지 않음\n\n불리언 인덱싱(boolean indexing)\n\n조건식을 통해 bool형 배열을 생성하여 True인 원소만 추출\n복사본을 반환(deep copy) → 원본과 메모리 공간을 공유하지 않음\n\n\n\n\n\n슬라이싱(slicing)\n\n[(start index):(stop index)]를 사용하여 배열의 일부 원소를 추출함\n얕은 복사(shallow copy)로 작동하며 뷰(view)를 반환 → 원본과 메모리 공간을 공유\n\n\n\n# 1차원 인덱싱과 슬라이싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[0])\nprint(arr[-1])\nprint(arr[1:4])\nprint(arr[::2])\n\n10\n50\n[20 30 40]\n[10 30 50]\n\n\n\n# 슬라이싱은 기본적으로 뷰(view)임\narr = np.array([10, 20, 30, 40, 50])\nprint(arr)\n\nsub_arr = arr[1:4]\nprint(sub_arr)\n\nsub_arr[0] = 100\nprint(arr)\nprint(sub_arr)\n\n[10 20 30 40 50]\n[20 30 40]\n[ 10 100  30  40  50]\n[100  30  40]\n\n\n\n# copy() 함수를 이용해서 깊은 복사를 해야 원본이 변하지 않음\narr = np.array([10, 20, 30, 40, 50])\nprint(arr)\n\nsub_arr = arr[1:4].copy()\nprint(sub_arr)\n\nsub_arr[0] = 100\nprint(arr)\nprint(sub_arr)\n\n[10 20 30 40 50]\n[20 30 40]\n[10 20 30 40 50]\n[100  30  40]\n\n\n\n# 2차원 인덱싱과 슬라이싱\narr = np.array([[1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]])\nprint(arr[1, 2])                           # arr[1][2], 리스트에서는 안 됨\nprint(arr[0:2, 1:3])\nprint(arr[0])                              # 첫 번째 행의 모든 열\nprint(arr[:, 1])                           # 모든 행의 두 번째 열\nprint(arr[1:, :2])                         # 두 번째 행부터 끝까지, 처음부터 두 번째 열까지\n\n6\n[[2 3]\n [5 6]]\n[1 2 3]\n[2 5 8]\n[[4 5]\n [7 8]]\n\n\n\n# 3차원 인덱싱과 슬라이싱\narr = np.arange(24).reshape(2, 3, 4)\n\nprint(arr[1, 2])                           # arr[1][2], 리스트에서는 안 됨\nprint(arr[1, 2, 3])                        # 두 번째 면, 세 번째 행, 네 번째 열\nprint(arr[:, 1, :])                        # 모든 면의 두 번째 행 → shape(2, 4)\n\n[20 21 22 23]\n23\n[[ 4  5  6  7]\n [16 17 18 19]]\n\n\n\n# 팬시 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[[0, 3, 4]])\n\n[10 40 50]\n\n\n\n# 불리언 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr &gt; 30)\nprint(arr[arr &gt; 30])\n\n[False False False  True  True]\n[40 50]\n\n\n\n\n\n\n\n벡터화(vectorization)\n\n반복문을 사용하지 않고 배열 전체에 연산을 적용하는 기능\n동일한 shape을 가진 배열 간에 같은 인덱스에 위치한 원소들끼리(element-wise) 연산을 수행함\n\n두 배열의 shape가 다르더라도 브로드캐스팅이 가능한 경우에는 연산이 가능함\n\n이 경우 내부적으로 브로드캐스팅을 통해 shape를 맞춘 후, 벡터화 연산을 수행함\n\n\n\n\n\n브로드캐스팅(broadcasting)\n\n차원이 서로 다른 배열 간의 연산을 자동으로 처리해주는 기능\n더 작은 차원인 배열의 shape를 자동으로 확장하여 연산이 가능하도록 함\n브로드캐스팅이 적용되는 조건\n\n차원이 다르면, 더 작은 배열 앞쪽(왼쪽)에 1을 추가해서 맞춰줌\n차원이 같으면, 각 차원의 크기를 비교하여 두 값이 같거나 한 쪽이 1이면 브로드캐스팅 가능함\n\n\n\n\n\n\n# 벡터화\narr1 = np.array([1, 2, 3])\narr2 = np.array([10, 20, 30])\n\nprint(arr1 + arr2)\nprint(arr1 / arr2)\n\n[11 22 33]\n[0.1 0.1 0.1]\n\n\n\n# 브로드캐스팅1 : 1차원 + 스칼라\narr = np.array([1, 2, 3])\nprint(arr + 10)\n\n[11 12 13]\n\n\n\n# 브로드캐스팅2 : 차원 수가 다른 경우\narr1 = np.array([[1], [2], [3]])           # shape : (3, 1)\narr2 = np.array([10, 20, 30, 40])          # shape : (4,) → (1, 4)로 간주\n\nprint(arr1.shape, arr2.shape)\nprint(arr1 + arr2)                \n\n(3, 1) (4,)\n[[11 21 31 41]\n [12 22 32 42]\n [13 23 33 43]]\n\n\n\n# 브로드캐스팅3 : 두 배열의 열 크기가 다르므로 브로드캐스팅 불가능\n#arr1 = np.array([[1, 2, 3],\n#                 [4, 5, 6]])               # shape : (2, 3)\n#arr2 = np.array([10, 20, 30, 40])          # shape: (4,) → (1, 4)로 간주\n#\n#print(arr1.shape, arr2.shape)\n#print(arr1 + arr2)\n\n\n# 브로드캐스팅 : 3차원 + 1차원\narr1 = np.arange(24).reshape(2, 3, 4)      # shape : (2, 3, 4)\narr2 = np.array([10, 20, 30, 40])          # shape : (4,) → (1, 1, 4)로 간주\n\nprint(arr1.shape, arr2.shape)\nprint((arr1 + arr2).shape)                 # shaep : (2, 3, 4)\nprint(arr1 + arr2)\n\n(2, 3, 4) (4,)\n(2, 3, 4)\n[[[10 21 32 43]\n  [14 25 36 47]\n  [18 29 40 51]]\n\n [[22 33 44 55]\n  [26 37 48 59]\n  [30 41 52 63]]]"
  },
  {
    "objectID": "3_4_set.html",
    "href": "3_4_set.html",
    "title": "3. 자료구조",
    "section": "",
    "text": "세트(set)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 없는 집합 자료형(set data type)\n중복을 허용하지 않으며, 순서가 유지되지 않음\n\n리스트, 튜플과 달리 인덱싱과 슬라이싱이 불가능함\n\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n정수형, 부동소수점형, 문자열형, bool형, 튜플 등 해시 가능한(immutable) 자료형을 저장할 수 있는 컨테이너형 객체\n\n\n\n\n[참고] 해시(hash)\n\n데이터를 저장하거나 검색할 때 사용되는 고유한 숫자 값(해시 값)을 사용하는 과정\n세트와 딕셔너리는 내부적으로 해시 값을 사용하여 원소 또는 key에 빠르게 접근함(검색 속도가 빠름)\n해시 값은 변경되지 않아야 하므로, 불변형 객체만 사용할 수 있음\n\n\n\n\n세트 생성\n\n리터럴 방식(set literal)\n\n{}를 사용하여 세트를 직접 정의하는 방법\n{} 안에 원소(element)를 ,로 구분하여 나열함\n중복된 원소는 자동으로 제거됨\n\n생성자 방식(set constructor)\n\nset() 함수를 사용하여 세트를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 세트를 생성할 때 유용함\n빈 세트를 만들려면 반드시 set() 함수를 사용해야 함\n\n\n\n\n# 세트 생성1\nst = {1, 2, 3, 1, 1, 4}\nprint(st)\n\n{1, 2, 3, 4}\n\n\n\n# 세트 생성2\nst = set({1, 2, 3, 1, 1, 4})\nprint(st)\n\n{1, 2, 3, 4}\n\n\n\n# 세트 생성3 : 세트는 해시 가능한(immutable) 자료형을 저장할 수 있음\nst = {1, 3.14, \"Hello\", True, (1, 2, 3), \"Hello\", 1, 1, 1}\nprint(st)\n\n{1, 3.14, 'Hello', (1, 2, 3)}\n\n\n\n# 세트 생성4: iterable 객체 사용\nst = set(\"Hello\")\nprint(st)\n\n{'e', 'l', 'H', 'o'}\n\n\n\n# 세트 생성5 : iterable 객체 사용\nst1 = set([1, 2, 3, 1, 1, 4])\nst2 = set((1, 2, 3, 1, 1, 4))\nprint(st1)\nprint(st2)\n\n{1, 2, 3, 4}\n{1, 2, 3, 4}\n\n\n\n\n\n\n\n\n\n세트 전개 연산자 * : 세트의 개별 원소를 분리하여 다른 세트로 전개 - (예) {*세트}\n\n\n# 세트 전개\nst = {1, 2, 3, 1, 1, 4}\nprint({*st, *st})\nprint([11, 12, *st, 20])\n\n{1, 2, 3, 4}\n[11, 12, 1, 2, 3, 4, 20]\n\n\n\n\n\n\n\n\n\n연산\n연산자\n함수\n\n\n\n\n합집합\n|\nunion()\n\n\n교집합\n&\nintersection()\n\n\n차집합\n-\ndifference()\n\n\n대칭차집합\n^\nsymmetric_difference()\n\n\n부분집합 여부\n&lt;=\nissubset()\n\n\n\n\n\n\n# 세트 연산1\nA = {1, 2, 3}\nB = {3, 4, 5}\n\nprint(A | B)                               # 합집합\nprint(A & B)                               # 교집합\nprint(A - B)                               # 차집합\nprint(A ^ B)                               # 대칭차집합\nprint(A &lt;= B)                              # 부분집합 여부\n\n{1, 2, 3, 4, 5}\n{3}\n{1, 2}\n{1, 2, 4, 5}\nFalse\n\n\n\n# 세트 연산2\nA = {1, 2, 3}\nB = {3, 4, 5}\n\nprint(A.union(B))\nprint(A.intersection(B))\nprint(A.difference(B))\nprint(A.symmetric_difference(B))\nprint(A.issubset(B))\n\n{1, 2, 3, 4, 5}\n{3}\n{1, 2}\n{1, 2, 4, 5}\nFalse\n\n\n\n# 세트 연산3 : 여러 개의 세트를 연쇄적으로 한 번에 연산 가능\nA = {1, 2, 3}\nB = {3, 4, 5}\nC = {5, 6, 7}\n\n# 연산자 사용\nprint(A | B | C)\nprint(A & B & C)\n\n# 메소드 사용\nprint(A.union(B, C))\nprint(A.intersection(B, C))\n\n{1, 2, 3, 4, 5, 6, 7}\nset()\n{1, 2, 3, 4, 5, 6, 7}\nset()\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nadd()\n- 새로운 값을 세트에 추가\n\n\nupdate()\n- 여러 개 값을 세트에 추가\n\n\npop()\n- 임의의 값을 삭제하고 그 값을 반환 - 어떤 값을 삭제할지 예측 불가능\n\n\nremove()\n- 세트에서 일치하는 값을 삭제 - 일치하는 값이 없으면 오류가 발생함\n\n\ndiscard()\n- 세트에서 일치하는 값을 삭제 - 일치하는 값이 없어도 오류가 발생하지 않음\n\n\nclear()\n- 세트의 모든 원소를 삭제\n\n\nin 연산자\n세트 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\n\n\n# 세트에 한 개의 원소 추가\nst = {1, 2, 3}\nst.add(6)                                  # 실행 결과로 아무것도 출력하지 않음\nprint(st)                                  # st 원본 값이 변함\n\n{1, 2, 3, 6}\n\n\n\n# 세트에 여러 개의 원소 추가\nst = {1, 2, 3}\nst.update([1, 2, 6])                       # 리스트 사용\nprint(st)\n\nst.update((1, 7))                          # 튜플 사용\nprint(st)\n\nst.update({8, 9})                          # 세트 사용\nprint(st)\n\n{1, 2, 3, 6}\n{1, 2, 3, 6, 7}\n{1, 2, 3, 6, 7, 8, 9}\n\n\n\n# 임의의 원소 삭제\nst = {1, 2, 3}\nresult = st.pop()                          # 임의의 원소를 삭제 후 반환\nprint(st)                                  # st 원본 값이 변함\nprint(result)\n\n{2, 3}\n1\n\n\n\n# 일치하는 값 삭제1\nst = {1, 2, 3}\nst.remove(3)\nprint(st)\n\n{1, 2}\n\n\n\n# 일치하는 값 삭제2 : remove() 함수는 일치하는 값이 없으면 오류가 발생함\n#st = {1, 2, 3}\n#st.remove(4)\n#print(st)\n\n\n# 일치하는 값 삭제3\nst = {1, 2, 3}\nst.discard(3)\nprint(st)\n\n{1, 2}\n\n\n\n# 일치하는 값 삭제4 : discard() 함수는 일치하는 값이 없어도 오류가 발생하지 않음\nst = {1, 2, 3}\nst.discard(4)\nprint(st)\n\n{1, 2, 3}\n\n\n\n# 세트 모든 원소 삭제\nst = {1, 2, 3}\nst.clear()\nprint(st)\n\nset()\n\n\n\n# 특정값 찾기\nst = {1, 2, 3}\nprint(3 in st)\nprint(6 in st)\n\nTrue\nFalse\n\n\n\n\n\n\n\n\n{식 for 변수 in 반복범위 if 조건식}\n\n\n리스트 컴프리헨션과 문법이 동일함\n자동으로 중복이 제거되므로 빠르고 편리함\n\n\n# 이메일 리스트에서 '@'가 포함된 유효한 이메일 주소만 추출\nemails = [\"user1@gmail.com\", \"user2\", \"test@yahoo.com\", \"invalid_email\", \"hello@naver.com\"]\nvalid_emails = {e for e in emails if \"@\" in e}\nprint(valid_emails)\n\n{'user1@gmail.com', 'hello@naver.com', 'test@yahoo.com'}\n\n\n\n# 문장에서 알파벳 문자만 추출 (중복 제거)\nsentence = \"Python is amazing! 123\"\nunique_chars = {char.lower() for char in sentence if char.isalpha()}\nprint(unique_chars)\n\n{'y', 't', 'i', 'z', 'h', 'n', 'a', 'g', 's', 'm', 'o', 'p'}\n\n\n\n# 주어진 숫자 리스트에서 짝수의 제곱을 저장하는 세트\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_squares = {n**2 for n in numbers if n % 2 == 0}\nprint(even_squares) \n\n{64, 100, 4, 36, 16}\n\n\n\n# 웹사이트 방문 기록에서 도메인만 추출 (중복 제거)\nurls = [\"https://google.com\", \"http://example.com\", \"https://google.com\", \"https://openai.com\"]\ndomains = {url.split(\"//\")[1] for url in urls}\nprint(domains)\n\n{'google.com', 'example.com', 'openai.com'}\n\n\n\n# 두 개의 리스트에서 공통된 단어만 저장 (중복 없이)\nwords1 = [\"apple\", \"banana\", \"cherry\", \"durian\"]\nwords2 = [\"banana\", \"durian\", \"fig\", \"grape\"]\ncommon_words = {word for word in words1 if word in words2}\nprint(common_words)  \n\n{'durian', 'banana'}"
  },
  {
    "objectID": "3_4_set.html#세트",
    "href": "3_4_set.html#세트",
    "title": "3. 자료구조",
    "section": "",
    "text": "세트(set)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 없는 집합 자료형(set data type)\n중복을 허용하지 않으며, 순서가 유지되지 않음\n\n리스트, 튜플과 달리 인덱싱과 슬라이싱이 불가능함\n\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n정수형, 부동소수점형, 문자열형, bool형, 튜플 등 해시 가능한(immutable) 자료형을 저장할 수 있는 컨테이너형 객체\n\n\n\n\n[참고] 해시(hash)\n\n데이터를 저장하거나 검색할 때 사용되는 고유한 숫자 값(해시 값)을 사용하는 과정\n세트와 딕셔너리는 내부적으로 해시 값을 사용하여 원소 또는 key에 빠르게 접근함(검색 속도가 빠름)\n해시 값은 변경되지 않아야 하므로, 불변형 객체만 사용할 수 있음\n\n\n\n\n세트 생성\n\n리터럴 방식(set literal)\n\n{}를 사용하여 세트를 직접 정의하는 방법\n{} 안에 원소(element)를 ,로 구분하여 나열함\n중복된 원소는 자동으로 제거됨\n\n생성자 방식(set constructor)\n\nset() 함수를 사용하여 세트를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 세트를 생성할 때 유용함\n빈 세트를 만들려면 반드시 set() 함수를 사용해야 함\n\n\n\n\n# 세트 생성1\nst = {1, 2, 3, 1, 1, 4}\nprint(st)\n\n{1, 2, 3, 4}\n\n\n\n# 세트 생성2\nst = set({1, 2, 3, 1, 1, 4})\nprint(st)\n\n{1, 2, 3, 4}\n\n\n\n# 세트 생성3 : 세트는 해시 가능한(immutable) 자료형을 저장할 수 있음\nst = {1, 3.14, \"Hello\", True, (1, 2, 3), \"Hello\", 1, 1, 1}\nprint(st)\n\n{1, 3.14, 'Hello', (1, 2, 3)}\n\n\n\n# 세트 생성4: iterable 객체 사용\nst = set(\"Hello\")\nprint(st)\n\n{'e', 'l', 'H', 'o'}\n\n\n\n# 세트 생성5 : iterable 객체 사용\nst1 = set([1, 2, 3, 1, 1, 4])\nst2 = set((1, 2, 3, 1, 1, 4))\nprint(st1)\nprint(st2)\n\n{1, 2, 3, 4}\n{1, 2, 3, 4}\n\n\n\n\n\n\n\n\n\n세트 전개 연산자 * : 세트의 개별 원소를 분리하여 다른 세트로 전개 - (예) {*세트}\n\n\n# 세트 전개\nst = {1, 2, 3, 1, 1, 4}\nprint({*st, *st})\nprint([11, 12, *st, 20])\n\n{1, 2, 3, 4}\n[11, 12, 1, 2, 3, 4, 20]\n\n\n\n\n\n\n\n\n\n연산\n연산자\n함수\n\n\n\n\n합집합\n|\nunion()\n\n\n교집합\n&\nintersection()\n\n\n차집합\n-\ndifference()\n\n\n대칭차집합\n^\nsymmetric_difference()\n\n\n부분집합 여부\n&lt;=\nissubset()\n\n\n\n\n\n\n# 세트 연산1\nA = {1, 2, 3}\nB = {3, 4, 5}\n\nprint(A | B)                               # 합집합\nprint(A & B)                               # 교집합\nprint(A - B)                               # 차집합\nprint(A ^ B)                               # 대칭차집합\nprint(A &lt;= B)                              # 부분집합 여부\n\n{1, 2, 3, 4, 5}\n{3}\n{1, 2}\n{1, 2, 4, 5}\nFalse\n\n\n\n# 세트 연산2\nA = {1, 2, 3}\nB = {3, 4, 5}\n\nprint(A.union(B))\nprint(A.intersection(B))\nprint(A.difference(B))\nprint(A.symmetric_difference(B))\nprint(A.issubset(B))\n\n{1, 2, 3, 4, 5}\n{3}\n{1, 2}\n{1, 2, 4, 5}\nFalse\n\n\n\n# 세트 연산3 : 여러 개의 세트를 연쇄적으로 한 번에 연산 가능\nA = {1, 2, 3}\nB = {3, 4, 5}\nC = {5, 6, 7}\n\n# 연산자 사용\nprint(A | B | C)\nprint(A & B & C)\n\n# 메소드 사용\nprint(A.union(B, C))\nprint(A.intersection(B, C))\n\n{1, 2, 3, 4, 5, 6, 7}\nset()\n{1, 2, 3, 4, 5, 6, 7}\nset()\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nadd()\n- 새로운 값을 세트에 추가\n\n\nupdate()\n- 여러 개 값을 세트에 추가\n\n\npop()\n- 임의의 값을 삭제하고 그 값을 반환 - 어떤 값을 삭제할지 예측 불가능\n\n\nremove()\n- 세트에서 일치하는 값을 삭제 - 일치하는 값이 없으면 오류가 발생함\n\n\ndiscard()\n- 세트에서 일치하는 값을 삭제 - 일치하는 값이 없어도 오류가 발생하지 않음\n\n\nclear()\n- 세트의 모든 원소를 삭제\n\n\nin 연산자\n세트 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\n\n\n# 세트에 한 개의 원소 추가\nst = {1, 2, 3}\nst.add(6)                                  # 실행 결과로 아무것도 출력하지 않음\nprint(st)                                  # st 원본 값이 변함\n\n{1, 2, 3, 6}\n\n\n\n# 세트에 여러 개의 원소 추가\nst = {1, 2, 3}\nst.update([1, 2, 6])                       # 리스트 사용\nprint(st)\n\nst.update((1, 7))                          # 튜플 사용\nprint(st)\n\nst.update({8, 9})                          # 세트 사용\nprint(st)\n\n{1, 2, 3, 6}\n{1, 2, 3, 6, 7}\n{1, 2, 3, 6, 7, 8, 9}\n\n\n\n# 임의의 원소 삭제\nst = {1, 2, 3}\nresult = st.pop()                          # 임의의 원소를 삭제 후 반환\nprint(st)                                  # st 원본 값이 변함\nprint(result)\n\n{2, 3}\n1\n\n\n\n# 일치하는 값 삭제1\nst = {1, 2, 3}\nst.remove(3)\nprint(st)\n\n{1, 2}\n\n\n\n# 일치하는 값 삭제2 : remove() 함수는 일치하는 값이 없으면 오류가 발생함\n#st = {1, 2, 3}\n#st.remove(4)\n#print(st)\n\n\n# 일치하는 값 삭제3\nst = {1, 2, 3}\nst.discard(3)\nprint(st)\n\n{1, 2}\n\n\n\n# 일치하는 값 삭제4 : discard() 함수는 일치하는 값이 없어도 오류가 발생하지 않음\nst = {1, 2, 3}\nst.discard(4)\nprint(st)\n\n{1, 2, 3}\n\n\n\n# 세트 모든 원소 삭제\nst = {1, 2, 3}\nst.clear()\nprint(st)\n\nset()\n\n\n\n# 특정값 찾기\nst = {1, 2, 3}\nprint(3 in st)\nprint(6 in st)\n\nTrue\nFalse\n\n\n\n\n\n\n\n\n{식 for 변수 in 반복범위 if 조건식}\n\n\n리스트 컴프리헨션과 문법이 동일함\n자동으로 중복이 제거되므로 빠르고 편리함\n\n\n# 이메일 리스트에서 '@'가 포함된 유효한 이메일 주소만 추출\nemails = [\"user1@gmail.com\", \"user2\", \"test@yahoo.com\", \"invalid_email\", \"hello@naver.com\"]\nvalid_emails = {e for e in emails if \"@\" in e}\nprint(valid_emails)\n\n{'user1@gmail.com', 'hello@naver.com', 'test@yahoo.com'}\n\n\n\n# 문장에서 알파벳 문자만 추출 (중복 제거)\nsentence = \"Python is amazing! 123\"\nunique_chars = {char.lower() for char in sentence if char.isalpha()}\nprint(unique_chars)\n\n{'y', 't', 'i', 'z', 'h', 'n', 'a', 'g', 's', 'm', 'o', 'p'}\n\n\n\n# 주어진 숫자 리스트에서 짝수의 제곱을 저장하는 세트\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_squares = {n**2 for n in numbers if n % 2 == 0}\nprint(even_squares) \n\n{64, 100, 4, 36, 16}\n\n\n\n# 웹사이트 방문 기록에서 도메인만 추출 (중복 제거)\nurls = [\"https://google.com\", \"http://example.com\", \"https://google.com\", \"https://openai.com\"]\ndomains = {url.split(\"//\")[1] for url in urls}\nprint(domains)\n\n{'google.com', 'example.com', 'openai.com'}\n\n\n\n# 두 개의 리스트에서 공통된 단어만 저장 (중복 없이)\nwords1 = [\"apple\", \"banana\", \"cherry\", \"durian\"]\nwords2 = [\"banana\", \"durian\", \"fig\", \"grape\"]\ncommon_words = {word for word in words1 if word in words2}\nprint(common_words)  \n\n{'durian', 'banana'}"
  },
  {
    "objectID": "3_2_list.html",
    "href": "3_2_list.html",
    "title": "3. 자료구조",
    "section": "",
    "text": "리스트(list)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 존재하는 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n정수형, 부동소수점형, 문자열형, bool형, 리스트, 튜플, 딕셔너리 등 다양한 자료형을 저장할 수 있는 컨테이너형 객체\n\n\n\n\n리스트 생성\n\n리터럴 방식(list literal)\n\n[] 사용하여 리스트를 직접 정의하는 방법\n[] 안에 원소(element)를 ,로 구분하여 나열함\n\n생성자 방식(list constructor)\n\nlist() 함수를 사용하여 리스트를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)을 인수로 받아 리스트를 생성할 때 유용함\n\n\n\n\n# 리스트 생성1\nlst = [1, 2, 3, 4, 5]\nprint(lst)\n\n[1, 2, 3, 4, 5]\n\n\n\n# 리스트 생성2\nlst = list([1, 2, 3, 4, 5])\nprint(lst)\n\n[1, 2, 3, 4, 5]\n\n\n\n# 리스트 생성3 : 리스트는 다양한 자료형을 저장할 수 있음\nlst = [1, 3.14, \"Hello\", True, [11, 12, 13]]\nprint(lst)\n\n[1, 3.14, 'Hello', True, [11, 12, 13]]\n\n\n\n# 리스트 생성4 : iterable 객체 사용\nlst = list(\"Hello\")\nprint(lst)\n\n['H', 'e', 'l', 'l', 'o']\n\n\n\n# 리스트 생성5 : iterable 객체 사용\nlst = list(range(10))\nprint(lst)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\n\n\n\n문자열 연산과 동일함\n리스트 연결 연산자 + : 두 리스트를 연결해서 새로운 리스트 생성\n리스트 반복 연산자 * : 리스트를 숫자만큼 반복하여 새로운 리스트 생성 - (예) 리스트*숫자\n리스트 전개 연산자 * : 리스트의 개별 원소를 분리하여 다른 리스트로 전개 - (예) [*리스트]\n\n\n# 리스트 연결\nlst1 = [1, 2, 3]\nlst2 = [11, 12, 13]\nprint(lst1 + lst2)\n\n[1, 2, 3, 11, 12, 13]\n\n\n\n# 리스트 반복\nprint(lst1 * 3)\n\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n\n\n# 리스트 전개\nlst = [1, 2, 3]\nprint([lst, lst])\nprint([*lst, *lst])\n\n[[1, 2, 3], [1, 2, 3]]\n[1, 2, 3, 1, 2, 3]\n\n\n\n\n\n\n\n\n\n패킹(packing) : 여러 개의 데이터를 한 변수에 묶어 할당하는 것\n언패킹(unpacking)\n\n한 변수에 묶인 데이터를 개별적인 변수들에 할당하는 것\n언패킹 시 기본적으로 변수 개수가 맞아야 하지만, *를 사용하면 가변 개수도 처리할 수 있음\n\n\n\n# 리스트 패킹\nlst = [1, 2, 3]\nprint(lst)\n\n[1, 2, 3]\n\n\n\n# 리스트 언패킹\nlst = [1, 2, 3]\nx, y, z = lst\nprint(x)\nprint(y)\nprint(z)\n\n1\n2\n3\n\n\n\n# 언패킹 시 변수 개수 불일치 오류\n#a, b = [1, 2, 3]\n#x, y, z = [4, 5]\n\n\n# 언패킹 시 *을 이용한 가변 개수 처리\n*x, y, z = [5, 6, 7, 8]\nprint(x)\nprint(y)\nprint(z)\n\n[5, 6]\n7\n8\n\n\n\n\n\n\n\n가변 인수를 사용하면 전달된 인수들은 튜플로 패킹됨\n*를 사용하여 리스트를 언패킹하여 함수에 전달함\n\n\n\n[참고] 함수의 인수\n\n\n\n\n\n\n\n\n종류\n내용\n\n\n\n\n키워드 인수\n함수의 인터페이스에서 저장한 변수 이름을 사용하여 함수의 인수를 지정하는 방법\n\n\n디폴트 인수\n별도의 인수 값이 입력되지 않을 때 인터페이스 선언에서 지정한 초기 값을 사용하는 방법\n\n\n가변 인수\n함수의 인터페이스에서 지정하는 변수 이외의 추가 변수를 함수에 입력할 수 있도록 지원하는 방법\n\n\n키워드 가변 인수\n매개변수의 이름을 따로 지정하지 않고 입력하는 방법\n\n\n\n\n# 키워드 인수(keyword arguments)\ndef greet(name, greeting):\n    print(f\"{greeting}, {name}!\")\n\ngreet(name=\"Alice\", greeting=\"Hi\")\n\nHi, Alice!\n\n\n\n# 디폴트 인수(default arguments)\ndef greet(name, greeting=\"Hello\"):\n    print(f\"{greeting}, {name}!\")\n\ngreet(\"Alice\")\ngreet(\"Bob\", \"Hi\")\n\nHello, Alice!\nHi, Bob!\n\n\n\n# 가변 인수(variable-length arguments) : *로 표현\n# 함수에 전단하는 인수의 개수가 불확실할 때 사용\n# 가변 인수는 반드시 일반적인 키워드 인수에 대한 선언이 모두 끝난 후 마지막에 선언되어야 함\ndef sum_numbers(*args):\n    return sum(args)\n\nprint(sum_numbers(1, 2, 3))\nprint(sum_numbers(5, 10))\n\n6\n15\n\n\n\n# 키워드 가변 인수(keyword variable-length arguments) : **로 표현\n# 입력 받은 값은 딕셔너리 지료형임\n# 키워드 가변 인수는 반드시 모든 매개변수의 마지막에 선언되어야 함\ndef print_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"Alice\", age=25)\n\nname: Alice\nage: 25\n\n\n\n# 가변 인수와 패킹, 언패킹\ndef print_args(*args):\n    print(\"Packed arguments:\", args)                        # 전달된 값이 튜플로 패킹됨\n\nprint_args(1, 2, 3, 4)\n\nlst = [11, 12, 13]\nprint_args(lst)                                             # 리스트 자체를 인수로 전달\nprint_args(*lst)                                            # 리스트를 언패킹하여 함수에 전달\n\nPacked arguments: (1, 2, 3, 4)\nPacked arguments: ([11, 12, 13],)\nPacked arguments: (11, 12, 13)\n\n\n\n# 키워드 인수와 언패킹\ndef sum_numbers(a, b, c, d):\n    return a + b + c + d\n\nlst = [1, 2, 3, 4]\n\nprint(sum_numbers(lst[0], lst[1], lst[2], lst[3]))          # 개별 원소를 인수로 전달\nprint(sum_numbers(*lst))                                    # 리스트를 언패킹하여 함수에 전달\n\n10\n10\n\n\n\n\n\n\n\n함수에서 여러 개의 값을 반환하면 자동으로 튜플로 패킹됨\n반환 값을 리스트로 묶어(패킹) 반환할 수도 있음\n함수가 반환한 리스트를 언패킹하여 개별 변수에 할당할 수 있음\n\n\n# 반환값과 패킹, 언패킹\ndef get_student_info():\n    return [\"Alice\", 20, \"Statistics\"]                      # 리스트로 패킹함\n\n# 패킹된 값 출력\ninfo = get_student_info()\nprint(info)\n\n# 언패킹하여 개별 변수에 할당\nname, age, major = get_student_info()\nprint(name)\nprint(age)\nprint(major)\n\n['Alice', 20, 'Statistics']\nAlice\n20\nStatistics\n\n\n\n\n\n\n\n\n문자열과 문법이 동일함\n인덱싱(indexing) : [index]를 사용하여 리스트의 특정 위치에 있는 원소에 접근함\n슬라이싱(slicing) : [(start index):(stop index)]를 사용하여 리스트의 일부 원소를 추출함\n\nlist[(start index):(end index)] = iterable를 사용하면 start:end로 지정한 부분이 iterable 객체의 모든 원소로 대체됨\n슬라이싱을 이용하여 기존 리스트의 일부를 삭제하거나, 새로운 원소를 추가 및 변경할 수 있음\n\n\n\n\n# 리스트 인덱싱1\nlst = [10, 20, 30, 40, 50]\nprint(lst[0])\n\n10\n\n\n\n# 리스트 인덱싱2\nlst = [10, 20, 30, 40, 50]\nprint(lst[-1])\n\n50\n\n\n\n# 리스트 접근 연산자 []를 이중으로 사용할 수 있음\nlst = [1, 3.14, \"Hello\", True, [11, 12, 13]]\nprint(lst[2])\nprint(lst[2][0])\n\nHello\nH\n\n\n\n# 리스트 슬라이싱1\nlst = [10, 20, 30, 40, 50]\nprint(lst[0:2])\n\n[10, 20]\n\n\n\n# 리스트 슬라이싱2\nlst = [10, 20, 30, 40, 50]\nprint(lst[:2])\nprint(lst[2:])\nprint(lst[::2])\n\n[10, 20]\n[30, 40, 50]\n[10, 30, 50]\n\n\n\n# 리스트는 가변형 객체이므로 인덱스를 이용한 수정이 가능함\nlst = [10, 20, 30, 40, 50]\nlst[2] = 3\nprint(lst)\n\n[10, 20, 3, 40, 50]\n\n\n\n# 슬라이싱을 이용한 원소 삭제\nlst = [10, 20, 30, 40, 50]\nlst[1:4] = []                              # 빈 리스트를 할당하면 해당 부분이 삭제됨\nprint(lst)\n\n[10, 50]\n\n\n\n# 슬라이싱을 이용한 원소 추가\nlst = [10, 20, 30, 40, 50]\nlst[1:1] = [6, 7]                          # 인덱스 1 위치에 [6, 7]의 원소를 개별적으로 추가\nprint(lst)\n\n[10, 6, 7, 20, 30, 40, 50]\n\n\n\n# 슬라이싱을 이용한 원소 수정\nlst = [10, 20, 30, 40, 50]\nlst[1:3] = [6, 7, 8]                       # 인덱스 1~2 부분을 [6, 7, 8]로 수정\nprint(lst)\n\n[10, 6, 7, 8, 40, 50]\n\n\n\n\n\n\n\n리스트 안에 또 다른 리스트가 포함된 구조\n2차원 리스트\n\n모든 내부 리스트가 동일한 길이를 가진 경우\n일반적으로 행(row)과 열(column)로 이루어짐\n행렬(matrix)처럼 활용하거나, 데이터를 일정한 구조로 관리할 때 유용함\n\n\n\n# 중첩 리스트\nnested_lst = [\n    [1, 2, 3],\n    [4, 5, 6, 7],\n    [8, 9]\n]\n\nprint(nested_lst)\n\n[[1, 2, 3], [4, 5, 6, 7], [8, 9]]\n\n\n\nfor items in nested_lst:\n    for item in items:\n        print(item)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2차원 리스트\nkor = [80, 82, 75, 95]\neng = [67, 95, 84, 83]\nmath = [74, 88, 82, 76]\nmidterm = [kor, eng, math]\nprint(midterm)\n\n[[80, 82, 75, 95], [67, 95, 84, 83], [74, 88, 82, 76]]\n\n\n\n# 2차원 리스트 인덱싱\nmidterm[0][3]\n\n95\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nappend()\n- 새로운 값을 기존 리스트의 맨 끝에 추가\n\n\nextend()\n- 새로운 리스트를 기존 리스트에 추가(덧셈 연산과 같은 효과)\n\n\ninsert()\n- 기존 리스트의 i번째 인덱스에 새로운 값을 추가 - i번째 인덱스를 기준으로 뒤쪽의 인덱스는 하나씩 밀림\n\n\n\n\n# 리스트에 한 개의 원소 추가1\nlst = [1, 2, 3]\nlst.append(4)                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 4]\n\n\n\n# 리스트에 한 개의 원소 추가2\n# 원본 값 변화 없이 리스트에 한 개의 원소를 추가하려면 전개 연산자 *를 사용하면 됨\nlst = [1, 2, 3]\nnew_lst = [*lst, 4]\nprint(lst)                                 # lst 원본 값이 변하지 않음\nprint(new_lst)\n\n[1, 2, 3]\n[1, 2, 3, 4]\n\n\n\n# append() 함수는 여러 개의 인수를 입력하거나, 연속으로 사용할 수 없음\nlst = [1, 2, 3]\n#lst.append(4,5)\n#lst.append(4).append(5)\n\n\n# 리스트에 여러 개의 원소 추가\nlst = [1, 2, 3]\nlst.extend([11, 12])                       # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst1 원본 값이 변함\n\n[1, 2, 3, 11, 12]\n\n\n\n# extend() 함수와 리스트 연결 연산자 +의 차이\nlst1 = [1, 2, 3]\nlst2 = [11, 12, 13]\nlst1 + lst2                                # 실행 결과가 출력됨\nprint(lst1)                                # lst1 원본 값이 변하지 않음\nprint(lst2)                                # lst2 원본 값이 변하지 않음\n\n[1, 2, 3]\n[11, 12, 13]\n\n\n\n# 특정 위치에 한 개의 원소 추가\nlst = [1, 2, 3]\nlst.insert(0, 100)                         # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[100, 1, 2, 3]\n\n\n\n# 특정 위치에 여러 개의 원소 추가 : 슬라이싱을 이용\nlst = [1, 2, 3]\nlst[1:1] = [11, 12]                        # 인덱스 1의 위치에 리스트 [11, 12]의 원소를 개별적으로 삽입\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 11, 12, 2, 3]\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\npop()\n- 특정 인덱스 값을 삭제하고 그 값을 반환 - 인덱스를 생략하면 마지막 원소를 삭제\n\n\ndel 키워드\n- 특정 인덱스 값을 삭제 - 리스트 객체 자체를 삭제 가능함\n\n\nremove()\n- 리스트에서 첫 번째로 일치하는 값을 삭제 - 값으로 삭제하므로 인덱스를 사용하지 않음\n\n\nclear()\n- 리스트의 모든 원소를 삭제\n\n\n\n\n# 특정 인덱스 값 삭제1\nlst = [1, 2, 3, 4, 5]\nresult = lst.pop(3)                        # 실행 결과로 삭제한 값을 반환\nprint(lst)                                 # lst 원본 값이 변함\nprint(result)\n\n[1, 2, 3, 5]\n4\n\n\n\n# 특정 인덱스 값 삭제2\nlst = [1, 2, 3, 4, 5]\nresult = lst.pop()                         # 인덱스를 생략하면 마지막 원소를 삭제 후 반환\nprint(lst)                                 # lst 원본 값이 변함\nprint(result)\n\n[1, 2, 3, 4]\n5\n\n\n\n# 특정 인덱스 값 삭제3\nlst = [1, 2, 3, 4, 5]\ndel lst[3]                                 # 실행 결과로 아무것도 반환하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 5]\n\n\n\n# 리스트 객체 삭제\nlst = [1, 2, 3, 4, 5]\ndel lst\n#print(lst)\n\n\n# 일치하는 값 삭제1\nlst = [1, 2, 3, 4, 5]\nlst.remove(4)                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 5]\n\n\n\n# 일치하는 값 삭제2\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nlst.remove(1)                              # 첫 번째로 일치하는 값만 삭제됨\nprint(lst)                                 # lst 원본 값이 변함\n\n[2, 3, 1, 4, 5, 1, 6, 7]\n\n\n\n# 리스트 모든 원소 삭제\nlst = [1, 2, 3, 4, 5]\nlst.clear()                                # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[]\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nreverse()\n- 리스트 원소를 역순으로 재배열\n\n\nsort()\n- 리스트 원소를 오름차순(default)으로 정렬 - 내림차순으로 정렬하려면 reverse=True로 설정\n\n\n\n\n# 리스트 역순 재배열\nlst = [52, 273, 103, 32, 275, 1, 7]\nlst.reverse()                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[7, 1, 275, 32, 103, 273, 52]\n\n\n\n# 리스트 정렬\nlst = [52, 273, 103, 32, 275, 1, 7]\nlst.sort()                                 # 실행 결과로 아무것도 출력하지 않음, 오름차순 정렬\nprint(lst)                                 # lst 원본 값이 변함\n\nlst.sort(reverse=True)                     # 내림차순 정렬\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 7, 32, 52, 103, 273, 275]\n[275, 273, 103, 52, 32, 7, 1]\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ncount()\n리스트 내부에 특정 값이 몇 번 나타나는지 개수를 반환\n\n\nindex()\n리스트 내부에 특정 값의 첫 번째 인덱스를 반환하며, 없으면 오류 발생\n\n\nin 연산자\n리스트 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\n\n\n# 특정 값 개수\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nprint(lst.count(1))\nprint(lst.count(9))\n\n3\n0\n\n\n\n# 특정 값의 첫 번쩨 인덱스\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nprint(lst.index(1))\n#print(lst.index(9))\n\n0\n\n\n\n# 특정 값 찾기\nlst = [1, 2, 3, 4, 5]\nprint(3 in lst)\nprint(6 in lst)\n\nTrue\nFalse\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nlen()\n리스트 원소의 개수(리스트 길이) 반환\n\n\nsum()\n리스트 원소의 합계 반환\n\n\nmax()\n리스트 원소 중 최대값 반환\n\n\nmin()\n리스트 원소 중 최소값 반환\n\n\n\n\nlst = [1, 2, 3, 4, 5]\nprint(len(lst))\nprint(sum(lst))\nprint(max(lst))\nprint(min(lst))\n\n5\n15\n5\n1\n\n\n\n\n\n\n\n\n[식 for 변수 in 반복범위 if 조건식]\n\n\n기존 리스트를 사용하여 간결하게 새로운 리스트를 생성하는 기법\n리스트와 for 문을 한 줄에 사용할 수 있어 코드가 더 직관적으로 작성됨\n필터링, 중첩 반복문, 이차원 리스트 등 다양한 방식으로 활용됨\n\n\n\n리스트 컴프리헨션은 수학에서 집합을 정의할 때 특정 조건을 만족하는 원소들의 집합으로 표현하는 방법과 유사함\n\n수학적 집합 : S = {x | x는 0 이상 10 이하의 정수}\n리스트 컴프리헨션 : [x for x in range(10)]\n\n\n\n## 0~9 정수 저장\n# 일반적인 반복문 + 리스트\nresult1 = []\nfor i in range(10):\n    result1.append(i)\n\nprint(result1)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n## 0~9 정수 저장\n# 리스트 컴프리헨션\nresult2 = [i for i in range(10)]\nprint(result2)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n## 짝수만 저장 (필터링, if 문과 함께 사용)\n# 일반적인 반복문 + 리스트\nresult1 = []\nfor i in range(10):\n    if i % 2 == 0:\n        result1.append(i)\n\nprint(result1)\n\n[0, 2, 4, 6, 8]\n\n\n\n## 짝수만 저장 (필터링, if 문과 함께 사용)\n# 리스트 컴프리헨션\nresult2 = [i for i in range(10) if i % 2 == 0]\nprint(result2)\n\n[0, 2, 4, 6, 8]\n\n\n\n## 두 개의 문자열 조합하여 새로운 리스트 생성 (중첩 반복문)\n# 일반적인 반복문 + 리스트\nword1 = \"Hello\"\nword2 = \"World\"\nresult1 = []\n\nfor i in word1:\n    for j in word2:\n        result1.append(i+j)\n\nprint(result1)\n\n['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']\n\n\n\n## 두 개의 문자열 조합하여 새로운 리스트 생성 (중첩 반복문)\n# 리스트 컴프리헨션\nword1 = \"Hello\"\nword2 = \"World\"\n\nresult2 = [i+j for i in word1 for j in word2]\nprint(result2)\n\n['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']\n\n\n\n# 리스트 컴프리헨션 (필터링 + 중첩 반복문)\ncase1 = [\"A\", \"B\", \"C\"]\ncase2 = [\"D\", \"E\", \"A\"]\nresult = [i + j for i in case1 for j in case2 if not(i==j)]\nprint(result)\n\n['AD', 'AE', 'BD', 'BE', 'BA', 'CD', 'CE', 'CA']\n\n\n\n## 리스트의 각 원소를 대문자, 소문자, 길이로 변환하여 이차원 리스트 생성 (이차원 리스트)\n# 일반적인 반복문 + 리스트\nwords = \"The quick brown fox jumps over the lazy dog\".split()\nword_info1 = []\n\nfor w in words:\n    word_info1.append([w.upper(), w.lower(), len(w)])\n\nword_info1\n\n[['THE', 'the', 3],\n ['QUICK', 'quick', 5],\n ['BROWN', 'brown', 5],\n ['FOX', 'fox', 3],\n ['JUMPS', 'jumps', 5],\n ['OVER', 'over', 4],\n ['THE', 'the', 3],\n ['LAZY', 'lazy', 4],\n ['DOG', 'dog', 3]]\n\n\n\n## 리스트의 각 원소를 대문자, 소문자, 길이로 변환하여 이차원 리스트 생성 (이차원 리스트)\n# 리스트 컴프리헨션\nwords = \"The quick brown fox jumps over the lazy dog\".split()\nword_info2 = [[w.upper(), w.lower(), len(w)] for w in words]\nword_info2\n\n[['THE', 'the', 3],\n ['QUICK', 'quick', 5],\n ['BROWN', 'brown', 5],\n ['FOX', 'fox', 3],\n ['JUMPS', 'jumps', 5],\n ['OVER', 'over', 4],\n ['THE', 'the', 3],\n ['LAZY', 'lazy', 4],\n ['DOG', 'dog', 3]]\n\n\n\n# [주의] 반복문에서 대괄호의 위치에 따라 리스트의 구조가 달라짐\ncase1 = [\"A\", \"B\", \"C\"]\ncase2 = [\"1\", \"2\", \"3\"]\n\n# 일차원 리스트, 앞의 for 문이 먼저 실행됨\nresult1 = [i + j for i in case1 for j in case2]\nprint(result1)\n\n# 이차원 리스트, 뒤의 for 문이 바깥쪽에서 먼저 실행됨\nresult2 = [[i + j for i in case1] for j in case2]\nprint(result2)\n\n['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']\n[['A1', 'B1', 'C1'], ['A2', 'B2', 'C2'], ['A3', 'B3', 'C3']]\n\n\n\n(과제) 리스트 컴프리헨션 실습\n\n문제 1. 1부터 10까지의 제곱수를 리스트로 만들기 - [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n문제 2. 문자열 words = [“apple”, “banana”, “cherry”, “durian”] 에서 첫 글자만 리스트로 만들기 - [‘a’, ‘b’, ‘c’, ‘d’]\n문제 3. 두 리스트 list1 = [1,2,3], list2 = [4,5,6] 의 각 원소를 곱하여 리스트로 만들기 - [4, 10, 18]\n문제 4. 1~20까지의 수 중에서 3의 배수만 리스트로 만들기 - [3, 6, 9, 12, 15, 18]\n문제 5. 문자열 words = [“alligator”, “bear”, “cat”, “dog”, “elephant”, “fox”] 에서 길이가 5 이상인 단어만 리스트로 만들기 - [“alligator”, “elephant”]"
  },
  {
    "objectID": "3_2_list.html#리스트",
    "href": "3_2_list.html#리스트",
    "title": "3. 자료구조",
    "section": "",
    "text": "리스트(list)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 존재하는 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n정수형, 부동소수점형, 문자열형, bool형, 리스트, 튜플, 딕셔너리 등 다양한 자료형을 저장할 수 있는 컨테이너형 객체\n\n\n\n\n리스트 생성\n\n리터럴 방식(list literal)\n\n[] 사용하여 리스트를 직접 정의하는 방법\n[] 안에 원소(element)를 ,로 구분하여 나열함\n\n생성자 방식(list constructor)\n\nlist() 함수를 사용하여 리스트를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)을 인수로 받아 리스트를 생성할 때 유용함\n\n\n\n\n# 리스트 생성1\nlst = [1, 2, 3, 4, 5]\nprint(lst)\n\n[1, 2, 3, 4, 5]\n\n\n\n# 리스트 생성2\nlst = list([1, 2, 3, 4, 5])\nprint(lst)\n\n[1, 2, 3, 4, 5]\n\n\n\n# 리스트 생성3 : 리스트는 다양한 자료형을 저장할 수 있음\nlst = [1, 3.14, \"Hello\", True, [11, 12, 13]]\nprint(lst)\n\n[1, 3.14, 'Hello', True, [11, 12, 13]]\n\n\n\n# 리스트 생성4 : iterable 객체 사용\nlst = list(\"Hello\")\nprint(lst)\n\n['H', 'e', 'l', 'l', 'o']\n\n\n\n# 리스트 생성5 : iterable 객체 사용\nlst = list(range(10))\nprint(lst)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\n\n\n\n문자열 연산과 동일함\n리스트 연결 연산자 + : 두 리스트를 연결해서 새로운 리스트 생성\n리스트 반복 연산자 * : 리스트를 숫자만큼 반복하여 새로운 리스트 생성 - (예) 리스트*숫자\n리스트 전개 연산자 * : 리스트의 개별 원소를 분리하여 다른 리스트로 전개 - (예) [*리스트]\n\n\n# 리스트 연결\nlst1 = [1, 2, 3]\nlst2 = [11, 12, 13]\nprint(lst1 + lst2)\n\n[1, 2, 3, 11, 12, 13]\n\n\n\n# 리스트 반복\nprint(lst1 * 3)\n\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n\n\n# 리스트 전개\nlst = [1, 2, 3]\nprint([lst, lst])\nprint([*lst, *lst])\n\n[[1, 2, 3], [1, 2, 3]]\n[1, 2, 3, 1, 2, 3]\n\n\n\n\n\n\n\n\n\n패킹(packing) : 여러 개의 데이터를 한 변수에 묶어 할당하는 것\n언패킹(unpacking)\n\n한 변수에 묶인 데이터를 개별적인 변수들에 할당하는 것\n언패킹 시 기본적으로 변수 개수가 맞아야 하지만, *를 사용하면 가변 개수도 처리할 수 있음\n\n\n\n# 리스트 패킹\nlst = [1, 2, 3]\nprint(lst)\n\n[1, 2, 3]\n\n\n\n# 리스트 언패킹\nlst = [1, 2, 3]\nx, y, z = lst\nprint(x)\nprint(y)\nprint(z)\n\n1\n2\n3\n\n\n\n# 언패킹 시 변수 개수 불일치 오류\n#a, b = [1, 2, 3]\n#x, y, z = [4, 5]\n\n\n# 언패킹 시 *을 이용한 가변 개수 처리\n*x, y, z = [5, 6, 7, 8]\nprint(x)\nprint(y)\nprint(z)\n\n[5, 6]\n7\n8\n\n\n\n\n\n\n\n가변 인수를 사용하면 전달된 인수들은 튜플로 패킹됨\n*를 사용하여 리스트를 언패킹하여 함수에 전달함\n\n\n\n[참고] 함수의 인수\n\n\n\n\n\n\n\n\n종류\n내용\n\n\n\n\n키워드 인수\n함수의 인터페이스에서 저장한 변수 이름을 사용하여 함수의 인수를 지정하는 방법\n\n\n디폴트 인수\n별도의 인수 값이 입력되지 않을 때 인터페이스 선언에서 지정한 초기 값을 사용하는 방법\n\n\n가변 인수\n함수의 인터페이스에서 지정하는 변수 이외의 추가 변수를 함수에 입력할 수 있도록 지원하는 방법\n\n\n키워드 가변 인수\n매개변수의 이름을 따로 지정하지 않고 입력하는 방법\n\n\n\n\n# 키워드 인수(keyword arguments)\ndef greet(name, greeting):\n    print(f\"{greeting}, {name}!\")\n\ngreet(name=\"Alice\", greeting=\"Hi\")\n\nHi, Alice!\n\n\n\n# 디폴트 인수(default arguments)\ndef greet(name, greeting=\"Hello\"):\n    print(f\"{greeting}, {name}!\")\n\ngreet(\"Alice\")\ngreet(\"Bob\", \"Hi\")\n\nHello, Alice!\nHi, Bob!\n\n\n\n# 가변 인수(variable-length arguments) : *로 표현\n# 함수에 전단하는 인수의 개수가 불확실할 때 사용\n# 가변 인수는 반드시 일반적인 키워드 인수에 대한 선언이 모두 끝난 후 마지막에 선언되어야 함\ndef sum_numbers(*args):\n    return sum(args)\n\nprint(sum_numbers(1, 2, 3))\nprint(sum_numbers(5, 10))\n\n6\n15\n\n\n\n# 키워드 가변 인수(keyword variable-length arguments) : **로 표현\n# 입력 받은 값은 딕셔너리 지료형임\n# 키워드 가변 인수는 반드시 모든 매개변수의 마지막에 선언되어야 함\ndef print_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"Alice\", age=25)\n\nname: Alice\nage: 25\n\n\n\n# 가변 인수와 패킹, 언패킹\ndef print_args(*args):\n    print(\"Packed arguments:\", args)                        # 전달된 값이 튜플로 패킹됨\n\nprint_args(1, 2, 3, 4)\n\nlst = [11, 12, 13]\nprint_args(lst)                                             # 리스트 자체를 인수로 전달\nprint_args(*lst)                                            # 리스트를 언패킹하여 함수에 전달\n\nPacked arguments: (1, 2, 3, 4)\nPacked arguments: ([11, 12, 13],)\nPacked arguments: (11, 12, 13)\n\n\n\n# 키워드 인수와 언패킹\ndef sum_numbers(a, b, c, d):\n    return a + b + c + d\n\nlst = [1, 2, 3, 4]\n\nprint(sum_numbers(lst[0], lst[1], lst[2], lst[3]))          # 개별 원소를 인수로 전달\nprint(sum_numbers(*lst))                                    # 리스트를 언패킹하여 함수에 전달\n\n10\n10\n\n\n\n\n\n\n\n함수에서 여러 개의 값을 반환하면 자동으로 튜플로 패킹됨\n반환 값을 리스트로 묶어(패킹) 반환할 수도 있음\n함수가 반환한 리스트를 언패킹하여 개별 변수에 할당할 수 있음\n\n\n# 반환값과 패킹, 언패킹\ndef get_student_info():\n    return [\"Alice\", 20, \"Statistics\"]                      # 리스트로 패킹함\n\n# 패킹된 값 출력\ninfo = get_student_info()\nprint(info)\n\n# 언패킹하여 개별 변수에 할당\nname, age, major = get_student_info()\nprint(name)\nprint(age)\nprint(major)\n\n['Alice', 20, 'Statistics']\nAlice\n20\nStatistics\n\n\n\n\n\n\n\n\n문자열과 문법이 동일함\n인덱싱(indexing) : [index]를 사용하여 리스트의 특정 위치에 있는 원소에 접근함\n슬라이싱(slicing) : [(start index):(stop index)]를 사용하여 리스트의 일부 원소를 추출함\n\nlist[(start index):(end index)] = iterable를 사용하면 start:end로 지정한 부분이 iterable 객체의 모든 원소로 대체됨\n슬라이싱을 이용하여 기존 리스트의 일부를 삭제하거나, 새로운 원소를 추가 및 변경할 수 있음\n\n\n\n\n# 리스트 인덱싱1\nlst = [10, 20, 30, 40, 50]\nprint(lst[0])\n\n10\n\n\n\n# 리스트 인덱싱2\nlst = [10, 20, 30, 40, 50]\nprint(lst[-1])\n\n50\n\n\n\n# 리스트 접근 연산자 []를 이중으로 사용할 수 있음\nlst = [1, 3.14, \"Hello\", True, [11, 12, 13]]\nprint(lst[2])\nprint(lst[2][0])\n\nHello\nH\n\n\n\n# 리스트 슬라이싱1\nlst = [10, 20, 30, 40, 50]\nprint(lst[0:2])\n\n[10, 20]\n\n\n\n# 리스트 슬라이싱2\nlst = [10, 20, 30, 40, 50]\nprint(lst[:2])\nprint(lst[2:])\nprint(lst[::2])\n\n[10, 20]\n[30, 40, 50]\n[10, 30, 50]\n\n\n\n# 리스트는 가변형 객체이므로 인덱스를 이용한 수정이 가능함\nlst = [10, 20, 30, 40, 50]\nlst[2] = 3\nprint(lst)\n\n[10, 20, 3, 40, 50]\n\n\n\n# 슬라이싱을 이용한 원소 삭제\nlst = [10, 20, 30, 40, 50]\nlst[1:4] = []                              # 빈 리스트를 할당하면 해당 부분이 삭제됨\nprint(lst)\n\n[10, 50]\n\n\n\n# 슬라이싱을 이용한 원소 추가\nlst = [10, 20, 30, 40, 50]\nlst[1:1] = [6, 7]                          # 인덱스 1 위치에 [6, 7]의 원소를 개별적으로 추가\nprint(lst)\n\n[10, 6, 7, 20, 30, 40, 50]\n\n\n\n# 슬라이싱을 이용한 원소 수정\nlst = [10, 20, 30, 40, 50]\nlst[1:3] = [6, 7, 8]                       # 인덱스 1~2 부분을 [6, 7, 8]로 수정\nprint(lst)\n\n[10, 6, 7, 8, 40, 50]\n\n\n\n\n\n\n\n리스트 안에 또 다른 리스트가 포함된 구조\n2차원 리스트\n\n모든 내부 리스트가 동일한 길이를 가진 경우\n일반적으로 행(row)과 열(column)로 이루어짐\n행렬(matrix)처럼 활용하거나, 데이터를 일정한 구조로 관리할 때 유용함\n\n\n\n# 중첩 리스트\nnested_lst = [\n    [1, 2, 3],\n    [4, 5, 6, 7],\n    [8, 9]\n]\n\nprint(nested_lst)\n\n[[1, 2, 3], [4, 5, 6, 7], [8, 9]]\n\n\n\nfor items in nested_lst:\n    for item in items:\n        print(item)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2차원 리스트\nkor = [80, 82, 75, 95]\neng = [67, 95, 84, 83]\nmath = [74, 88, 82, 76]\nmidterm = [kor, eng, math]\nprint(midterm)\n\n[[80, 82, 75, 95], [67, 95, 84, 83], [74, 88, 82, 76]]\n\n\n\n# 2차원 리스트 인덱싱\nmidterm[0][3]\n\n95\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nappend()\n- 새로운 값을 기존 리스트의 맨 끝에 추가\n\n\nextend()\n- 새로운 리스트를 기존 리스트에 추가(덧셈 연산과 같은 효과)\n\n\ninsert()\n- 기존 리스트의 i번째 인덱스에 새로운 값을 추가 - i번째 인덱스를 기준으로 뒤쪽의 인덱스는 하나씩 밀림\n\n\n\n\n# 리스트에 한 개의 원소 추가1\nlst = [1, 2, 3]\nlst.append(4)                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 4]\n\n\n\n# 리스트에 한 개의 원소 추가2\n# 원본 값 변화 없이 리스트에 한 개의 원소를 추가하려면 전개 연산자 *를 사용하면 됨\nlst = [1, 2, 3]\nnew_lst = [*lst, 4]\nprint(lst)                                 # lst 원본 값이 변하지 않음\nprint(new_lst)\n\n[1, 2, 3]\n[1, 2, 3, 4]\n\n\n\n# append() 함수는 여러 개의 인수를 입력하거나, 연속으로 사용할 수 없음\nlst = [1, 2, 3]\n#lst.append(4,5)\n#lst.append(4).append(5)\n\n\n# 리스트에 여러 개의 원소 추가\nlst = [1, 2, 3]\nlst.extend([11, 12])                       # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst1 원본 값이 변함\n\n[1, 2, 3, 11, 12]\n\n\n\n# extend() 함수와 리스트 연결 연산자 +의 차이\nlst1 = [1, 2, 3]\nlst2 = [11, 12, 13]\nlst1 + lst2                                # 실행 결과가 출력됨\nprint(lst1)                                # lst1 원본 값이 변하지 않음\nprint(lst2)                                # lst2 원본 값이 변하지 않음\n\n[1, 2, 3]\n[11, 12, 13]\n\n\n\n# 특정 위치에 한 개의 원소 추가\nlst = [1, 2, 3]\nlst.insert(0, 100)                         # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[100, 1, 2, 3]\n\n\n\n# 특정 위치에 여러 개의 원소 추가 : 슬라이싱을 이용\nlst = [1, 2, 3]\nlst[1:1] = [11, 12]                        # 인덱스 1의 위치에 리스트 [11, 12]의 원소를 개별적으로 삽입\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 11, 12, 2, 3]\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\npop()\n- 특정 인덱스 값을 삭제하고 그 값을 반환 - 인덱스를 생략하면 마지막 원소를 삭제\n\n\ndel 키워드\n- 특정 인덱스 값을 삭제 - 리스트 객체 자체를 삭제 가능함\n\n\nremove()\n- 리스트에서 첫 번째로 일치하는 값을 삭제 - 값으로 삭제하므로 인덱스를 사용하지 않음\n\n\nclear()\n- 리스트의 모든 원소를 삭제\n\n\n\n\n# 특정 인덱스 값 삭제1\nlst = [1, 2, 3, 4, 5]\nresult = lst.pop(3)                        # 실행 결과로 삭제한 값을 반환\nprint(lst)                                 # lst 원본 값이 변함\nprint(result)\n\n[1, 2, 3, 5]\n4\n\n\n\n# 특정 인덱스 값 삭제2\nlst = [1, 2, 3, 4, 5]\nresult = lst.pop()                         # 인덱스를 생략하면 마지막 원소를 삭제 후 반환\nprint(lst)                                 # lst 원본 값이 변함\nprint(result)\n\n[1, 2, 3, 4]\n5\n\n\n\n# 특정 인덱스 값 삭제3\nlst = [1, 2, 3, 4, 5]\ndel lst[3]                                 # 실행 결과로 아무것도 반환하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 5]\n\n\n\n# 리스트 객체 삭제\nlst = [1, 2, 3, 4, 5]\ndel lst\n#print(lst)\n\n\n# 일치하는 값 삭제1\nlst = [1, 2, 3, 4, 5]\nlst.remove(4)                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 5]\n\n\n\n# 일치하는 값 삭제2\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nlst.remove(1)                              # 첫 번째로 일치하는 값만 삭제됨\nprint(lst)                                 # lst 원본 값이 변함\n\n[2, 3, 1, 4, 5, 1, 6, 7]\n\n\n\n# 리스트 모든 원소 삭제\nlst = [1, 2, 3, 4, 5]\nlst.clear()                                # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[]\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nreverse()\n- 리스트 원소를 역순으로 재배열\n\n\nsort()\n- 리스트 원소를 오름차순(default)으로 정렬 - 내림차순으로 정렬하려면 reverse=True로 설정\n\n\n\n\n# 리스트 역순 재배열\nlst = [52, 273, 103, 32, 275, 1, 7]\nlst.reverse()                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[7, 1, 275, 32, 103, 273, 52]\n\n\n\n# 리스트 정렬\nlst = [52, 273, 103, 32, 275, 1, 7]\nlst.sort()                                 # 실행 결과로 아무것도 출력하지 않음, 오름차순 정렬\nprint(lst)                                 # lst 원본 값이 변함\n\nlst.sort(reverse=True)                     # 내림차순 정렬\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 7, 32, 52, 103, 273, 275]\n[275, 273, 103, 52, 32, 7, 1]\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ncount()\n리스트 내부에 특정 값이 몇 번 나타나는지 개수를 반환\n\n\nindex()\n리스트 내부에 특정 값의 첫 번째 인덱스를 반환하며, 없으면 오류 발생\n\n\nin 연산자\n리스트 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\n\n\n# 특정 값 개수\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nprint(lst.count(1))\nprint(lst.count(9))\n\n3\n0\n\n\n\n# 특정 값의 첫 번쩨 인덱스\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nprint(lst.index(1))\n#print(lst.index(9))\n\n0\n\n\n\n# 특정 값 찾기\nlst = [1, 2, 3, 4, 5]\nprint(3 in lst)\nprint(6 in lst)\n\nTrue\nFalse\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nlen()\n리스트 원소의 개수(리스트 길이) 반환\n\n\nsum()\n리스트 원소의 합계 반환\n\n\nmax()\n리스트 원소 중 최대값 반환\n\n\nmin()\n리스트 원소 중 최소값 반환\n\n\n\n\nlst = [1, 2, 3, 4, 5]\nprint(len(lst))\nprint(sum(lst))\nprint(max(lst))\nprint(min(lst))\n\n5\n15\n5\n1\n\n\n\n\n\n\n\n\n[식 for 변수 in 반복범위 if 조건식]\n\n\n기존 리스트를 사용하여 간결하게 새로운 리스트를 생성하는 기법\n리스트와 for 문을 한 줄에 사용할 수 있어 코드가 더 직관적으로 작성됨\n필터링, 중첩 반복문, 이차원 리스트 등 다양한 방식으로 활용됨\n\n\n\n리스트 컴프리헨션은 수학에서 집합을 정의할 때 특정 조건을 만족하는 원소들의 집합으로 표현하는 방법과 유사함\n\n수학적 집합 : S = {x | x는 0 이상 10 이하의 정수}\n리스트 컴프리헨션 : [x for x in range(10)]\n\n\n\n## 0~9 정수 저장\n# 일반적인 반복문 + 리스트\nresult1 = []\nfor i in range(10):\n    result1.append(i)\n\nprint(result1)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n## 0~9 정수 저장\n# 리스트 컴프리헨션\nresult2 = [i for i in range(10)]\nprint(result2)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n## 짝수만 저장 (필터링, if 문과 함께 사용)\n# 일반적인 반복문 + 리스트\nresult1 = []\nfor i in range(10):\n    if i % 2 == 0:\n        result1.append(i)\n\nprint(result1)\n\n[0, 2, 4, 6, 8]\n\n\n\n## 짝수만 저장 (필터링, if 문과 함께 사용)\n# 리스트 컴프리헨션\nresult2 = [i for i in range(10) if i % 2 == 0]\nprint(result2)\n\n[0, 2, 4, 6, 8]\n\n\n\n## 두 개의 문자열 조합하여 새로운 리스트 생성 (중첩 반복문)\n# 일반적인 반복문 + 리스트\nword1 = \"Hello\"\nword2 = \"World\"\nresult1 = []\n\nfor i in word1:\n    for j in word2:\n        result1.append(i+j)\n\nprint(result1)\n\n['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']\n\n\n\n## 두 개의 문자열 조합하여 새로운 리스트 생성 (중첩 반복문)\n# 리스트 컴프리헨션\nword1 = \"Hello\"\nword2 = \"World\"\n\nresult2 = [i+j for i in word1 for j in word2]\nprint(result2)\n\n['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']\n\n\n\n# 리스트 컴프리헨션 (필터링 + 중첩 반복문)\ncase1 = [\"A\", \"B\", \"C\"]\ncase2 = [\"D\", \"E\", \"A\"]\nresult = [i + j for i in case1 for j in case2 if not(i==j)]\nprint(result)\n\n['AD', 'AE', 'BD', 'BE', 'BA', 'CD', 'CE', 'CA']\n\n\n\n## 리스트의 각 원소를 대문자, 소문자, 길이로 변환하여 이차원 리스트 생성 (이차원 리스트)\n# 일반적인 반복문 + 리스트\nwords = \"The quick brown fox jumps over the lazy dog\".split()\nword_info1 = []\n\nfor w in words:\n    word_info1.append([w.upper(), w.lower(), len(w)])\n\nword_info1\n\n[['THE', 'the', 3],\n ['QUICK', 'quick', 5],\n ['BROWN', 'brown', 5],\n ['FOX', 'fox', 3],\n ['JUMPS', 'jumps', 5],\n ['OVER', 'over', 4],\n ['THE', 'the', 3],\n ['LAZY', 'lazy', 4],\n ['DOG', 'dog', 3]]\n\n\n\n## 리스트의 각 원소를 대문자, 소문자, 길이로 변환하여 이차원 리스트 생성 (이차원 리스트)\n# 리스트 컴프리헨션\nwords = \"The quick brown fox jumps over the lazy dog\".split()\nword_info2 = [[w.upper(), w.lower(), len(w)] for w in words]\nword_info2\n\n[['THE', 'the', 3],\n ['QUICK', 'quick', 5],\n ['BROWN', 'brown', 5],\n ['FOX', 'fox', 3],\n ['JUMPS', 'jumps', 5],\n ['OVER', 'over', 4],\n ['THE', 'the', 3],\n ['LAZY', 'lazy', 4],\n ['DOG', 'dog', 3]]\n\n\n\n# [주의] 반복문에서 대괄호의 위치에 따라 리스트의 구조가 달라짐\ncase1 = [\"A\", \"B\", \"C\"]\ncase2 = [\"1\", \"2\", \"3\"]\n\n# 일차원 리스트, 앞의 for 문이 먼저 실행됨\nresult1 = [i + j for i in case1 for j in case2]\nprint(result1)\n\n# 이차원 리스트, 뒤의 for 문이 바깥쪽에서 먼저 실행됨\nresult2 = [[i + j for i in case1] for j in case2]\nprint(result2)\n\n['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']\n[['A1', 'B1', 'C1'], ['A2', 'B2', 'C2'], ['A3', 'B3', 'C3']]\n\n\n\n(과제) 리스트 컴프리헨션 실습\n\n문제 1. 1부터 10까지의 제곱수를 리스트로 만들기 - [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n문제 2. 문자열 words = [“apple”, “banana”, “cherry”, “durian”] 에서 첫 글자만 리스트로 만들기 - [‘a’, ‘b’, ‘c’, ‘d’]\n문제 3. 두 리스트 list1 = [1,2,3], list2 = [4,5,6] 의 각 원소를 곱하여 리스트로 만들기 - [4, 10, 18]\n문제 4. 1~20까지의 수 중에서 3의 배수만 리스트로 만들기 - [3, 6, 9, 12, 15, 18]\n문제 5. 문자열 words = [“alligator”, “bear”, “cat”, “dog”, “elephant”, “fox”] 에서 길이가 5 이상인 단어만 리스트로 만들기 - [“alligator”, “elephant”]"
  },
  {
    "objectID": "2_5_string.html",
    "href": "2_5_string.html",
    "title": "2. Python 기초",
    "section": "",
    "text": "문자열(string)\n\n문자(character)들이 나열된 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에는 수정할 수 없는 불변형(immutable) 객체\n큰 따옴표 또는 작은 따옴표로 감싸서 문자열을 생성함\n\n\n\n\n이스케이프 문자(escape character)\n\n\\ 기호와 함께 조합해서 사용하는 특수한 문자\n\\\" : 큰 따옴표\n\\' : 작은 따옴표\n\\n : 줄 바꿈(new line)\n\\t : 탭(tab)\n\n\n\n# 문자열 생성\nprint(\"안녕하세요\")\nprint('Hello')\n\n안녕하세요\nHello\n\n\n\n# 문자열 내부에 따옴표 넣기\nprint('\"안녕하세요\"라고 말했습니다.')\nprint(\"'날씨가 좋다'라고 생각했습니다.\")\n\n\"안녕하세요\"라고 말했습니다.\n'날씨가 좋다'라고 생각했습니다.\n\n\n\n# 이스케이프 문자 사용1\nprint(\"\\\"안녕하세요\\\"라고 말했습니다.\")\nprint('\\'날씨가 좋다\\'라고 생각했습니다.')\n\n\"안녕하세요\"라고 말했습니다.\n'날씨가 좋다'라고 생각했습니다.\n\n\n\n# 이스케이프 문자 사용2\nprint(\"Hello\\nWorld\")\n\nHello\nWorld\n\n\n\n# 이스케이프 문자 사용3\nprint(\"Hello\\tWorld\")\n\nHello   World\n\n\n\n# 여러 줄 문자열 만들기 : 세 번 반복한 따옴표로 감쌈\nprint(\"\"\"동해물과 백두산이 마르고 닳도록\n하느님이 보우하사 우리나라 만세\n무궁화 삼천리 화려강산\n대한사람 대한으로 길이 보전하세\"\"\")\n\n동해물과 백두산이 마르고 닳도록\n하느님이 보우하사 우리나라 만세\n무궁화 삼천리 화려강산\n대한사람 대한으로 길이 보전하세\n\n\n\n\n\n\n\n문자열 연결 연산자 + : 두 문자열을 연결해서 새로운 문자열 생성\n문자열 반복 연산자 * : 문자열을 숫자만큼 반복하여 새로운 문자열 생성 - (예) 문자열*숫자\n\n\n# 문자열 연결\nprint(\"Hello \" + \"Wolrld\")\n\nHello Wolrld\n\n\n\n# 문자열 연결 연산자는 문자열과 숫자를 연결할 수 없음\n#score = 99\n#print(\"성적은\" + score + \"입니다.\")\n\n\n# 문자열 연결 연산자로 문자열과 숫자를 연결하려면 숫자를 문자열로 변환해야 함\nscore = 99\nprint(\"성적은\" + str(score) + \"입니다.\")\n\n성적은99입니다.\n\n\n\n# 문자열 반복\nprint(\"Hello \" * 3)\n\nHello Hello Hello \n\n\n\n\n\n\n\n문자열의 각 문자에 접근할 때 문자 위치인 인덱스(index)를 사용함\n\nPython은 숫자를 0부터 세는 제로 인덱스(zero index) 유형을 사용함\n\n\n\n\n인덱싱(indexing)\n\n[index]를 사용하여 문자열의 특정 위치에 있는 항목(문자)에 접근하는 것\n리버스 인덱싱(reverse indexing) : 음수 인덱스를 사용하면 마지막 값부터 -1씩 감소하여 역순으로 접근할 수 있음\n\n\n\n\n슬라이싱(slicing)\n\n[(start index):(stop index)]를 이용하여 문자열의 일부 문자를 추출하는 것\n끝 인덱스는 포함하지 않으니 주의해야 함\n시작 인덱스를 생략하면 첫 번째 글자부터 추출하며, 끝 인덱스를 생략하면 가장 마지막 글자까지 추출함\n\n\n\n\n# 문자열 인덱싱1\ns = \"안녕하세요\"\nprint(s[0])\n\n안\n\n\n\n# 문자열 인덱싱2\ns = \"안녕하세요\"\nprint(s[-1])\n\n요\n\n\n\n# 문자열 슬라이싱1\ns = \"안녕하세요\"\nprint(s[0:2])\n\n안녕\n\n\n\n# 문자열 슬라이싱2\ns = \"안녕하세요\"\nprint(s[:2])\nprint(s[2:])\nprint(s[::2])\n\n안녕\n하세요\n안하요\n\n\n\n# 문자열은 불변형 객체이므로 인덱스를 이용한 수정은 불가능함\n#s = \"안녕하세요\"\n#s[2:5] = \"하십니까\"\n#print(s)\n\n\n# 문자열을 변경하려면 새로운 문자열을 만들어야 함\ns = \"안녕하세요\"\ns = s[:2] + \"하십니까\"\nprint(s)\n\n안녕하십니까\n\n\n\n# 문자열 거꾸로 출력하기\nmy_str = \"Hello Python!\"\nprint(my_str[::-1])\n\n!nohtyP olleH\n\n\n\n\n\n\n\n\n\nlen() 함수 : 문자열에 들어있는 문자의 개수(문자열의 길이) 반환\n\n\n# 문자열 길이\ns = \"안녕하세요\"\nprint(len(s))\n\n5\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nlower()\n문자열의 알파벳을 모두 소문자로 변환\n\n\nupper()\n문자열의 알파벳을 모두 대문자로 변환\n\n\n\n\n# 대소문자 변환 : 원본은 변하지 않음\ns = \"Hello Python!\"\nprint(s.lower())\nprint(s.upper())\nprint(s)\n\nhello python!\nHELLO PYTHON!\nHello Python!\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nfind()\n- 문자열에서 특정 문자열을 왼쪽에서부터 찾아서 인덱스를 반환 - 찾는 문자열이 없으면 -1을 반환\n\n\nrfind()\n- 문자열에서 특정 문자열을 오른쪽에서부터 찾아서 인덱스를 반환 - 찾는 문자열이 없으면 -1을 반환\n\n\ncount()\n- 문자열에서 특정 문자열의 개수를 반환\n\n\nin 연산자\n- 문자열 내부에 특정 문자열이 있다면 True, 없다면 False를 반환\n\n\n\n\n# 문자열 찾기\ns = \"Hello! Python is Python\"\nprint(s.find(\"Python\"))\nprint(s.rfind(\"Python\"))\nprint(s.count(\"Python\"))\nprint(\"Hello\" in s)\nprint(\"Hi\" in s)\n\n7\n17\n2\nTrue\nFalse\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nstrip()\n문자열 양 옆의 공백이나 특정 문자를 제거\n\n\nrstrip()\n문자열 오른쪽의 공백이나 특정 문자를 제거\n\n\nlstrip()\n문자열 왼쪽의 공백이나 특정 문자를 제거\n\n\nreplace()\n특정 문자열을 다른 문자열로 변경\n\n\n\n\n# 공백 제거\ns = \"  Hello Python!  \"\nprint(s)\nprint(s.strip())\n\n  Hello Python!  \nHello Python!\n\n\n\n# 특정 문자 제거\ns = \"##100kg, ##200kg\"\nprint(s.rstrip(\"kg\"))\nprint(s.lstrip(\"#\"))\n\n##100kg, ##200\n100kg, ##200kg\n\n\n\n# 문자열 변경\ns = \"Hello Python!\"\nprint(s.replace(\"Hello\", \"Hi\"))\n\nHi Python!\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nsplit()\n- 특정문자를 기준으로 문자열을 분리하고 리스트로 반환\n\n\njoin()\n- 여러 문자열을 모아서 하나의 문자열로 만듬 - 문자열을 구분할 구분자를 지정해야 함\n\n\n\n\n# 문자열 분리\ns = \"Hello Python!\"\ns.split(\" \")\n\n['Hello', 'Python!']\n\n\n\n# 문자열 결합\nlst = [\"one\", \"two\", \"three\"]\nprint(\", \".join(lst))\nprint(\" - \".join(lst))\n\none, two, three\none - two - three\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nisdigit()\n문자열이 숫자로만 구성되었는지 확인\n\n\nisalpha()\n문자열이 알파벳으로만 구성되었는지 확인\n\n\nisalnum()\n문자열이 알파벳과 숫자로만 구성되었는지 확인\n\n\nislower()\n문자열이 소문자로만 구성되었는지 확인\n\n\nisupper()\n문자열이 대문자로만 구성되었는지 확인\n\n\nisspace()\n문자열이 공백으로만 구성되었는지 확인\n\n\n\n\n# 문자열 구성 파악\nprint(\"1234\".isdigit())\nprint(\"Python\".isalpha())\nprint(\"pass123\".isalnum())\nprint(\"hello\".islower())\nprint(\"HELLO\".isupper())\nprint(\"     \".isspace())\n\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nstr()\n수를 문자열로 변환\n\n\nint()\n정수 형식의 문자열이나 실수를 정수로 변환\n\n\nfloat()\n실수 형식의 문자열이나 정수를 실수로 변환\n\n\n\n\n# 형 변환1\na = 1234\n#print(a + \"kg\")\nprint(str(a) + \"kg\")\n\n1234kg\n\n\n\n# 형 변환2\nprint(int(\"1234\"))\nprint(float(\"3.14\"))\n\n1234\n3.14\n\n\n\n\n\n\n\n“{자료형}”.format(인수)\n\n\n\n{}를 포함한 문자열 뒤에 .을 찍고 format() 함수를 사용하여 문자열이 출력되는 형식을 지정할 수 있음\n\n앞쪽에 있는 문자열 안의 {} 기호가 format() 함수의 매개변수로 차례로 대치되면서 숫자가 문자열이 됨\n{} 개수와 format() 함수의 매개변수 개수는 반드시 같아야 함\n\nf-문자열이 format() 함수보다 간단하고 직관적이므로, 대부분 f-문자열을 사용함\n\n\n\nf-문자열보다 format() 함수를 사용하는 것이 더 좋은 경우\n\n문자열 내용이 너무 많을 때 - 어떤 데이터를 출력하는지 모아서 볼 수 있어 더 유용함\n데이터를 리스트에 담아서 사용할 때\n\n\n\n# format() 함수1\nprint(\"{}\".format(10))\nprint(\"{} {}\".format(10, 20))\nprint(\"{} {} {} {} {}\".format(10, 20, 30, 40, 50))\n\n10\n10 20\n10 20 30 40 50\n\n\n\n# format() 함수2\nname = \"홍길동\"\nage = 20\nprint(f\"이름은 {name}이고, 나이는 {age}입니다.\")\nprint(\"이름은 {}이고, 나이는 {}입니다.\".format(name, age))\n\n이름은 홍길동이고, 나이는 20입니다.\n이름은 홍길동이고, 나이는 20입니다.\n\n\n\n# format() 함수3\na = 4\nb = 3.14159265\nprint(\"20{:02d}\".format(a))                # a 값을 두자리로 출력하되 앞의 빈곳은 0으로 채움\nprint(\"{:.3f}\".format(b))                  # b 값을 소수점 이하 세자리로 반올림하여 출력\n\n2004\n3.142\n\n\n\n# 데이터를 리스트에 담아서 사용할 때는 format() 함수를 사용하는 것이 더 좋음\ndata = [\"별\", 2, \"M\", \"Yes\"]\n\n# f-문자열 사용\nprint(f\"이름: {data[0]}, 나이: {data[1]}, 성별: {data[2]}, 중성화 여부: {data[3]}\")\n\n# format() 함수 사용\n# 전개 연산자 *를 사용하여 리스트 내용을 전개함\nprint(\"이름: {}, 나이: {}, 성별: {}, 중성화 여부: {}\".format(*data))\n\n이름: 별, 나이: 2, 성별: M, 중성화 여부: Yes\n이름: 별, 나이: 2, 성별: M, 중성화 여부: Yes"
  },
  {
    "objectID": "2_5_string.html#문자열",
    "href": "2_5_string.html#문자열",
    "title": "2. Python 기초",
    "section": "",
    "text": "문자열(string)\n\n문자(character)들이 나열된 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에는 수정할 수 없는 불변형(immutable) 객체\n큰 따옴표 또는 작은 따옴표로 감싸서 문자열을 생성함\n\n\n\n\n이스케이프 문자(escape character)\n\n\\ 기호와 함께 조합해서 사용하는 특수한 문자\n\\\" : 큰 따옴표\n\\' : 작은 따옴표\n\\n : 줄 바꿈(new line)\n\\t : 탭(tab)\n\n\n\n# 문자열 생성\nprint(\"안녕하세요\")\nprint('Hello')\n\n안녕하세요\nHello\n\n\n\n# 문자열 내부에 따옴표 넣기\nprint('\"안녕하세요\"라고 말했습니다.')\nprint(\"'날씨가 좋다'라고 생각했습니다.\")\n\n\"안녕하세요\"라고 말했습니다.\n'날씨가 좋다'라고 생각했습니다.\n\n\n\n# 이스케이프 문자 사용1\nprint(\"\\\"안녕하세요\\\"라고 말했습니다.\")\nprint('\\'날씨가 좋다\\'라고 생각했습니다.')\n\n\"안녕하세요\"라고 말했습니다.\n'날씨가 좋다'라고 생각했습니다.\n\n\n\n# 이스케이프 문자 사용2\nprint(\"Hello\\nWorld\")\n\nHello\nWorld\n\n\n\n# 이스케이프 문자 사용3\nprint(\"Hello\\tWorld\")\n\nHello   World\n\n\n\n# 여러 줄 문자열 만들기 : 세 번 반복한 따옴표로 감쌈\nprint(\"\"\"동해물과 백두산이 마르고 닳도록\n하느님이 보우하사 우리나라 만세\n무궁화 삼천리 화려강산\n대한사람 대한으로 길이 보전하세\"\"\")\n\n동해물과 백두산이 마르고 닳도록\n하느님이 보우하사 우리나라 만세\n무궁화 삼천리 화려강산\n대한사람 대한으로 길이 보전하세\n\n\n\n\n\n\n\n문자열 연결 연산자 + : 두 문자열을 연결해서 새로운 문자열 생성\n문자열 반복 연산자 * : 문자열을 숫자만큼 반복하여 새로운 문자열 생성 - (예) 문자열*숫자\n\n\n# 문자열 연결\nprint(\"Hello \" + \"Wolrld\")\n\nHello Wolrld\n\n\n\n# 문자열 연결 연산자는 문자열과 숫자를 연결할 수 없음\n#score = 99\n#print(\"성적은\" + score + \"입니다.\")\n\n\n# 문자열 연결 연산자로 문자열과 숫자를 연결하려면 숫자를 문자열로 변환해야 함\nscore = 99\nprint(\"성적은\" + str(score) + \"입니다.\")\n\n성적은99입니다.\n\n\n\n# 문자열 반복\nprint(\"Hello \" * 3)\n\nHello Hello Hello \n\n\n\n\n\n\n\n문자열의 각 문자에 접근할 때 문자 위치인 인덱스(index)를 사용함\n\nPython은 숫자를 0부터 세는 제로 인덱스(zero index) 유형을 사용함\n\n\n\n\n인덱싱(indexing)\n\n[index]를 사용하여 문자열의 특정 위치에 있는 항목(문자)에 접근하는 것\n리버스 인덱싱(reverse indexing) : 음수 인덱스를 사용하면 마지막 값부터 -1씩 감소하여 역순으로 접근할 수 있음\n\n\n\n\n슬라이싱(slicing)\n\n[(start index):(stop index)]를 이용하여 문자열의 일부 문자를 추출하는 것\n끝 인덱스는 포함하지 않으니 주의해야 함\n시작 인덱스를 생략하면 첫 번째 글자부터 추출하며, 끝 인덱스를 생략하면 가장 마지막 글자까지 추출함\n\n\n\n\n# 문자열 인덱싱1\ns = \"안녕하세요\"\nprint(s[0])\n\n안\n\n\n\n# 문자열 인덱싱2\ns = \"안녕하세요\"\nprint(s[-1])\n\n요\n\n\n\n# 문자열 슬라이싱1\ns = \"안녕하세요\"\nprint(s[0:2])\n\n안녕\n\n\n\n# 문자열 슬라이싱2\ns = \"안녕하세요\"\nprint(s[:2])\nprint(s[2:])\nprint(s[::2])\n\n안녕\n하세요\n안하요\n\n\n\n# 문자열은 불변형 객체이므로 인덱스를 이용한 수정은 불가능함\n#s = \"안녕하세요\"\n#s[2:5] = \"하십니까\"\n#print(s)\n\n\n# 문자열을 변경하려면 새로운 문자열을 만들어야 함\ns = \"안녕하세요\"\ns = s[:2] + \"하십니까\"\nprint(s)\n\n안녕하십니까\n\n\n\n# 문자열 거꾸로 출력하기\nmy_str = \"Hello Python!\"\nprint(my_str[::-1])\n\n!nohtyP olleH\n\n\n\n\n\n\n\n\n\nlen() 함수 : 문자열에 들어있는 문자의 개수(문자열의 길이) 반환\n\n\n# 문자열 길이\ns = \"안녕하세요\"\nprint(len(s))\n\n5\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nlower()\n문자열의 알파벳을 모두 소문자로 변환\n\n\nupper()\n문자열의 알파벳을 모두 대문자로 변환\n\n\n\n\n# 대소문자 변환 : 원본은 변하지 않음\ns = \"Hello Python!\"\nprint(s.lower())\nprint(s.upper())\nprint(s)\n\nhello python!\nHELLO PYTHON!\nHello Python!\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nfind()\n- 문자열에서 특정 문자열을 왼쪽에서부터 찾아서 인덱스를 반환 - 찾는 문자열이 없으면 -1을 반환\n\n\nrfind()\n- 문자열에서 특정 문자열을 오른쪽에서부터 찾아서 인덱스를 반환 - 찾는 문자열이 없으면 -1을 반환\n\n\ncount()\n- 문자열에서 특정 문자열의 개수를 반환\n\n\nin 연산자\n- 문자열 내부에 특정 문자열이 있다면 True, 없다면 False를 반환\n\n\n\n\n# 문자열 찾기\ns = \"Hello! Python is Python\"\nprint(s.find(\"Python\"))\nprint(s.rfind(\"Python\"))\nprint(s.count(\"Python\"))\nprint(\"Hello\" in s)\nprint(\"Hi\" in s)\n\n7\n17\n2\nTrue\nFalse\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nstrip()\n문자열 양 옆의 공백이나 특정 문자를 제거\n\n\nrstrip()\n문자열 오른쪽의 공백이나 특정 문자를 제거\n\n\nlstrip()\n문자열 왼쪽의 공백이나 특정 문자를 제거\n\n\nreplace()\n특정 문자열을 다른 문자열로 변경\n\n\n\n\n# 공백 제거\ns = \"  Hello Python!  \"\nprint(s)\nprint(s.strip())\n\n  Hello Python!  \nHello Python!\n\n\n\n# 특정 문자 제거\ns = \"##100kg, ##200kg\"\nprint(s.rstrip(\"kg\"))\nprint(s.lstrip(\"#\"))\n\n##100kg, ##200\n100kg, ##200kg\n\n\n\n# 문자열 변경\ns = \"Hello Python!\"\nprint(s.replace(\"Hello\", \"Hi\"))\n\nHi Python!\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nsplit()\n- 특정문자를 기준으로 문자열을 분리하고 리스트로 반환\n\n\njoin()\n- 여러 문자열을 모아서 하나의 문자열로 만듬 - 문자열을 구분할 구분자를 지정해야 함\n\n\n\n\n# 문자열 분리\ns = \"Hello Python!\"\ns.split(\" \")\n\n['Hello', 'Python!']\n\n\n\n# 문자열 결합\nlst = [\"one\", \"two\", \"three\"]\nprint(\", \".join(lst))\nprint(\" - \".join(lst))\n\none, two, three\none - two - three\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nisdigit()\n문자열이 숫자로만 구성되었는지 확인\n\n\nisalpha()\n문자열이 알파벳으로만 구성되었는지 확인\n\n\nisalnum()\n문자열이 알파벳과 숫자로만 구성되었는지 확인\n\n\nislower()\n문자열이 소문자로만 구성되었는지 확인\n\n\nisupper()\n문자열이 대문자로만 구성되었는지 확인\n\n\nisspace()\n문자열이 공백으로만 구성되었는지 확인\n\n\n\n\n# 문자열 구성 파악\nprint(\"1234\".isdigit())\nprint(\"Python\".isalpha())\nprint(\"pass123\".isalnum())\nprint(\"hello\".islower())\nprint(\"HELLO\".isupper())\nprint(\"     \".isspace())\n\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nstr()\n수를 문자열로 변환\n\n\nint()\n정수 형식의 문자열이나 실수를 정수로 변환\n\n\nfloat()\n실수 형식의 문자열이나 정수를 실수로 변환\n\n\n\n\n# 형 변환1\na = 1234\n#print(a + \"kg\")\nprint(str(a) + \"kg\")\n\n1234kg\n\n\n\n# 형 변환2\nprint(int(\"1234\"))\nprint(float(\"3.14\"))\n\n1234\n3.14\n\n\n\n\n\n\n\n“{자료형}”.format(인수)\n\n\n\n{}를 포함한 문자열 뒤에 .을 찍고 format() 함수를 사용하여 문자열이 출력되는 형식을 지정할 수 있음\n\n앞쪽에 있는 문자열 안의 {} 기호가 format() 함수의 매개변수로 차례로 대치되면서 숫자가 문자열이 됨\n{} 개수와 format() 함수의 매개변수 개수는 반드시 같아야 함\n\nf-문자열이 format() 함수보다 간단하고 직관적이므로, 대부분 f-문자열을 사용함\n\n\n\nf-문자열보다 format() 함수를 사용하는 것이 더 좋은 경우\n\n문자열 내용이 너무 많을 때 - 어떤 데이터를 출력하는지 모아서 볼 수 있어 더 유용함\n데이터를 리스트에 담아서 사용할 때\n\n\n\n# format() 함수1\nprint(\"{}\".format(10))\nprint(\"{} {}\".format(10, 20))\nprint(\"{} {} {} {} {}\".format(10, 20, 30, 40, 50))\n\n10\n10 20\n10 20 30 40 50\n\n\n\n# format() 함수2\nname = \"홍길동\"\nage = 20\nprint(f\"이름은 {name}이고, 나이는 {age}입니다.\")\nprint(\"이름은 {}이고, 나이는 {}입니다.\".format(name, age))\n\n이름은 홍길동이고, 나이는 20입니다.\n이름은 홍길동이고, 나이는 20입니다.\n\n\n\n# format() 함수3\na = 4\nb = 3.14159265\nprint(\"20{:02d}\".format(a))                # a 값을 두자리로 출력하되 앞의 빈곳은 0으로 채움\nprint(\"{:.3f}\".format(b))                  # b 값을 소수점 이하 세자리로 반올림하여 출력\n\n2004\n3.142\n\n\n\n# 데이터를 리스트에 담아서 사용할 때는 format() 함수를 사용하는 것이 더 좋음\ndata = [\"별\", 2, \"M\", \"Yes\"]\n\n# f-문자열 사용\nprint(f\"이름: {data[0]}, 나이: {data[1]}, 성별: {data[2]}, 중성화 여부: {data[3]}\")\n\n# format() 함수 사용\n# 전개 연산자 *를 사용하여 리스트 내용을 전개함\nprint(\"이름: {}, 나이: {}, 성별: {}, 중성화 여부: {}\".format(*data))\n\n이름: 별, 나이: 2, 성별: M, 중성화 여부: Yes\n이름: 별, 나이: 2, 성별: M, 중성화 여부: Yes"
  },
  {
    "objectID": "2_3_loop.html",
    "href": "2_3_loop.html",
    "title": "2. Python 기초",
    "section": "",
    "text": "for 반복변수 in 반복범위:  　　문장\n\n\n반복범위를 지정하여(정해진 횟수만큼) 반복해서 문장을 실행함\n반복범위 오른쪽에는 :이 위치하고, 반복해서 실행할 문장은 반드시 들여쓰기해야 함\n반복범위에는 범위, 문자열, 리스트, 딕셔너리 등이 사용될 수 있음\n\n그 중 범위가 가장 많이 사용되며, range() 함수로 만들 수 있음\n\n\n\n\n\n\n\n\n\n\n\n형식\n설명\n예시\n결과\n\n\n\n\nrange(종료값)\n0으로 시작해서 1씩 증가하며 종료값 전까지의 정수를 생성\nrange(5)\n0,1,2,3,4\n\n\nrange(시작값, 종료값)\n시작값으로 시작해서 1씩 증가하며 종료값 전까지의 정수를 생성\nrang(2,7)\n2,3,4,5,6\n\n\nrange(시작값, 종료값, 증가값)\n시작값으로 시작해서 증가값만큼 증가시키면서 종료값 전까지의 정수를 생성\nrange(2,11,3)\n2,5,8\n\n\n\n\n# 문자열을 3번 반복해서 출력\nfor i in range(3):\n    print(\"Hello!\")\n\nHello!\nHello!\nHello!\n\n\n\n# 반복범위의 값을 출력1\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\n\n# 반복범위의 값을 출력2\nfor i in \"World\":\n    print(i)\n\nW\no\nr\nl\nd\n\n\n\n# 1~100 정수의 합 계산\nsum = 0\n\nfor i in range(1,101):\n    sum += i\n\nprint(sum)\n\n5050\n\n\n\n# 30의 약수 출력\nnum = 30\n\nfor i in range(1, num+1):\n    if num%i == 0:\n        print(i, end=' ')\n\n1 2 3 5 6 10 15 30 \n\n\n\n\n\n\n\nwhile 조건식:  　　문장\n\n\n조건이 참인 동안 문장을 반복해서 실행하고, 조건이 거짓이면 반복문을 종료함\n\n\n# 1~100 정수의 합 계산\nsum = 0\nnum = 1\n\nwhile num&lt;=100:\n    sum += num\n    num += 1\n\nprint(sum)\n\n5050\n\n\n\n# 구구단 9단 출력\nnum = 1\n\nwhile num&lt;=9:\n    print(f'9x{num}={9*num}')\n    num += 1\n\n9x1=9\n9x2=18\n9x3=27\n9x4=36\n9x5=45\n9x6=54\n9x7=63\n9x8=72\n9x9=81"
  },
  {
    "objectID": "2_3_loop.html#반복문",
    "href": "2_3_loop.html#반복문",
    "title": "2. Python 기초",
    "section": "",
    "text": "for 반복변수 in 반복범위:  　　문장\n\n\n반복범위를 지정하여(정해진 횟수만큼) 반복해서 문장을 실행함\n반복범위 오른쪽에는 :이 위치하고, 반복해서 실행할 문장은 반드시 들여쓰기해야 함\n반복범위에는 범위, 문자열, 리스트, 딕셔너리 등이 사용될 수 있음\n\n그 중 범위가 가장 많이 사용되며, range() 함수로 만들 수 있음\n\n\n\n\n\n\n\n\n\n\n\n형식\n설명\n예시\n결과\n\n\n\n\nrange(종료값)\n0으로 시작해서 1씩 증가하며 종료값 전까지의 정수를 생성\nrange(5)\n0,1,2,3,4\n\n\nrange(시작값, 종료값)\n시작값으로 시작해서 1씩 증가하며 종료값 전까지의 정수를 생성\nrang(2,7)\n2,3,4,5,6\n\n\nrange(시작값, 종료값, 증가값)\n시작값으로 시작해서 증가값만큼 증가시키면서 종료값 전까지의 정수를 생성\nrange(2,11,3)\n2,5,8\n\n\n\n\n# 문자열을 3번 반복해서 출력\nfor i in range(3):\n    print(\"Hello!\")\n\nHello!\nHello!\nHello!\n\n\n\n# 반복범위의 값을 출력1\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\n\n# 반복범위의 값을 출력2\nfor i in \"World\":\n    print(i)\n\nW\no\nr\nl\nd\n\n\n\n# 1~100 정수의 합 계산\nsum = 0\n\nfor i in range(1,101):\n    sum += i\n\nprint(sum)\n\n5050\n\n\n\n# 30의 약수 출력\nnum = 30\n\nfor i in range(1, num+1):\n    if num%i == 0:\n        print(i, end=' ')\n\n1 2 3 5 6 10 15 30 \n\n\n\n\n\n\n\nwhile 조건식:  　　문장\n\n\n조건이 참인 동안 문장을 반복해서 실행하고, 조건이 거짓이면 반복문을 종료함\n\n\n# 1~100 정수의 합 계산\nsum = 0\nnum = 1\n\nwhile num&lt;=100:\n    sum += num\n    num += 1\n\nprint(sum)\n\n5050\n\n\n\n# 구구단 9단 출력\nnum = 1\n\nwhile num&lt;=9:\n    print(f'9x{num}={9*num}')\n    num += 1\n\n9x1=9\n9x2=18\n9x3=27\n9x4=36\n9x5=45\n9x6=54\n9x7=63\n9x8=72\n9x9=81"
  },
  {
    "objectID": "2_1_basic.html",
    "href": "2_1_basic.html",
    "title": "2. Python 기초",
    "section": "",
    "text": "변수\n\n프로그램이 실행되는 동안 값을 저장하는 공간\n하나의 프로그램에서 여러 개의 변수를 만들어 사용할 수 있으며, 각 변수를 구분하기 위해 변수마다 이름을 붙여 관리함\n변수에는 언제든지 새로운 값을 저장할 수 있음\n(정의) 변수 이름 = 값\n\n\n\n\n대입 연산자 =\n\n변수에 값을 저장할 때 사용하는 연산자로, 할당 연산자라고도 함\n= 기호 오른쪽의 값을 = 기호 왼쪽의 변수에 저장한다는 의미\n\n\n\n# 변수에 값을 저장하고 출력\nage = 20\nprint(age)\n\n20\n\n\n\n# 변수에 저장된 값 변경\nage = 21\nprint(age)\n\n21\n\n\n\n# 여러 변수에 값 대입\na = b = c = 7\nprint(a)\nprint(b)\nprint(c)\n\n7\n7\n7\n\n\n\n# 코드 한 줄에서 여러 개의 변수에 각각 다른 값을 한번에 대입할 수 있음\na, b, c = 7, 11, 19\nprint(a)\nprint(b)\nprint(c)\n\n7\n11\n19\n\n\n\n# 두 변수의 값 교환\na = 7\nb = 11\ntemp = a\na = b\nb = temp\nprint(a, b)\n\n11 7\n\n\n\n# Python에서는 패킹과 언패킹을 활용하여 임시변수 없이 두 변수의 값을 쉽게 교환할 수 있음\na = 7\nb = 11\na, b = b, a\nprint(a, b)\n\n11 7\n\n\n\n변수 이름 규칙\n\n변수가 어떤 용도로 쓰이는지 잘 설명하는 이름으로 만드는 것이 좋음\n첫 번째 글자는 문자 또는 _이어야 하고, 나머지 글자는 문자, 숫자, _이어야 함\n영문 대문자와 소문자를 구분함\n키워드(예약어; keyword)는 변수 이름으로 사용할 수 없음\n\n키워드 : 프로그래밍 언어에서 사용하기 위해 쓰임새를 미리 정해 놓은 단어\n\n\n\n\nimport keyword\nprint(keyword.kwlist)\n\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n\n\n\n\n\n\n\n기본 자료형\n\n단순한 값을 저장하는 자료형\n(예) 정수(1,2,3,…), 부동소수점수(1.23, 3.14, …), 복소수(2+3j), 문자열(“Hello”), bool(True, False)\n\n구조적 자료형\n\n여러 개의 값을 담을 수 있는 자료형\n(예) 리스트(list), 튜플(tuple), 세트(set), 딕셔너리(dictionary)\n\ntype() 함수를 이용하여 자료형을 확인할 수 있음\n\n\n# 정수형\na = 20                      # 10진수\nb = 0o34                    # 8진수\nc = 0xA1                    # 16진수\nd = 0b1110                  # 2진수\nprint(a, b, c, d)\nprint(type(a))\n\n20 28 161 14\n&lt;class 'int'&gt;\n\n\n\n# 부동소수점수형\na = 3.14\nb = 1.23e5                  # 지수 표현 방식\nprint(a, b)\nprint(type(a))\n\n3.14 123000.0\n&lt;class 'float'&gt;\n\n\n\n# 문자열형\na = 'Hello'\nb = \"Python\"\nprint(a, b)\nprint(type(a))\n\nHello Python\n&lt;class 'str'&gt;\n\n\n\n# bool형\na = 10&gt;20\nprint(a)\nprint(type(a))\n\nFalse\n&lt;class 'bool'&gt;\n\n\n\n\n\n\n\n입력\n\n사용자로부터 데이터를 입력받기 위해 input() 함수를 이용함\ninput() 함수는 안내문을 출력한 후 사용자의 입력을 기다리며, 입력한 데이터를 문자열 형식으로 반환함\n변수 = input(안내문)\n\n출력\n\n데이터를 출력하기 위해 print() 함수를 이용함\n여러 개의 값을 출력하려면 ,로 구분한 값을 나열하면 됨\n\n\n\n# 문자열 입력\n#name = input(\"이름: \")\n#age = input(\"나이: \")\n#print(name, \"나이:\", age)\n\n\n# 정수 형식의 문자열 입력\n# input 함수를 통해서 입력받은 데이터는 문자열형임\n# 따라서 int() 함수를 이용하여 정수 형식의 문자열을 정수로 변환해야 함\n#a = int(input(\"정수: \"))\n#b = int(input(\"정수: \"))\n#print(a-b)\n\n\n# 부동소수점 형식의 문자열 입력\n# float() 함수를 이용하여 부동소수점수 형식의 문자열을 부동소수점수로 변환함\n#minute = float(input(\"분 단위 시간: \"))\n#second = minute * 60\n#print(second, \"초\")\n\n\n# 문자열 출력\nprint(\"반갑습니다.\")\nscore = 99\nprint(\"성적은\", score, \"입니다.\")\n\n반갑습니다.\n성적은 99 입니다.\n\n\n\n# print() 함수가 여러 개일 때는 다음 줄로 넘어가서 값을 출력함\na = 25\nb = 42\nprint(a)\nprint(b)\n\n25\n42\n\n\n\n# print() 함수가 여러 개일 때 다음 줄로 넘어가는 대신 공백이 출력되기를 원하면 end 매개변수를 공백으로 설정함\na = 25\nb = 42\nprint(a, end=' ')\nprint(b)\n\n25 42\n\n\n\nf-문자열(f-string)\n\n문자열 앞에 소문자 f나 대문자 F를 붙이고, 문자열 안의 변수를 {}로 감싸서 표현하는 것\nf-문자열을 이용하면 변수 값이 출력되는 형식을 지정할 수 있음\n\n\n\n# f-문자열 사용\nname = \"홍길동\"\nage = 20\nprint(f\"이름은 {name}이고, 나이는 {age}입니다.\")\n\n이름은 홍길동이고, 나이는 20입니다.\n\n\n\n# f-문자열 출력 형식 지정\n# 변수 이름 옆에 :을 작성한 다음 형식을 지정함\nname = \"홍길동\"\nage = 20\nprint(f\"{name:5}, {age:3}\")\n\na = 4\nb = 3.14159265\nprint(f\"20{a:02d}\")                        # a 값을 두자리로 출력하되 앞의 빈곳은 0으로 채움\nprint(f\"{b:.3f}\")                          # b 값을 소수점 이하 세자리로 반올림하여 출력\n\n홍길동  ,  20\n2004\n3.142\n\n\n\n# 원의 넓이 구하기\n#pi = 3.14159265\n#radius = int(input(\"원의 반지름: \"))\n#area = pi * radius * radius\n#print(f\"원의 넓이: {area:.3f}\")\n\n\n\n\n\n\n연산(operation) : 덧셈, 뺄셈 등과 같이 일정한 규칙에 따라 계산하는 것\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n+\n더하기\nprint(6+4)\n10\n\n\n-\n빼기\nprint(6-4)\n2\n\n\n*\n곱하기\nprint(6*4)\n24\n\n\n/\n나누기\nprint(6/4)\n1.5\n\n\n//\n나눈 정수 몫\nprint(6//4)\n1\n\n\n%\n나눈 나머지\nprint(6%4)\n2\n\n\n**\n거듭제곱\nprint(6**4)\n1296\n\n\n\n\n\n\n\n\n크기를 비교할 때 사용하는 연산자\n연산 결과는 참(True) 또는 거짓(False)으로 나타남\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n==\n같다\nprint(10==20)\nFalse\n\n\n!=\n같지 않다\nprint(10!=20)\nTrue\n\n\n&gt;\n크다\nprint(10&gt;20)\nFalse\n\n\n&lt;\n작다\nprint(10&lt;20)\nTrue\n\n\n&gt;=\n크거나 같다\nprint(10&gt;=20)\nFalse\n\n\n&lt;=\n작거나 같다\nprint(10&lt;=20)\nTrue\n\n\n\n\n\n\n\n\n참과 거짓의 논리 동작을 다루는 연산\n여러 조건을 조합할 때 주로 사용함\n\n\n\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\nand\n왼쪽 식과 오른쪽 식 모두 참인 경우에만 True\na=25 print(a&gt;8 and a&lt;60)\nTrue\n\n\nor\n왼쪽 식과 오른쪽 식 중 하나라도 참인 경우에만 True\na=70 print(a&lt;8 or a&gt;=60)\nTrue\n\n\nnot\n오른쪽 식이 참이면 False, 거짓이면 True\na=20 print(not a==20)\nFalse\n\n\n\n\n\n\n\n\n연산한 값을 다시 대입하는 연산자\n\n\n\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n+=\n왼쪽 값에 오른쪽 값을 더한 결과를 다시 왼쪽에 대입\na, b = 2, 3 a += b  print(a)\n5\n\n\n-=\n왼쪽 값에 오른쪽 값을 뺀 결과를 다시 왼쪽에 대입\na, b = 2, 3 a -= b  print(a)\n-1\n\n\n*=\n왼쪽 값에 오른쪽 값을 곱한 결과를 다시 왼쪽에 대입\na, b = 2, 3 a *= b  print(a)\n6\n\n\n/=\n왼쪽 값에 오른쪽 값을 나눈 결과를 다시 왼쪽에 대입\na, b = 3, 2 a /= b  print(a)\n1.5\n\n\n//=\n왼쪽 값에 오른쪽 값을 나눈 몫을 다시 왼쪽에 대입\na, b = 7, 3 a //= b  print(a)\n2\n\n\n%=\n왼쪽 값에 오른쪽 값을 나눈 나머지를 다시 왼쪽에 대입\na, b = 7, 3 a %= b  print(a)\n1\n\n\n\n\n\n\n\n\n프로그래밍 언어는 연산자에 우선순위를 부여하여 우선순위가 높은 연산자를 먼저 계산함\n우선순위에 관계없이 연산의 순서를 정하려면 괄호 ()를 사용함\n\n\n\n\n우선순위\n연산자\n설명\n\n\n\n\n1\n**\n거듭제곱 연산자\n\n\n2\n+, -\n양수, 음수를 나타내는 단항 연산자\n\n\n3\n*, /, //, %\n곱셈, 나눗셈, 나눈 몫, 나머지\n\n\n4\n+, -\n덧셈, 뺄셈\n\n\n5\n&lt;, &lt;=, &gt;, &gt;=\n비교 연산자\n\n\n6\n==, !=\n동등 연산자\n\n\n7\n=, +=, -=, /=, //=, %=, **=\n대입 연산자\n\n\n8\nnot\n논리 연산자\n\n\n9\nand\n논리 연산자\n\n\n10\nor\n논리 연산자\n\n\n\n\n# 정수 3개의 평균 계산(틀림)\navg = 70 + 80 + 90 / 3\nprint(avg)\n\n180.0\n\n\n\n# 정수 3개의 평균 계산\navg = (70 + 80 + 90) / 3\nprint(avg)\n\n80.0\n\n\n\n# 길이 단위 변환\n#_cm = int(input(\"센티미터 단위 길이: \"))\n#m = _cm // 100\n#cm = _cm % 100\n#print(f'{m}미터 {cm}센티미터')"
  },
  {
    "objectID": "2_1_basic.html#기초-문법",
    "href": "2_1_basic.html#기초-문법",
    "title": "2. Python 기초",
    "section": "",
    "text": "변수\n\n프로그램이 실행되는 동안 값을 저장하는 공간\n하나의 프로그램에서 여러 개의 변수를 만들어 사용할 수 있으며, 각 변수를 구분하기 위해 변수마다 이름을 붙여 관리함\n변수에는 언제든지 새로운 값을 저장할 수 있음\n(정의) 변수 이름 = 값\n\n\n\n\n대입 연산자 =\n\n변수에 값을 저장할 때 사용하는 연산자로, 할당 연산자라고도 함\n= 기호 오른쪽의 값을 = 기호 왼쪽의 변수에 저장한다는 의미\n\n\n\n# 변수에 값을 저장하고 출력\nage = 20\nprint(age)\n\n20\n\n\n\n# 변수에 저장된 값 변경\nage = 21\nprint(age)\n\n21\n\n\n\n# 여러 변수에 값 대입\na = b = c = 7\nprint(a)\nprint(b)\nprint(c)\n\n7\n7\n7\n\n\n\n# 코드 한 줄에서 여러 개의 변수에 각각 다른 값을 한번에 대입할 수 있음\na, b, c = 7, 11, 19\nprint(a)\nprint(b)\nprint(c)\n\n7\n11\n19\n\n\n\n# 두 변수의 값 교환\na = 7\nb = 11\ntemp = a\na = b\nb = temp\nprint(a, b)\n\n11 7\n\n\n\n# Python에서는 패킹과 언패킹을 활용하여 임시변수 없이 두 변수의 값을 쉽게 교환할 수 있음\na = 7\nb = 11\na, b = b, a\nprint(a, b)\n\n11 7\n\n\n\n변수 이름 규칙\n\n변수가 어떤 용도로 쓰이는지 잘 설명하는 이름으로 만드는 것이 좋음\n첫 번째 글자는 문자 또는 _이어야 하고, 나머지 글자는 문자, 숫자, _이어야 함\n영문 대문자와 소문자를 구분함\n키워드(예약어; keyword)는 변수 이름으로 사용할 수 없음\n\n키워드 : 프로그래밍 언어에서 사용하기 위해 쓰임새를 미리 정해 놓은 단어\n\n\n\n\nimport keyword\nprint(keyword.kwlist)\n\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n\n\n\n\n\n\n\n기본 자료형\n\n단순한 값을 저장하는 자료형\n(예) 정수(1,2,3,…), 부동소수점수(1.23, 3.14, …), 복소수(2+3j), 문자열(“Hello”), bool(True, False)\n\n구조적 자료형\n\n여러 개의 값을 담을 수 있는 자료형\n(예) 리스트(list), 튜플(tuple), 세트(set), 딕셔너리(dictionary)\n\ntype() 함수를 이용하여 자료형을 확인할 수 있음\n\n\n# 정수형\na = 20                      # 10진수\nb = 0o34                    # 8진수\nc = 0xA1                    # 16진수\nd = 0b1110                  # 2진수\nprint(a, b, c, d)\nprint(type(a))\n\n20 28 161 14\n&lt;class 'int'&gt;\n\n\n\n# 부동소수점수형\na = 3.14\nb = 1.23e5                  # 지수 표현 방식\nprint(a, b)\nprint(type(a))\n\n3.14 123000.0\n&lt;class 'float'&gt;\n\n\n\n# 문자열형\na = 'Hello'\nb = \"Python\"\nprint(a, b)\nprint(type(a))\n\nHello Python\n&lt;class 'str'&gt;\n\n\n\n# bool형\na = 10&gt;20\nprint(a)\nprint(type(a))\n\nFalse\n&lt;class 'bool'&gt;\n\n\n\n\n\n\n\n입력\n\n사용자로부터 데이터를 입력받기 위해 input() 함수를 이용함\ninput() 함수는 안내문을 출력한 후 사용자의 입력을 기다리며, 입력한 데이터를 문자열 형식으로 반환함\n변수 = input(안내문)\n\n출력\n\n데이터를 출력하기 위해 print() 함수를 이용함\n여러 개의 값을 출력하려면 ,로 구분한 값을 나열하면 됨\n\n\n\n# 문자열 입력\n#name = input(\"이름: \")\n#age = input(\"나이: \")\n#print(name, \"나이:\", age)\n\n\n# 정수 형식의 문자열 입력\n# input 함수를 통해서 입력받은 데이터는 문자열형임\n# 따라서 int() 함수를 이용하여 정수 형식의 문자열을 정수로 변환해야 함\n#a = int(input(\"정수: \"))\n#b = int(input(\"정수: \"))\n#print(a-b)\n\n\n# 부동소수점 형식의 문자열 입력\n# float() 함수를 이용하여 부동소수점수 형식의 문자열을 부동소수점수로 변환함\n#minute = float(input(\"분 단위 시간: \"))\n#second = minute * 60\n#print(second, \"초\")\n\n\n# 문자열 출력\nprint(\"반갑습니다.\")\nscore = 99\nprint(\"성적은\", score, \"입니다.\")\n\n반갑습니다.\n성적은 99 입니다.\n\n\n\n# print() 함수가 여러 개일 때는 다음 줄로 넘어가서 값을 출력함\na = 25\nb = 42\nprint(a)\nprint(b)\n\n25\n42\n\n\n\n# print() 함수가 여러 개일 때 다음 줄로 넘어가는 대신 공백이 출력되기를 원하면 end 매개변수를 공백으로 설정함\na = 25\nb = 42\nprint(a, end=' ')\nprint(b)\n\n25 42\n\n\n\nf-문자열(f-string)\n\n문자열 앞에 소문자 f나 대문자 F를 붙이고, 문자열 안의 변수를 {}로 감싸서 표현하는 것\nf-문자열을 이용하면 변수 값이 출력되는 형식을 지정할 수 있음\n\n\n\n# f-문자열 사용\nname = \"홍길동\"\nage = 20\nprint(f\"이름은 {name}이고, 나이는 {age}입니다.\")\n\n이름은 홍길동이고, 나이는 20입니다.\n\n\n\n# f-문자열 출력 형식 지정\n# 변수 이름 옆에 :을 작성한 다음 형식을 지정함\nname = \"홍길동\"\nage = 20\nprint(f\"{name:5}, {age:3}\")\n\na = 4\nb = 3.14159265\nprint(f\"20{a:02d}\")                        # a 값을 두자리로 출력하되 앞의 빈곳은 0으로 채움\nprint(f\"{b:.3f}\")                          # b 값을 소수점 이하 세자리로 반올림하여 출력\n\n홍길동  ,  20\n2004\n3.142\n\n\n\n# 원의 넓이 구하기\n#pi = 3.14159265\n#radius = int(input(\"원의 반지름: \"))\n#area = pi * radius * radius\n#print(f\"원의 넓이: {area:.3f}\")\n\n\n\n\n\n\n연산(operation) : 덧셈, 뺄셈 등과 같이 일정한 규칙에 따라 계산하는 것\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n+\n더하기\nprint(6+4)\n10\n\n\n-\n빼기\nprint(6-4)\n2\n\n\n*\n곱하기\nprint(6*4)\n24\n\n\n/\n나누기\nprint(6/4)\n1.5\n\n\n//\n나눈 정수 몫\nprint(6//4)\n1\n\n\n%\n나눈 나머지\nprint(6%4)\n2\n\n\n**\n거듭제곱\nprint(6**4)\n1296\n\n\n\n\n\n\n\n\n크기를 비교할 때 사용하는 연산자\n연산 결과는 참(True) 또는 거짓(False)으로 나타남\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n==\n같다\nprint(10==20)\nFalse\n\n\n!=\n같지 않다\nprint(10!=20)\nTrue\n\n\n&gt;\n크다\nprint(10&gt;20)\nFalse\n\n\n&lt;\n작다\nprint(10&lt;20)\nTrue\n\n\n&gt;=\n크거나 같다\nprint(10&gt;=20)\nFalse\n\n\n&lt;=\n작거나 같다\nprint(10&lt;=20)\nTrue\n\n\n\n\n\n\n\n\n참과 거짓의 논리 동작을 다루는 연산\n여러 조건을 조합할 때 주로 사용함\n\n\n\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\nand\n왼쪽 식과 오른쪽 식 모두 참인 경우에만 True\na=25 print(a&gt;8 and a&lt;60)\nTrue\n\n\nor\n왼쪽 식과 오른쪽 식 중 하나라도 참인 경우에만 True\na=70 print(a&lt;8 or a&gt;=60)\nTrue\n\n\nnot\n오른쪽 식이 참이면 False, 거짓이면 True\na=20 print(not a==20)\nFalse\n\n\n\n\n\n\n\n\n연산한 값을 다시 대입하는 연산자\n\n\n\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n+=\n왼쪽 값에 오른쪽 값을 더한 결과를 다시 왼쪽에 대입\na, b = 2, 3 a += b  print(a)\n5\n\n\n-=\n왼쪽 값에 오른쪽 값을 뺀 결과를 다시 왼쪽에 대입\na, b = 2, 3 a -= b  print(a)\n-1\n\n\n*=\n왼쪽 값에 오른쪽 값을 곱한 결과를 다시 왼쪽에 대입\na, b = 2, 3 a *= b  print(a)\n6\n\n\n/=\n왼쪽 값에 오른쪽 값을 나눈 결과를 다시 왼쪽에 대입\na, b = 3, 2 a /= b  print(a)\n1.5\n\n\n//=\n왼쪽 값에 오른쪽 값을 나눈 몫을 다시 왼쪽에 대입\na, b = 7, 3 a //= b  print(a)\n2\n\n\n%=\n왼쪽 값에 오른쪽 값을 나눈 나머지를 다시 왼쪽에 대입\na, b = 7, 3 a %= b  print(a)\n1\n\n\n\n\n\n\n\n\n프로그래밍 언어는 연산자에 우선순위를 부여하여 우선순위가 높은 연산자를 먼저 계산함\n우선순위에 관계없이 연산의 순서를 정하려면 괄호 ()를 사용함\n\n\n\n\n우선순위\n연산자\n설명\n\n\n\n\n1\n**\n거듭제곱 연산자\n\n\n2\n+, -\n양수, 음수를 나타내는 단항 연산자\n\n\n3\n*, /, //, %\n곱셈, 나눗셈, 나눈 몫, 나머지\n\n\n4\n+, -\n덧셈, 뺄셈\n\n\n5\n&lt;, &lt;=, &gt;, &gt;=\n비교 연산자\n\n\n6\n==, !=\n동등 연산자\n\n\n7\n=, +=, -=, /=, //=, %=, **=\n대입 연산자\n\n\n8\nnot\n논리 연산자\n\n\n9\nand\n논리 연산자\n\n\n10\nor\n논리 연산자\n\n\n\n\n# 정수 3개의 평균 계산(틀림)\navg = 70 + 80 + 90 / 3\nprint(avg)\n\n180.0\n\n\n\n# 정수 3개의 평균 계산\navg = (70 + 80 + 90) / 3\nprint(avg)\n\n80.0\n\n\n\n# 길이 단위 변환\n#_cm = int(input(\"센티미터 단위 길이: \"))\n#m = _cm // 100\n#cm = _cm % 100\n#print(f'{m}미터 {cm}센티미터')"
  },
  {
    "objectID": "1_python.html",
    "href": "1_python.html",
    "title": "1. Python 소개 및 설치",
    "section": "",
    "text": "컴퓨터 프로그램과 프로그래밍 언어\n\n컴퓨터 프로그램 (computer program) : 컴퓨터로 문제를 해결하기 위해 작성하는 명령어의 모음\n프로그래밍 언어(programming language)\n\n컴퓨터에 어떤 동작을 수행하도록 지시하는 언어\n프로그래밍 언어를 사용하여 프로그램을 논리적으로 작성하는 작업을 코딩(coding)이라 함\n\n\n\n\n\nPython\n\n1991년 귀도 반 로섬(Guido van Rossum)이 개발한 프로그래밍 언어\n빅데이터 분석과 인공지능 분야에서 가장 널리 사용되고 있음\n문법이 쉽고 간결하여 프로그래밍을 처음 접하는 사람이 배우기 적합함\n\n\n\n\nPython 특징\n\n플랫폼 독립적인 언어 : 컴퓨터 운영체제나 하드웨어의 종류에 관계없이 사용할 수 있음\n인터프리터 언어 : 소스코드 자체가 바로 실행되어 간편하게 사용할 수 있음(속도는 느림)\n동적 타이핑 언어\n\n프로그램의 실행 시점에서 각 프로그램 변수의 타입(type)을 결정하는 언어\n인터프리터 언어이므로 프로그램의 실행 시점에 변수들의 메모리 공간을 자유롭게 할당받을 수 있음\n\n객체 지향 언어\n\n프로그램이 해결해야 할 문제의 구성요소를 요소별로 정의한 다음, 각 요소의 기능(method)과 정보(attribute)를 프로그래밍한 다음 요소들을 결합하는 방식으로 프로그램을 작성함\n이때 각 요소를 객체(object)라고 하며, 한 번 만들어진 객체는 재사용(reusability)할 수 있음"
  },
  {
    "objectID": "1_python.html#python-소개",
    "href": "1_python.html#python-소개",
    "title": "1. Python 소개 및 설치",
    "section": "",
    "text": "컴퓨터 프로그램과 프로그래밍 언어\n\n컴퓨터 프로그램 (computer program) : 컴퓨터로 문제를 해결하기 위해 작성하는 명령어의 모음\n프로그래밍 언어(programming language)\n\n컴퓨터에 어떤 동작을 수행하도록 지시하는 언어\n프로그래밍 언어를 사용하여 프로그램을 논리적으로 작성하는 작업을 코딩(coding)이라 함\n\n\n\n\n\nPython\n\n1991년 귀도 반 로섬(Guido van Rossum)이 개발한 프로그래밍 언어\n빅데이터 분석과 인공지능 분야에서 가장 널리 사용되고 있음\n문법이 쉽고 간결하여 프로그래밍을 처음 접하는 사람이 배우기 적합함\n\n\n\n\nPython 특징\n\n플랫폼 독립적인 언어 : 컴퓨터 운영체제나 하드웨어의 종류에 관계없이 사용할 수 있음\n인터프리터 언어 : 소스코드 자체가 바로 실행되어 간편하게 사용할 수 있음(속도는 느림)\n동적 타이핑 언어\n\n프로그램의 실행 시점에서 각 프로그램 변수의 타입(type)을 결정하는 언어\n인터프리터 언어이므로 프로그램의 실행 시점에 변수들의 메모리 공간을 자유롭게 할당받을 수 있음\n\n객체 지향 언어\n\n프로그램이 해결해야 할 문제의 구성요소를 요소별로 정의한 다음, 각 요소의 기능(method)과 정보(attribute)를 프로그래밍한 다음 요소들을 결합하는 방식으로 프로그램을 작성함\n이때 각 요소를 객체(object)라고 하며, 한 번 만들어진 객체는 재사용(reusability)할 수 있음"
  },
  {
    "objectID": "1_python.html#python-설치",
    "href": "1_python.html#python-설치",
    "title": "1. Python 소개 및 설치",
    "section": "1.2. Python 설치",
    "text": "1.2. Python 설치\n\n1.2.1. Jupyter Notebook과 Jupyter Lab\n\nJupyter Notebook\n\n가장 많이 사용되는 Python IDE 중 하나로, 웹 브라우저에서 실행되는 대화형 개발 도구\n코드 작성과 실행을 한 화면에서 쉽게 수행할 수 있으며, 텍스트(markdown), 수식(LaTeX), 그래프(Matplotlib) 등을 함께 포함할 수 있음\n실행 결과가 셀 단위로 저장되어, 데이터 분석 과정을 논리적인 흐름으로 문서화하여 공유하기 용이함\n특히 데이터 과학, 머신러닝, 교육, 연구 분야에서 많이 활용됨\n\n\n\n\nJupyter Lab\n\nJupyter Notebook을 확장한 차세대 인터페이스로, 더욱 유연하고 강력한 기능을 제공하는 개발 환경\n탭(tab) 기반 인터페이스를 지원하여 여러 개의 노트북, 터미널, 텍스트 파일, 콘솔 등을 동시에 열고 작업할 수 있음\n코드 편집, 데이터 분석, 시각화 등 데이터 과학 및 머신러닝 작업에 최적화된 다양한 편의 기능이 포함됨\n파일 브라우저, 터미널, markdown 편집기, 확장 플러그인 지원 등으로 보다 통합적인 워크플로우 제공\nJupyter Notebook과 호환되며, 확장성을 고려하여 설계되어 다양한 플로그인 추가가 가능함\n\n\n\n\n가상 환경(virtual environment)\n\n독립적인 작업 공간을 제공하여, 하나의 컴퓨터에서 여러 프로젝트를 각각의 독립된 환경으로 격리하여 실행할 수 있음\n하나의 시스템에서 여러 버전의 Python, 라이브러리 등을 설치하고, 프로젝트마다 서로 다른 버전의 의존성을 관리할 수 있음\n충돌 방지 및 의존성 관리에 유용하며, 특정 프로젝트에 필요한 패키지나 라이브러리만 설치하여 다른 프로젝트에 영향을 주지 않음\n프로젝트 간의 의존성 충돌을 피하고, 재현 가능한 환경을 제공하여 코드의 안정성을 높이고 협업을 용이하게 함\n\n\n\n\n가상 환경을 만든 후, Jupyter Lab 설치 및 실행\n\nAnaconda3 설치\nAnaconda Prompt 실행\n가상 환경 생성 : conda create -n myenv python=3.9\n가상 환경 리스트 조회 : conda info --envs\n가상 환경 접속(활성화) : conda activate myenv\n가상 환경에서 Jupyter Lab 설치 : conda install -c conda-forge jupyterlab\nJupyter Lab 접속 : jupyter lab\n\n\n\n\n\n1.2.2. Google Colab\n\nGoogle Colab\n\n구글에서 제공하는 클라우드 기반의 Jupyter Notebook 개발 환경으로, 웹 브라우저에서 Python 코드 작성 및 실행이 가능함\n별도의 설치 없이 바로 사용할 수 있으며, 구글 드라이브와 연동하여 작성한 파일을 클라우드에 저장하고 쉽게 관리 가능\n다양한 라이브러리(Numpy, Pandas, Matplotlib 등)가 기본적으로 설치되어 있음\nGPU, TPU 지원을 통해 대규모 데이터 처리와 딥러닝 모델 학습에 유리함\n협업 기능을 제공하여, 여러 사람이 동시에 실시간으로 작업하고 프로그램을 공유할 수 있음"
  },
  {
    "objectID": "2_2_conditional.html",
    "href": "2_2_conditional.html",
    "title": "2. Python 기초",
    "section": "",
    "text": "프로그램 구조는 크게 순차 구조, 선택 구조, 반복 구조로 구분됨\n\n순차 구조 : 위에서부터 아래로 순차적으로 실행되는 구조\n선택 구조 : 조건에 따라 문장을 선택적으로 실행하는 구조로, 조건이 참(True)인지 거짓(False)인지에 따라 실행되는 문장이 달라짐\n반복 구조 : 임의의 문장을 반복해서 실행하는 구조\n\n\n\n\n\n\n\n\nif 조건식:  　　문장\n\n\n조건식이 참이면 문장을 실행하고 거짓이면 문장을 실행하지 않음\n조건식 오른쪽에 :이 위치하고, 참인 경우 실행될 문장은 반드시 들여쓰기(indentation)해야 함\n\n\n\n# 무작위로 1~100 사이의 두 정수를 생성한 후, 큰 수부터 작은 수 순으로 출력\nimport random\na = random.randint(1, 100)\nb = random.randint(1, 100)\n\nif a&lt;b:\n    a, b = b, a\n\nprint(a, b)\n\n65 56\n\n\n\n\n\n\n\nif 조건식:  　　문장1  else:  　　문장2\n\n\n조건식이 참이면 문장1을 실행하고, 거짓이면 문장2를 실행함\n조건식 오른쪽에 :이 위치하고, else 오른쪽에는 조건식 없이 :이 위치함\n문장1과 문장2는 반드시 들여쓰기해야 함\n\n\n\n# 무작위로 1~100 사이의 정수를 생성한 후, 짝수인지 홀수인지 판단\nimport random\na = random.randint(1, 100)\n\nif a % 2 == 0:\n    print(f'{a}는 짝수입니다')\nelse:\n    print(f'{a}는 홀수입니다')\n\n17는 홀수입니다\n\n\n\n\n\n\n\nif 조건식1:  　　문장1  elif 조건식2:  　　문장2  else:  　　문장3\n\n\n조건식1이 거짓인 경우에 또 다른 선택구조를 연결하는 구조\n조건식1이 참이면 문장1을 실행하고, 조건식1이 거짓이면서 조건식2가 참이면 문장2를 실행하고, 두 조건식 모두 거짓이면 문장3을 실행함\n조건식1, 조건식2 오른쪽에 :이 위치하고, 문장1, 문장2, 문장3은 반드시 들여쓰기해야 함\n\n\n\n# 놀이공원 기본 입장료는 5,000원임\n# 8세 미만은 기본 입장료 30% 할인, 65세 이상은 기본 입장료 20% 할인 적용함\n# 연령이 주어졌을 때, 놀이공원 입장료 산출\nfee = 5000\nage = 7\n\nif age &lt; 8:\n    print('입장료:', fee*0.7)\nelif age &lt; 65:\n    print('입장료:', fee)\nelse:\n    print('입장료:', fee*0.8)\n\n입장료: 3500.0"
  },
  {
    "objectID": "2_2_conditional.html#조건문",
    "href": "2_2_conditional.html#조건문",
    "title": "2. Python 기초",
    "section": "",
    "text": "프로그램 구조는 크게 순차 구조, 선택 구조, 반복 구조로 구분됨\n\n순차 구조 : 위에서부터 아래로 순차적으로 실행되는 구조\n선택 구조 : 조건에 따라 문장을 선택적으로 실행하는 구조로, 조건이 참(True)인지 거짓(False)인지에 따라 실행되는 문장이 달라짐\n반복 구조 : 임의의 문장을 반복해서 실행하는 구조\n\n\n\n\n\n\n\n\nif 조건식:  　　문장\n\n\n조건식이 참이면 문장을 실행하고 거짓이면 문장을 실행하지 않음\n조건식 오른쪽에 :이 위치하고, 참인 경우 실행될 문장은 반드시 들여쓰기(indentation)해야 함\n\n\n\n# 무작위로 1~100 사이의 두 정수를 생성한 후, 큰 수부터 작은 수 순으로 출력\nimport random\na = random.randint(1, 100)\nb = random.randint(1, 100)\n\nif a&lt;b:\n    a, b = b, a\n\nprint(a, b)\n\n65 56\n\n\n\n\n\n\n\nif 조건식:  　　문장1  else:  　　문장2\n\n\n조건식이 참이면 문장1을 실행하고, 거짓이면 문장2를 실행함\n조건식 오른쪽에 :이 위치하고, else 오른쪽에는 조건식 없이 :이 위치함\n문장1과 문장2는 반드시 들여쓰기해야 함\n\n\n\n# 무작위로 1~100 사이의 정수를 생성한 후, 짝수인지 홀수인지 판단\nimport random\na = random.randint(1, 100)\n\nif a % 2 == 0:\n    print(f'{a}는 짝수입니다')\nelse:\n    print(f'{a}는 홀수입니다')\n\n17는 홀수입니다\n\n\n\n\n\n\n\nif 조건식1:  　　문장1  elif 조건식2:  　　문장2  else:  　　문장3\n\n\n조건식1이 거짓인 경우에 또 다른 선택구조를 연결하는 구조\n조건식1이 참이면 문장1을 실행하고, 조건식1이 거짓이면서 조건식2가 참이면 문장2를 실행하고, 두 조건식 모두 거짓이면 문장3을 실행함\n조건식1, 조건식2 오른쪽에 :이 위치하고, 문장1, 문장2, 문장3은 반드시 들여쓰기해야 함\n\n\n\n# 놀이공원 기본 입장료는 5,000원임\n# 8세 미만은 기본 입장료 30% 할인, 65세 이상은 기본 입장료 20% 할인 적용함\n# 연령이 주어졌을 때, 놀이공원 입장료 산출\nfee = 5000\nage = 7\n\nif age &lt; 8:\n    print('입장료:', fee*0.7)\nelif age &lt; 65:\n    print('입장료:', fee)\nelse:\n    print('입장료:', fee*0.8)\n\n입장료: 3500.0"
  },
  {
    "objectID": "2_4_function.html",
    "href": "2_4_function.html",
    "title": "2. Python 기초",
    "section": "",
    "text": "함수(function)\n\n특정한 기능을 수행하도록 미리 만들어 놓고, 필요할 때마다 호출하여 사용하는 일련의 코드\nPython에서 기본적으로 제공하는 내장 함수와 사용자가 직접 만들어서 사용할 수 있는 사용자 정의 함수가 있음\n\n\n\n\n함수 장점\n\n필요할 때마다 호출 가능 : 반복적으로 수행해야 하는 업무를 한 번만 작성해 놓고 필요할 때마다 호출하여 사용할 수 있음\n논리적인 단위로 분할 가능 : (예) 도형 계산 프로그램 - 덧셈 코드, 곱셈 코드, 나눗셈 코드 등으로 나눔\n코드의 캡슐화 가능 : 함수의 인터페이스만 잘 정의하면 다른 사람이 자신의 코드를 쉽게 가져다 사용할 수 있음\n\n\n\n# 절대값 반환 함수\nabs(-10)\n\n10\n\n\n\n\n\n\n\ndef 함수 이름(매개변수1, 매개변수2, …):  　　문장  　　return 반환값\n\n\n\n함수 이름 규칙\n\n변수 이름 규칙과 동일함\n일반적으로 소문자로 입력\n작업을 나타내기 위해 동사와 명사를 함께 사용하는 경우가 많음 - (예) find_number\n외부에 공개하는 함수일 경우 줄임말을 사용하지 않고 짧고 명료한 이름으로 정함\n\n\n\n\n매개변수(parameter)\n\n함수에서 입력값으로 사용하는 변수로, 1개 이상의 값을 적을 수 있음\n\n\n\n\n함수 형태\n\n\n\n\n\n\n\n\n\n구분\n매개변수 없음\n매개변수 있음\n\n\n\n\n반환값 없음\n함수 내부 명령문만 수행\n매개변수를 사용하여 명령문만 수행\n\n\n반환값 있음\n매개변수 없이 명령문을 수행한 후 결과값 반환\n매개변수를 사용하여 명령문을 수행한 후 결과값 반환\n\n\n\n\n# 매개변수 ×, 반환값 ×\ndef func():\n    print('함수입니다.')\n\nprint('함수 호출 전입니다')\nfunc()\nprint('함수 호출 후입니다')\n\n함수 호출 전입니다\n함수입니다.\n함수 호출 후입니다\n\n\n\n# 매개변수 ○, 반환값 ×\ndef add1(x, y):\n    print(x+y)\n\nres1 = add1(10,20)\nprint(res1)\n\n30\nNone\n\n\n\n# 매개변수 ○, 반환값 ○\ndef add2(x, y):\n    return x+y\n\nres2 = add2(10,20)\nprint(res2)\n\n30\n\n\n\n## 섭씨온도를 화씨온도로 변환하는 함수\n# (섭씨온도) = (화씨온도 - 32) × 5/9\ndef f_to_c(fahrenheit):\n    return (fahrenheit-32) * 5/9\n\nf_to_c(100)\n\n37.77777777777778"
  },
  {
    "objectID": "2_4_function.html#함수",
    "href": "2_4_function.html#함수",
    "title": "2. Python 기초",
    "section": "",
    "text": "함수(function)\n\n특정한 기능을 수행하도록 미리 만들어 놓고, 필요할 때마다 호출하여 사용하는 일련의 코드\nPython에서 기본적으로 제공하는 내장 함수와 사용자가 직접 만들어서 사용할 수 있는 사용자 정의 함수가 있음\n\n\n\n\n함수 장점\n\n필요할 때마다 호출 가능 : 반복적으로 수행해야 하는 업무를 한 번만 작성해 놓고 필요할 때마다 호출하여 사용할 수 있음\n논리적인 단위로 분할 가능 : (예) 도형 계산 프로그램 - 덧셈 코드, 곱셈 코드, 나눗셈 코드 등으로 나눔\n코드의 캡슐화 가능 : 함수의 인터페이스만 잘 정의하면 다른 사람이 자신의 코드를 쉽게 가져다 사용할 수 있음\n\n\n\n# 절대값 반환 함수\nabs(-10)\n\n10\n\n\n\n\n\n\n\ndef 함수 이름(매개변수1, 매개변수2, …):  　　문장  　　return 반환값\n\n\n\n함수 이름 규칙\n\n변수 이름 규칙과 동일함\n일반적으로 소문자로 입력\n작업을 나타내기 위해 동사와 명사를 함께 사용하는 경우가 많음 - (예) find_number\n외부에 공개하는 함수일 경우 줄임말을 사용하지 않고 짧고 명료한 이름으로 정함\n\n\n\n\n매개변수(parameter)\n\n함수에서 입력값으로 사용하는 변수로, 1개 이상의 값을 적을 수 있음\n\n\n\n\n함수 형태\n\n\n\n\n\n\n\n\n\n구분\n매개변수 없음\n매개변수 있음\n\n\n\n\n반환값 없음\n함수 내부 명령문만 수행\n매개변수를 사용하여 명령문만 수행\n\n\n반환값 있음\n매개변수 없이 명령문을 수행한 후 결과값 반환\n매개변수를 사용하여 명령문을 수행한 후 결과값 반환\n\n\n\n\n# 매개변수 ×, 반환값 ×\ndef func():\n    print('함수입니다.')\n\nprint('함수 호출 전입니다')\nfunc()\nprint('함수 호출 후입니다')\n\n함수 호출 전입니다\n함수입니다.\n함수 호출 후입니다\n\n\n\n# 매개변수 ○, 반환값 ×\ndef add1(x, y):\n    print(x+y)\n\nres1 = add1(10,20)\nprint(res1)\n\n30\nNone\n\n\n\n# 매개변수 ○, 반환값 ○\ndef add2(x, y):\n    return x+y\n\nres2 = add2(10,20)\nprint(res2)\n\n30\n\n\n\n## 섭씨온도를 화씨온도로 변환하는 함수\n# (섭씨온도) = (화씨온도 - 32) × 5/9\ndef f_to_c(fahrenheit):\n    return (fahrenheit-32) * 5/9\n\nf_to_c(100)\n\n37.77777777777778"
  },
  {
    "objectID": "3_1_structure.html",
    "href": "3_1_structure.html",
    "title": "3. 자료구조",
    "section": "",
    "text": "자료구조(data structure)\n\n데이터의 특징을 고려하여 메모리에 효율적으로 저장 및 반환하는 방법으로 데이터를 관리하는 방식\n\n\n\n\n자료구조의 중요성\n\n데이터 저장과 검색 효율화 : (예) 빠른 검색이 필요한 경우 딕셔너리 사용\n연산 속도 최적화 : (예) 중복을 제거하는 경우 리스트보다 세트가 효율적임\n메모리 사용 절약 : (예) 불변형 객체를 다룰 때는 리스트 대신 튜플 사용\n코드 가독성 및 유지보수성 향상\n\n\n\n\n\n\n\nPython은 리스트(list), 튜플(tuple), 세트(set), 딕셔너리(dictionary)의 4개 대표적인 자료구조를 제공함\n\n\n\n\n\n\n\n\n자료구조\n설명\n\n\n\n\n리스트(list)\n여러 개의 값을 저장할 수 있는 순차적인 자료구조\n\n\n튜플(tuple)\n리스트와 같지만 데이터의 변경을 허용하지 않는 자료구조\n\n\n세트(set)\n데이터의 중복을 허용하지 않고, 수학의 집합 연산을 지원하는 자료구조\n\n\n딕셔너리(dictionary)\n키(key)와 값(value)의 형태로 데이터를 저장하는 자료구조\n\n\n\n\n\n자료구조 비교\n\n\n\n\n자료구조\n순서 유지\n변경 가능\n중복 허용\n특징\n\n\n\n\n리스트(list)\n○\n○\n○\n가장 기본적인 자료구조, 인덱스로 접근\n\n\n튜플(tuple)\n○\n×\n○\n리스트와 유사하지만 불변형(immutable)\n\n\n세트(set)\n×\n○\n×\n중복 제거, 수학적 집합 연산 가능\n\n\n딕셔너리(dictionary)\n○\n○\n△\n키-값(key-value) 형태로 저장"
  },
  {
    "objectID": "3_1_structure.html#자료구조",
    "href": "3_1_structure.html#자료구조",
    "title": "3. 자료구조",
    "section": "",
    "text": "자료구조(data structure)\n\n데이터의 특징을 고려하여 메모리에 효율적으로 저장 및 반환하는 방법으로 데이터를 관리하는 방식\n\n\n\n\n자료구조의 중요성\n\n데이터 저장과 검색 효율화 : (예) 빠른 검색이 필요한 경우 딕셔너리 사용\n연산 속도 최적화 : (예) 중복을 제거하는 경우 리스트보다 세트가 효율적임\n메모리 사용 절약 : (예) 불변형 객체를 다룰 때는 리스트 대신 튜플 사용\n코드 가독성 및 유지보수성 향상\n\n\n\n\n\n\n\nPython은 리스트(list), 튜플(tuple), 세트(set), 딕셔너리(dictionary)의 4개 대표적인 자료구조를 제공함\n\n\n\n\n\n\n\n\n자료구조\n설명\n\n\n\n\n리스트(list)\n여러 개의 값을 저장할 수 있는 순차적인 자료구조\n\n\n튜플(tuple)\n리스트와 같지만 데이터의 변경을 허용하지 않는 자료구조\n\n\n세트(set)\n데이터의 중복을 허용하지 않고, 수학의 집합 연산을 지원하는 자료구조\n\n\n딕셔너리(dictionary)\n키(key)와 값(value)의 형태로 데이터를 저장하는 자료구조\n\n\n\n\n\n자료구조 비교\n\n\n\n\n자료구조\n순서 유지\n변경 가능\n중복 허용\n특징\n\n\n\n\n리스트(list)\n○\n○\n○\n가장 기본적인 자료구조, 인덱스로 접근\n\n\n튜플(tuple)\n○\n×\n○\n리스트와 유사하지만 불변형(immutable)\n\n\n세트(set)\n×\n○\n×\n중복 제거, 수학적 집합 연산 가능\n\n\n딕셔너리(dictionary)\n○\n○\n△\n키-값(key-value) 형태로 저장"
  },
  {
    "objectID": "3_3_tuple.html",
    "href": "3_3_tuple.html",
    "title": "3. 자료구조",
    "section": "",
    "text": "튜플(tuple)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 존재하는 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에는 수정할 수 없는 불변형(immutable) 객체\n정수형, 부동소수점형, 문자열형, bool형, 리스트, 튜플, 딕셔너리 등 다양한 자료형을 저장할 수 있는 컨테이너형 객체\n리스트와 구조 및 사용 방법이 거의 동일하지만, 수정이 불가능하다는 차이점이 있음\n\n\n\n\n튜플 생성\n\n리터럴 방식(tuple literal)\n\n()를 사용하여 튜플을 직접 정의하는 방법\n() 안에 원소(element)를 ,로 구분하여 나열함\n()을 생략할 수도 있지만, 원소가 하나인 경우에는 (값,)처럼 반드시 ,를 포함해야 함\n\n생성자 방식(tuple constructor)\n\ntuple() 함수를 사용하여 튜플을 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 튜플을 생성할 때 유용함\n\n\n\n\n# 튜플 생성1\ntpl = (1, 2, 3, 4, 5)\nprint(tpl)\n\n(1, 2, 3, 4, 5)\n\n\n\n# 튜플 생성2\ntpl = 1, 2, 3, 4, 5\nprint(tpl)\n\n(1, 2, 3, 4, 5)\n\n\n\n# 튜플 생성3 : 원소가 하나인 경우에는 반드시 ,를 포함해야 함\ntpl = (1,)\nprint(tpl)\n\n(1,)\n\n\n\n# 튜플 생성4 : 튜플은 다양한 자료형을 저장할 수 있음\ntpl = (1, 3.14, \"Hello\", True, [11, 12, 13], (21, 22))\nprint(tpl)\n\n(1, 3.14, 'Hello', True, [11, 12, 13], (21, 22))\n\n\n\n# 튜플 생성5 : iterable 객체 사용\ntpl = tuple(\"Hello\")\nprint(tpl)\n\n('H', 'e', 'l', 'l', 'o')\n\n\n\n# 튜플 생성6 : iterable 객체 사용\ntpl = tuple([1, 2, 3])\nprint(tpl)\n\n(1, 2, 3)\n\n\n\n\n\n\n\n리스트 연산과 문법이 동일함\n튜플 연결 연산자 + : 두 튜플을 연결해서 새로운 튜플 생성\n튜플 반복 연산자 * : 튜플을 숫자만큼 반복하여 새로운 튜플 생성 - (예) 튜플*숫자\n튜플 전개 연산자 * : 튜플의 개별 원소를 분리하여 다른 튜플 전개 - (예) (*튜플)\n\n\n# 튜플 연결\ntpl1 = 1, 2, 3\ntpl2 = 11, 12, 13\nprint(tpl1 + tpl2)\n\n(1, 2, 3, 11, 12, 13)\n\n\n\n# 튜플 반복\nprint(tpl1 * 3)\n\n(1, 2, 3, 1, 2, 3, 1, 2, 3)\n\n\n\n# 튜플 전개\ntpl = 1, 2, 3, 4, 5\nprint((tpl, tpl))\nprint((*tpl, *tpl))\n\n((1, 2, 3, 4, 5), (1, 2, 3, 4, 5))\n(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)\n\n\n\n\n\n\n\n\n\n패킹(packing) : 여러 개의 데이터를 한 변수에 묶어 할당하는 것\n언패킹(unpacking) : 한 변수에 묶인 데이터를 개별적인 변수들에 할당하는 것\n\n\n# 튜플 패킹\ntpl = 1, 2, 3\nprint(tpl)\n\n(1, 2, 3)\n\n\n\n# 튜플 언패킹\ntpl = 1, 2, 3\nx, y, z = tpl\nprint(x)\nprint(y)\nprint(z)\n\n1\n2\n3\n\n\n\n# 튜플 패킹과 언패킹 : 임시변수 없이 두 변수의 값을 쉽게 교환할 수 있음\na = 7\nb = 11\na, b = b, a\nprint(a)\nprint(b)\n\n11\n7\n\n\n\n# 언패킹 시 변수 개수 불일치 오류\n#a, b = 1, 2, 3\n#x, y, z = 4, 5\n\n\n# 언패킹 시 *을 이용한 가변 개수 처리\n# *변수는 여러 개의 값을 저장해야 하므로, 가변적인 리스트로 처리됨\n*x, y, z = 5, 6, 7, 8\nprint(x)\nprint(y)\nprint(z)\n\n[5, 6]\n7\n8\n\n\n\n\n\n\n\n가변 인수를 사용하면 전달된 인수들은 튜플로 패킹됨\n*를 사용하여 튜플을 언패킹하여 함수에 전달함\n\n\n# 가변 인수와 패킹, 언패킹\ndef print_args(*args):\n    print(\"Packed arguments:\", args)                        # 전달된 값이 튜플로 패킹됨\n\nprint_args(1, 2, 3, 4)\n\ntpl = 11, 12, 13\nprint_args(tpl)                                             # 튜플 자체를 인수로 전달\nprint_args(*tpl)                                            # 튜플을 언패킹하여 함수에 전달\n\nPacked arguments: (1, 2, 3, 4)\nPacked arguments: ((11, 12, 13),)\nPacked arguments: (11, 12, 13)\n\n\n\n# 키워드 인수와 언패킹\ndef sum_numbers(a, b, c, d):\n    return a + b + c + d\n\ntpl = 1, 2, 3, 4\n\nprint(sum_numbers(tpl[0], tpl[1], tpl[2], tpl[3]))          # 개별 원소를 인수로 전달\nprint(sum_numbers(*tpl))                                    # 튜플을 언패킹하여 함수에 전달\n\n10\n10\n\n\n\n\n\n\n\n함수에서 여러 개의 값을 반환하면 자동으로 튜플로 패킹됨\n함수가 반환한 튜플을 언패킹하여 개별 변수에 할당할 수 있음\n\n\n# 반환값과 패킹, 언패킹\ndef get_student_info():\n    return \"Alice\", 20, \"Statistics\"                        # 튜플로 자동 패킹됨\n\n# 패킹된 값 출력\ninfo = get_student_info()\nprint(info)\n\n# 언패킹하여 개별 변수에 할당\nname, age, major = get_student_info()\nprint(name)\nprint(age)\nprint(major)\n\n('Alice', 20, 'Statistics')\nAlice\n20\nStatistics\n\n\n\n\n\n\n\n\n리스트와 문법이 동일함\n인덱싱(indexing) : [index]를 사용하여 튜플의 특정 위치에 있는 원소에 접근함\n슬라이싱(slicing) : [(start index):(stop index)]를 사용하여 튜플의 일부 원소를 추출함\n\n리스트와 달리 불변형 객체이므로 슬라이싱을 이용하여 기존 튜플의 일부를 삭제하거나, 새로운 원소를 추가 및 변경할 수 없음\n\n\n\n# 튜플 인덱싱1\ntpl = 1, 2, 3, 4, 5\nprint(tpl[0])\n\n1\n\n\n\n# 튜플 인덱싱2\ntpl = 1, 2, 3, 4, 5\nprint(tpl[-1])\n\n5\n\n\n\n# 튜플 슬라이싱1\ntpl = 1, 2, 3, 4, 5\nprint(tpl[0:2])\n\n(1, 2)\n\n\n\n# 튜플 슬라이싱2\ntpl = 1, 2, 3, 4, 5\nprint(tpl[:2])\nprint(tpl[2:])\nprint(tpl[::2])\n\n(1, 2)\n(3, 4, 5)\n(1, 3, 5)\n\n\n\n# 튜플은 불변형 객체이므로 인덱스를 이용한 수정이 불가능함\n#tpl = 1, 2, 3, 4, 5\n#tpl[2] = 3\n#print(tpl)\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ncount()\n튜플 내부에 특정 값이 몇 번 나타나는지 개수를 반환\n\n\nindex()\n튜플 내부에 특정 값의 첫 번째 인덱스를 반환하며, 없으면 오류 발생\n\n\nin 연산자\n튜플 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\nlen()\n튜플 원소의 개수(튜플 길이) 반환\n\n\nsum()\n튜플 원소의 합계 반환\n\n\nmax()\n튜플 원소 중 최대값 반환\n\n\nmin()\n튜플 원소 중 최소값 반환\n\n\n\n\n# 특정 값 개수\ntpl = 1, 2, 3, 1, 4, 5, 1, 6, 7\nprint(tpl.count(1))\nprint(tpl.count(9))\n\n3\n0\n\n\n\n# 특정 값의 첫 번쩨 인덱스\ntpl = 1, 2, 3, 1, 4, 5, 1, 6, 7\nprint(tpl.index(1))\n#print(tpl.index(9))\n\n0\n\n\n\n# 특정값 찾기\ntpl = 1, 2, 3, 4, 5\nprint(3 in tpl)\nprint(6 in tpl)\n\nTrue\nFalse\n\n\n\ntpl = 1, 2, 3, 4, 5\nprint(len(tpl))\nprint(sum(tpl))\nprint(max(tpl))\nprint(min(tpl))\n\n5\n15\n5\n1"
  },
  {
    "objectID": "3_3_tuple.html#튜플",
    "href": "3_3_tuple.html#튜플",
    "title": "3. 자료구조",
    "section": "",
    "text": "튜플(tuple)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 존재하는 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에는 수정할 수 없는 불변형(immutable) 객체\n정수형, 부동소수점형, 문자열형, bool형, 리스트, 튜플, 딕셔너리 등 다양한 자료형을 저장할 수 있는 컨테이너형 객체\n리스트와 구조 및 사용 방법이 거의 동일하지만, 수정이 불가능하다는 차이점이 있음\n\n\n\n\n튜플 생성\n\n리터럴 방식(tuple literal)\n\n()를 사용하여 튜플을 직접 정의하는 방법\n() 안에 원소(element)를 ,로 구분하여 나열함\n()을 생략할 수도 있지만, 원소가 하나인 경우에는 (값,)처럼 반드시 ,를 포함해야 함\n\n생성자 방식(tuple constructor)\n\ntuple() 함수를 사용하여 튜플을 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 튜플을 생성할 때 유용함\n\n\n\n\n# 튜플 생성1\ntpl = (1, 2, 3, 4, 5)\nprint(tpl)\n\n(1, 2, 3, 4, 5)\n\n\n\n# 튜플 생성2\ntpl = 1, 2, 3, 4, 5\nprint(tpl)\n\n(1, 2, 3, 4, 5)\n\n\n\n# 튜플 생성3 : 원소가 하나인 경우에는 반드시 ,를 포함해야 함\ntpl = (1,)\nprint(tpl)\n\n(1,)\n\n\n\n# 튜플 생성4 : 튜플은 다양한 자료형을 저장할 수 있음\ntpl = (1, 3.14, \"Hello\", True, [11, 12, 13], (21, 22))\nprint(tpl)\n\n(1, 3.14, 'Hello', True, [11, 12, 13], (21, 22))\n\n\n\n# 튜플 생성5 : iterable 객체 사용\ntpl = tuple(\"Hello\")\nprint(tpl)\n\n('H', 'e', 'l', 'l', 'o')\n\n\n\n# 튜플 생성6 : iterable 객체 사용\ntpl = tuple([1, 2, 3])\nprint(tpl)\n\n(1, 2, 3)\n\n\n\n\n\n\n\n리스트 연산과 문법이 동일함\n튜플 연결 연산자 + : 두 튜플을 연결해서 새로운 튜플 생성\n튜플 반복 연산자 * : 튜플을 숫자만큼 반복하여 새로운 튜플 생성 - (예) 튜플*숫자\n튜플 전개 연산자 * : 튜플의 개별 원소를 분리하여 다른 튜플 전개 - (예) (*튜플)\n\n\n# 튜플 연결\ntpl1 = 1, 2, 3\ntpl2 = 11, 12, 13\nprint(tpl1 + tpl2)\n\n(1, 2, 3, 11, 12, 13)\n\n\n\n# 튜플 반복\nprint(tpl1 * 3)\n\n(1, 2, 3, 1, 2, 3, 1, 2, 3)\n\n\n\n# 튜플 전개\ntpl = 1, 2, 3, 4, 5\nprint((tpl, tpl))\nprint((*tpl, *tpl))\n\n((1, 2, 3, 4, 5), (1, 2, 3, 4, 5))\n(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)\n\n\n\n\n\n\n\n\n\n패킹(packing) : 여러 개의 데이터를 한 변수에 묶어 할당하는 것\n언패킹(unpacking) : 한 변수에 묶인 데이터를 개별적인 변수들에 할당하는 것\n\n\n# 튜플 패킹\ntpl = 1, 2, 3\nprint(tpl)\n\n(1, 2, 3)\n\n\n\n# 튜플 언패킹\ntpl = 1, 2, 3\nx, y, z = tpl\nprint(x)\nprint(y)\nprint(z)\n\n1\n2\n3\n\n\n\n# 튜플 패킹과 언패킹 : 임시변수 없이 두 변수의 값을 쉽게 교환할 수 있음\na = 7\nb = 11\na, b = b, a\nprint(a)\nprint(b)\n\n11\n7\n\n\n\n# 언패킹 시 변수 개수 불일치 오류\n#a, b = 1, 2, 3\n#x, y, z = 4, 5\n\n\n# 언패킹 시 *을 이용한 가변 개수 처리\n# *변수는 여러 개의 값을 저장해야 하므로, 가변적인 리스트로 처리됨\n*x, y, z = 5, 6, 7, 8\nprint(x)\nprint(y)\nprint(z)\n\n[5, 6]\n7\n8\n\n\n\n\n\n\n\n가변 인수를 사용하면 전달된 인수들은 튜플로 패킹됨\n*를 사용하여 튜플을 언패킹하여 함수에 전달함\n\n\n# 가변 인수와 패킹, 언패킹\ndef print_args(*args):\n    print(\"Packed arguments:\", args)                        # 전달된 값이 튜플로 패킹됨\n\nprint_args(1, 2, 3, 4)\n\ntpl = 11, 12, 13\nprint_args(tpl)                                             # 튜플 자체를 인수로 전달\nprint_args(*tpl)                                            # 튜플을 언패킹하여 함수에 전달\n\nPacked arguments: (1, 2, 3, 4)\nPacked arguments: ((11, 12, 13),)\nPacked arguments: (11, 12, 13)\n\n\n\n# 키워드 인수와 언패킹\ndef sum_numbers(a, b, c, d):\n    return a + b + c + d\n\ntpl = 1, 2, 3, 4\n\nprint(sum_numbers(tpl[0], tpl[1], tpl[2], tpl[3]))          # 개별 원소를 인수로 전달\nprint(sum_numbers(*tpl))                                    # 튜플을 언패킹하여 함수에 전달\n\n10\n10\n\n\n\n\n\n\n\n함수에서 여러 개의 값을 반환하면 자동으로 튜플로 패킹됨\n함수가 반환한 튜플을 언패킹하여 개별 변수에 할당할 수 있음\n\n\n# 반환값과 패킹, 언패킹\ndef get_student_info():\n    return \"Alice\", 20, \"Statistics\"                        # 튜플로 자동 패킹됨\n\n# 패킹된 값 출력\ninfo = get_student_info()\nprint(info)\n\n# 언패킹하여 개별 변수에 할당\nname, age, major = get_student_info()\nprint(name)\nprint(age)\nprint(major)\n\n('Alice', 20, 'Statistics')\nAlice\n20\nStatistics\n\n\n\n\n\n\n\n\n리스트와 문법이 동일함\n인덱싱(indexing) : [index]를 사용하여 튜플의 특정 위치에 있는 원소에 접근함\n슬라이싱(slicing) : [(start index):(stop index)]를 사용하여 튜플의 일부 원소를 추출함\n\n리스트와 달리 불변형 객체이므로 슬라이싱을 이용하여 기존 튜플의 일부를 삭제하거나, 새로운 원소를 추가 및 변경할 수 없음\n\n\n\n# 튜플 인덱싱1\ntpl = 1, 2, 3, 4, 5\nprint(tpl[0])\n\n1\n\n\n\n# 튜플 인덱싱2\ntpl = 1, 2, 3, 4, 5\nprint(tpl[-1])\n\n5\n\n\n\n# 튜플 슬라이싱1\ntpl = 1, 2, 3, 4, 5\nprint(tpl[0:2])\n\n(1, 2)\n\n\n\n# 튜플 슬라이싱2\ntpl = 1, 2, 3, 4, 5\nprint(tpl[:2])\nprint(tpl[2:])\nprint(tpl[::2])\n\n(1, 2)\n(3, 4, 5)\n(1, 3, 5)\n\n\n\n# 튜플은 불변형 객체이므로 인덱스를 이용한 수정이 불가능함\n#tpl = 1, 2, 3, 4, 5\n#tpl[2] = 3\n#print(tpl)\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ncount()\n튜플 내부에 특정 값이 몇 번 나타나는지 개수를 반환\n\n\nindex()\n튜플 내부에 특정 값의 첫 번째 인덱스를 반환하며, 없으면 오류 발생\n\n\nin 연산자\n튜플 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\nlen()\n튜플 원소의 개수(튜플 길이) 반환\n\n\nsum()\n튜플 원소의 합계 반환\n\n\nmax()\n튜플 원소 중 최대값 반환\n\n\nmin()\n튜플 원소 중 최소값 반환\n\n\n\n\n# 특정 값 개수\ntpl = 1, 2, 3, 1, 4, 5, 1, 6, 7\nprint(tpl.count(1))\nprint(tpl.count(9))\n\n3\n0\n\n\n\n# 특정 값의 첫 번쩨 인덱스\ntpl = 1, 2, 3, 1, 4, 5, 1, 6, 7\nprint(tpl.index(1))\n#print(tpl.index(9))\n\n0\n\n\n\n# 특정값 찾기\ntpl = 1, 2, 3, 4, 5\nprint(3 in tpl)\nprint(6 in tpl)\n\nTrue\nFalse\n\n\n\ntpl = 1, 2, 3, 4, 5\nprint(len(tpl))\nprint(sum(tpl))\nprint(max(tpl))\nprint(min(tpl))\n\n5\n15\n5\n1"
  },
  {
    "objectID": "3_5_dictionary.html",
    "href": "3_5_dictionary.html",
    "title": "3. 자료구조",
    "section": "",
    "text": "딕셔너리(dictionary)\n\n여러 개의 키-값(key-value) 쌍을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 있는 매핑 자료형(mapping data type)(Python 3.7+)\n키(key)를 통해 값(value)을 찾는 구조\n\n키는 중복될 수 없고(해시 가능한 자료형만 가능), 값은 중복 가능함(모든 자료형 가능)\n\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n\n\n\n\n딕셔너리 생성\n\n리터럴 방식(dictionary literal)\n\n{key: value}를 사용하여 딕셔너리를 직접 정의하는 방법\n{} 안에 여러 개의 key: value 쌍을 ,로 구분하여 나열함\n중복된 키가 있으면 마지막에 정의한 값이 적용됨\n\n생성자 방식(dictionary constructor)\n\ndict() 함수를 사용하여 딕셔너리를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 딕셔너리를 생성할 때 유용함\n\nzip() 함수를 이용하여 여러 개의 리스트나 튜플을 병렬로 묶어 키-값 쌍의 형태로 구성할 수 있음\nenumerate() 함수를 이용하여 인덱스를 키로, 원소를 값으로 하여 쌍으로 묶어 딕셔너리를 생성할 수 있음\n\n\n\n\n\n# 딕셔너리 생성1\ndct = {'a': 1, 'b': 2, 'c': 3}\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 생성2\ndct = dict(a=1, b=2, c=3)\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 생성3 : 키는 중복될 수 없음\ndct = {'a':1, 'b': 2, 'c': 3, 'a': 4, 'b': 5}\nprint(dct)\n\n{'a': 4, 'b': 5, 'c': 3}\n\n\n\n# 딕셔너리 생성4 : (key, value) 쌍의 리스트 사용\ndct = dict([('x', 100), ('y', 200)])\nprint(dct)\n\n{'x': 100, 'y': 200}\n\n\n\n# 딕셔너리 생성5 : zip() 함수 사용\nkeys = ['name', 'age', 'city']\nvalues = ['Alice', 28, 'Jeonju']\ndct = dict(zip(keys, values))\nprint(dct)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n\n\n\n# 딕셔너리 생성6 : enumerate() 함수 사용\nfruits = ['apple', 'banana', 'cherry']\ndct = dict(enumerate(fruits))\nprint(dct)\n\n{0: 'apple', 1: 'banana', 2: 'cherry'}\n\n\n\n\n\n\n\n딕셔너리는 키를 사용하여 값에 접근함\n리스트, 튜플처럼 정수 인덱스를 이용한 접근은 불가능함\n\n\n# 키를 이용한 값 접근\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(info['name'])\nprint(info['age'])\n\nAlice\n28\n\n\n\n# 딕셔너리는 가변형 객체이므로 키를 이용한 수정이 가능함\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ninfo['city'] = 'Iksan'\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Iksan'}\n\n\n\n# 새로운 키-값 쌍 추가\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ninfo['email'] = 'alice123@gmail.com'\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju', 'email': 'alice123@gmail.com'}\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nkeys()\n딕셔너리의 모든 키를 반환(dict_keys 객체)\n\n\nvalues()\n딕셔너리의 모든 값을 반환(dict_values 객체)\n\n\nitems()\n(키, 값) 쌍을 튜플 형태로 반환(dict_items 객체)\n\n\nget()\n지정한 키의 값을 반환하며, 없으면 None 반환\n\n\nin 연산자\n특정 키가 딕셔너리에 있다면 True, 없다면 False 반환\n\n\n\n\n# 모든 키\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.keys()))\n\n['name', 'age', 'city']\n\n\n\n# 모든 값\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.values()))\n\n['Alice', 28, 'Jeonju']\n\n\n\n# (키, 값) 쌍\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.items()))\n\n[('name', 'Alice'), ('age', 28), ('city', 'Jeonju')]\n\n\n\n# 키를 이용한 값 조회\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(info.get('name'))\nprint(info.get('email'))\n\nAlice\nNone\n\n\n\n# 특정 키 찾기\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint('age' in info)\nprint('email' in info)\n\nTrue\nFalse\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nupdate()\n다른 딕셔너리나 키워드 인수를 이용하여 원소를 추가 및 수정\n\n\npop()\n특정 키의 값을 삭제하고 그 값을 반환하며, 키가 없으면 오류 발생\n\n\npopitem()\n마지막 (키, 값) 쌍을 삭제하고 반환\n\n\ndel 키워드\n특정 키의 원소를 삭제하며, 키가 없으면 오류 발생\n\n\nclear()\n딕셔너리의 모든 원소를 삭제\n\n\n\n\n# 원소 추가 및 수정1\ninfo = {'name': 'Alice', 'age': 28}\ninfo.update({'age': 29, 'city': 'Jeonju'})\nprint(info)\n\n{'name': 'Alice', 'age': 29, 'city': 'Jeonju'}\n\n\n\n# 원소 추가 및 수정2\ninfo = {'name': 'Alice', 'age': 28}\ninfo.update(age=29, city='Jeonju')\nprint(info)\n\n{'name': 'Alice', 'age': 29, 'city': 'Jeonju'}\n\n\n\n# 특정 키의 값 삭제1\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nage = info.pop('age')\nprint(info)\nprint(age)\n\n{'name': 'Alice', 'city': 'Jeonju'}\n28\n\n\n\n# 특정 키의 값 삭제2\n#info = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n#age = info.pop('email')\n#print(info)\n#print(email)\n\n\n# 마지막 (키, 값) 쌍 삭제\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nlast_item = info.popitem()\nprint(info)\nprint(last_item)\n\n{'name': 'Alice', 'age': 28}\n('city', 'Jeonju')\n\n\n\n# 특정 키의 원소 삭제1\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ndel info['age']\nprint(info)\n\n{'name': 'Alice', 'city': 'Jeonju'}\n\n\n\n# 특정 키의 원소 삭제2\n#info = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n#del info['email']\n#print(info)\n\n\n\n\n\n\n\n\n\n패킹(packing) : 여러 개의 키-값 쌍을 하나의 딕셔너리로 묶어 할당하는 것\n언패킹(unpacking) : 하나의 딕셔너리에 묶인 키-값 쌍을 개별 변수에 분리하여 할당하는 것\n\n\n# 딕셔너리 패킹\ndct = {'a': 1, 'b': 2, 'c': 3}\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 언패킹\nd = {'a': 1, 'b': 2, 'c': 3}\na, b, c = d.values()\nprint(a)\nprint(b)\nprint(c)\n\n1\n2\n3\n\n\n\n\n\n\n\n딕셔너리를 이용하여 함수의 키워드 가변 인수(keyword variable-length arguments)를 처리할 수 있음\n**를 사용하여 딕셔너리를 언패킹하면, 각 키-쌍이 함수의 키워드 인수로 전달됨\n\n\n# 키워드 가변 인수와 패킹, 언패킹\ndef print_info(**kwargs):\n    for key, value in kwargs.items():                       # 전달된 값이 딕셔너리로 패킹됨\n        print(f\"{key}: {value}\")\n\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint_info(**info)                                          # 딕셔너리를 언패킹하여 함수에 전달\n\nname: Alice\nage: 28\ncity: Jeonju\n\n\n\n\n\n\n\n\n{키식: 값식 for 변수 in 반복범위 if 조건식}\n\n\n리스트 컴프리헨션과 문법이 유사하지만, 키:값 형태로 표현\n\n\n# 문자 개수 세기\nword = \"Hello\"\nchar_count = {char: word.count(char) for char in word}\nprint(char_count)\n\n{'H': 1, 'e': 1, 'l': 2, 'o': 1}\n\n\n\n# 두 리스트를 키와 값으로 합치기\nkeys = ['name', 'age', 'city']\nvalues = ['Alice', 28, 'Jeonju']\ninfo = {k: v for k, v in zip(keys, values)}\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n\n\n\n# 리스트를 인덱스와 함께 딕셔너리로 변환\nfruits = ['apple', 'banana', 'cherry']\ndct = {i: fruit for i, fruit in enumerate(fruits)}\nprint(dct)\n\n{0: 'apple', 1: 'banana', 2: 'cherry'}\n\n\n\n# 점수(값) 80 이상만 필터링\nscores = {'Alice': 85, 'Bob': 92, 'Charlie': 77, 'David': 90}\npassed = {name: score for name, score in scores.items() if score &gt;= 80}\nprint(passed)\n\n{'Alice': 85, 'Bob': 92, 'David': 90}\n\n\n\n# 가격(값)에 5% 할인 적용\nprices = {'apple': 1000, 'banana': 800, 'cherry': 1500}\ndiscounted_prices = {item: price * 0.95 for item, price in prices.items()}\nprint(discounted_prices)\n\n{'apple': 950.0, 'banana': 760.0, 'cherry': 1425.0}"
  },
  {
    "objectID": "3_5_dictionary.html#딕셔너리",
    "href": "3_5_dictionary.html#딕셔너리",
    "title": "3. 자료구조",
    "section": "",
    "text": "딕셔너리(dictionary)\n\n여러 개의 키-값(key-value) 쌍을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 있는 매핑 자료형(mapping data type)(Python 3.7+)\n키(key)를 통해 값(value)을 찾는 구조\n\n키는 중복될 수 없고(해시 가능한 자료형만 가능), 값은 중복 가능함(모든 자료형 가능)\n\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n\n\n\n\n딕셔너리 생성\n\n리터럴 방식(dictionary literal)\n\n{key: value}를 사용하여 딕셔너리를 직접 정의하는 방법\n{} 안에 여러 개의 key: value 쌍을 ,로 구분하여 나열함\n중복된 키가 있으면 마지막에 정의한 값이 적용됨\n\n생성자 방식(dictionary constructor)\n\ndict() 함수를 사용하여 딕셔너리를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 딕셔너리를 생성할 때 유용함\n\nzip() 함수를 이용하여 여러 개의 리스트나 튜플을 병렬로 묶어 키-값 쌍의 형태로 구성할 수 있음\nenumerate() 함수를 이용하여 인덱스를 키로, 원소를 값으로 하여 쌍으로 묶어 딕셔너리를 생성할 수 있음\n\n\n\n\n\n# 딕셔너리 생성1\ndct = {'a': 1, 'b': 2, 'c': 3}\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 생성2\ndct = dict(a=1, b=2, c=3)\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 생성3 : 키는 중복될 수 없음\ndct = {'a':1, 'b': 2, 'c': 3, 'a': 4, 'b': 5}\nprint(dct)\n\n{'a': 4, 'b': 5, 'c': 3}\n\n\n\n# 딕셔너리 생성4 : (key, value) 쌍의 리스트 사용\ndct = dict([('x', 100), ('y', 200)])\nprint(dct)\n\n{'x': 100, 'y': 200}\n\n\n\n# 딕셔너리 생성5 : zip() 함수 사용\nkeys = ['name', 'age', 'city']\nvalues = ['Alice', 28, 'Jeonju']\ndct = dict(zip(keys, values))\nprint(dct)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n\n\n\n# 딕셔너리 생성6 : enumerate() 함수 사용\nfruits = ['apple', 'banana', 'cherry']\ndct = dict(enumerate(fruits))\nprint(dct)\n\n{0: 'apple', 1: 'banana', 2: 'cherry'}\n\n\n\n\n\n\n\n딕셔너리는 키를 사용하여 값에 접근함\n리스트, 튜플처럼 정수 인덱스를 이용한 접근은 불가능함\n\n\n# 키를 이용한 값 접근\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(info['name'])\nprint(info['age'])\n\nAlice\n28\n\n\n\n# 딕셔너리는 가변형 객체이므로 키를 이용한 수정이 가능함\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ninfo['city'] = 'Iksan'\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Iksan'}\n\n\n\n# 새로운 키-값 쌍 추가\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ninfo['email'] = 'alice123@gmail.com'\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju', 'email': 'alice123@gmail.com'}\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nkeys()\n딕셔너리의 모든 키를 반환(dict_keys 객체)\n\n\nvalues()\n딕셔너리의 모든 값을 반환(dict_values 객체)\n\n\nitems()\n(키, 값) 쌍을 튜플 형태로 반환(dict_items 객체)\n\n\nget()\n지정한 키의 값을 반환하며, 없으면 None 반환\n\n\nin 연산자\n특정 키가 딕셔너리에 있다면 True, 없다면 False 반환\n\n\n\n\n# 모든 키\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.keys()))\n\n['name', 'age', 'city']\n\n\n\n# 모든 값\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.values()))\n\n['Alice', 28, 'Jeonju']\n\n\n\n# (키, 값) 쌍\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.items()))\n\n[('name', 'Alice'), ('age', 28), ('city', 'Jeonju')]\n\n\n\n# 키를 이용한 값 조회\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(info.get('name'))\nprint(info.get('email'))\n\nAlice\nNone\n\n\n\n# 특정 키 찾기\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint('age' in info)\nprint('email' in info)\n\nTrue\nFalse\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nupdate()\n다른 딕셔너리나 키워드 인수를 이용하여 원소를 추가 및 수정\n\n\npop()\n특정 키의 값을 삭제하고 그 값을 반환하며, 키가 없으면 오류 발생\n\n\npopitem()\n마지막 (키, 값) 쌍을 삭제하고 반환\n\n\ndel 키워드\n특정 키의 원소를 삭제하며, 키가 없으면 오류 발생\n\n\nclear()\n딕셔너리의 모든 원소를 삭제\n\n\n\n\n# 원소 추가 및 수정1\ninfo = {'name': 'Alice', 'age': 28}\ninfo.update({'age': 29, 'city': 'Jeonju'})\nprint(info)\n\n{'name': 'Alice', 'age': 29, 'city': 'Jeonju'}\n\n\n\n# 원소 추가 및 수정2\ninfo = {'name': 'Alice', 'age': 28}\ninfo.update(age=29, city='Jeonju')\nprint(info)\n\n{'name': 'Alice', 'age': 29, 'city': 'Jeonju'}\n\n\n\n# 특정 키의 값 삭제1\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nage = info.pop('age')\nprint(info)\nprint(age)\n\n{'name': 'Alice', 'city': 'Jeonju'}\n28\n\n\n\n# 특정 키의 값 삭제2\n#info = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n#age = info.pop('email')\n#print(info)\n#print(email)\n\n\n# 마지막 (키, 값) 쌍 삭제\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nlast_item = info.popitem()\nprint(info)\nprint(last_item)\n\n{'name': 'Alice', 'age': 28}\n('city', 'Jeonju')\n\n\n\n# 특정 키의 원소 삭제1\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ndel info['age']\nprint(info)\n\n{'name': 'Alice', 'city': 'Jeonju'}\n\n\n\n# 특정 키의 원소 삭제2\n#info = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n#del info['email']\n#print(info)\n\n\n\n\n\n\n\n\n\n패킹(packing) : 여러 개의 키-값 쌍을 하나의 딕셔너리로 묶어 할당하는 것\n언패킹(unpacking) : 하나의 딕셔너리에 묶인 키-값 쌍을 개별 변수에 분리하여 할당하는 것\n\n\n# 딕셔너리 패킹\ndct = {'a': 1, 'b': 2, 'c': 3}\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 언패킹\nd = {'a': 1, 'b': 2, 'c': 3}\na, b, c = d.values()\nprint(a)\nprint(b)\nprint(c)\n\n1\n2\n3\n\n\n\n\n\n\n\n딕셔너리를 이용하여 함수의 키워드 가변 인수(keyword variable-length arguments)를 처리할 수 있음\n**를 사용하여 딕셔너리를 언패킹하면, 각 키-쌍이 함수의 키워드 인수로 전달됨\n\n\n# 키워드 가변 인수와 패킹, 언패킹\ndef print_info(**kwargs):\n    for key, value in kwargs.items():                       # 전달된 값이 딕셔너리로 패킹됨\n        print(f\"{key}: {value}\")\n\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint_info(**info)                                          # 딕셔너리를 언패킹하여 함수에 전달\n\nname: Alice\nage: 28\ncity: Jeonju\n\n\n\n\n\n\n\n\n{키식: 값식 for 변수 in 반복범위 if 조건식}\n\n\n리스트 컴프리헨션과 문법이 유사하지만, 키:값 형태로 표현\n\n\n# 문자 개수 세기\nword = \"Hello\"\nchar_count = {char: word.count(char) for char in word}\nprint(char_count)\n\n{'H': 1, 'e': 1, 'l': 2, 'o': 1}\n\n\n\n# 두 리스트를 키와 값으로 합치기\nkeys = ['name', 'age', 'city']\nvalues = ['Alice', 28, 'Jeonju']\ninfo = {k: v for k, v in zip(keys, values)}\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n\n\n\n# 리스트를 인덱스와 함께 딕셔너리로 변환\nfruits = ['apple', 'banana', 'cherry']\ndct = {i: fruit for i, fruit in enumerate(fruits)}\nprint(dct)\n\n{0: 'apple', 1: 'banana', 2: 'cherry'}\n\n\n\n# 점수(값) 80 이상만 필터링\nscores = {'Alice': 85, 'Bob': 92, 'Charlie': 77, 'David': 90}\npassed = {name: score for name, score in scores.items() if score &gt;= 80}\nprint(passed)\n\n{'Alice': 85, 'Bob': 92, 'David': 90}\n\n\n\n# 가격(값)에 5% 할인 적용\nprices = {'apple': 1000, 'banana': 800, 'cherry': 1500}\ndiscounted_prices = {item: price * 0.95 for item, price in prices.items()}\nprint(discounted_prices)\n\n{'apple': 950.0, 'banana': 760.0, 'cherry': 1425.0}"
  },
  {
    "objectID": "4_2_pandas.html",
    "href": "4_2_pandas.html",
    "title": "4. 라이브러리",
    "section": "",
    "text": "Pandas\n\nNumPy를 기반으로 만들어진 데이터 분석용 라이브러리\n레이블(label)로 식별되는 데이터를 쉽게 다룰 수 있도록 지원\n고성능 데이터 조작, 탐색, 전처리, 변환, 요약, 통계 연산 기능 제공\n주요 객체로는 Series(1차원), DataFrame(2차원), Index(레이블 관리 구조)가 있음\n\n\n\n\n\n\n\n\n\n\n객체\n설명\n\n\n\n\nSeries\n- 1차원 레이블이 붙은 배열로, 각 데이터에 고유한 인덱스가 있음 - 모든 원소가 동일한 자료형으로 저장되며, 숫자, 문자열, bool 등 다양한 자료형을 지원\n\n\nDataFrame\n- 2차원 표 형태의 데이터 구조로, 행(row)과 열(column)로 구성됨 - 각 열은 Series로 구성되어 있으며, 각 열이 서로 다른 자료형을 가질 수 있음 - DataFrame은 정렬(같은 인덱스 공유)된 Series 객체의 연속으로 볼 수 있음\n\n\nIndex\n- 데이터에 레이블을 부여하는 객체로, 행 또는 열에 사용됨 - 데이터 정렬, 선택, 결합 등을 효율적으로 할 수 있도록 지원\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\npd.Series()\n1차원 Series 객체 생성\n\n\npd.DataFrame()\n2차원 DataFrame 객체 생성\n\n\npd.Index()\nIndex 객체 생성\n\n\n\n\nimport numpy as np\nimport pandas as pd\n\n\n# Series 생성1 : 리스트 사용\nsr = pd.Series([1, 2, 3, 4, 5])\nprint(sr)\n\n0    1\n1    2\n2    3\n3    4\n4    5\ndtype: int64\n\n\n\n# Series 생성2 : 넘파이 배열 사용\nsr = pd.Series(np.array([1, 2, 3, 4, 5]))\nprint(sr)\n\n0    1\n1    2\n2    3\n3    4\n4    5\ndtype: int32\n\n\n\n# Series 생성3 : 딕셔너리 사용\n# 딕셔너리 키는 인덱스로 자동 지정됨\nsr = pd.Series({'a': 10, 'b': 20, 'c': 30})\nprint(sr)\n\na    10\nb    20\nc    30\ndtype: int64\n\n\n\n# Series 생성4 : 인덱스 지정\nsr = pd.Series([1, 2, 3], index = ['a', 'b', 'c'])\nprint(sr)\n\na    1\nb    2\nc    3\ndtype: int64\n\n\n\n# DataFrame 생성1 : Series 사용\nsr = pd.Series([1, 2, 3], index = ['a', 'b', 'c'])\ndf = pd.DataFrame(sr, columns = ['value'])\nprint(df)\n\n   value\na      1\nb      2\nc      3\n\n\n\n# DataFrame 생성2 : 리스트 사용\nlst = [['Alice', 22], ['Bob', 20], ['Charlie', 27]]\ndf = pd.DataFrame(lst, columns=['Name', 'Age'])\nprint(df)\n\n      Name  Age\n0    Alice   22\n1      Bob   20\n2  Charlie   27\n\n\n\n# DataFrame 생성3 : 넘파이 배열 사용\narr = np.array([['Alice', 22], ['Bob', 20], ['Charlie', 27]])\ndf = pd.DataFrame(arr, columns=['Name', 'Age'])\nprint(df)\n\n      Name Age\n0    Alice  22\n1      Bob  20\n2  Charlie  27\n\n\n\n# DataFrame 생성4 : 딕셔너리 사용\n# 딕셔너리 키는 열 이름으로 자동 지정됨\ndct = {'Name': ['Alice', 'Bob', 'Charlie'], 'Age': [22, 20, 27]}\ndf = pd.DataFrame(dct)\nprint(df)\n\n      Name  Age\n0    Alice   22\n1      Bob   20\n2  Charlie   27\n\n\n\n# DataFrame 생성5 : 딕셔너리 + 리스트 컴프리헨션 사용\ndct = [{'a': i, 'b': 2*i} for i in range(3)]\ndf = pd.DataFrame(dct)\nprint(df)\n\n   a  b\n0  0  0\n1  1  2\n2  2  4\n\n\n\n# DataFrame 생성6 : Series 사용\n# 서로 다른 인덱스를 가진 Series로 DataFrame을 생성하면\n# 공통된 인덱스를 기준으로 맞춰지고, 누락된 값은 NaN(Not a Number)으로 채워짐\nsr1 = pd.Series([1, 2, 3], index = ['a', 'b', 'c'])\nsr2 = pd.Series([4, 5, 6], index = ['a', 'c', 'd'])\ndf = pd.DataFrame({'x': sr1, 'y': sr2})\nprint(df)\n\n     x    y\na  1.0  4.0\nb  2.0  NaN\nc  3.0  5.0\nd  NaN  6.0\n\n\n\n# DataFrame 생성7 : 인덱스 및 열 이름 지정\ndata = [[101, 22], [102, 20], [103, 27]]\ncolumns = ['ID', 'Age']\nindex = ['Alice', 'Bob', 'Charlie']\ndf = pd.DataFrame(data, columns=columns, index=index)\nprint(df)\n\n          ID  Age\nAlice    101   22\nBob      102   20\nCharlie  103   27\n\n\n\n# Index 생성1 : 리스트 사용\nidx = pd.Index(['a', 'b', 'c', 'd'])\nidx\n\nIndex(['a', 'b', 'c', 'd'], dtype='object')\n\n\n\n# Index 생성2 : range() 사용\nidx = pd.Index(range(1, 6))\nidx\n\nRangeIndex(start=1, stop=6, step=1)\n\n\n\n\n\n\n\n\n\n속성\n설명\n\n\n\n\n.shape\n데이터프레임의 모양(행, 열)\n\n\n.index\n행 인덱스 조회 및 변경\n\n\n.columns\n열 이름 조회 및 변경\n\n\n.dtypes\n각 열의 자료형 확인\n\n\n\n\n# 데이터프레임 속성\ndf = pd.DataFrame({\n    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],\n    'Age': [25, 30, 35, 40, 28],\n    'Score': [85.5, 90.3, 78.2, 88.9, 92.5]\n})\n\nprint(df.shape)\nprint(df.index)\nprint(df.columns)\nprint(df.dtypes)\n\n(5, 3)\nRangeIndex(start=0, stop=5, step=1)\nIndex(['Name', 'Age', 'Score'], dtype='object')\nName      object\nAge        int64\nScore    float64\ndtype: object\n\n\n\n# 행 인덱스 변경\ndf.index = ['a', 'b', 'c', 'd', 'e']\nprint(df)\n\n      Name  Age  Score\na    Alice   25   85.5\nb      Bob   30   90.3\nc  Charlie   35   78.2\nd    David   40   88.9\ne      Eva   28   92.5\n\n\n\n# 열 이름 변경\ndf.columns = ['Student Name', 'Student Age', 'Exam Score']\nprint(df)\n\n  Student Name  Student Age  Exam Score\na        Alice           25        85.5\nb          Bob           30        90.3\nc      Charlie           35        78.2\nd        David           40        88.9\ne          Eva           28        92.5\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ninfo()\n기본 정보(행 개수, 열 개수, 데이터 자료형, 결측값 여부 등) 출력\n\n\nhead()\n상위 n개의 행 출력(초기 값 n=5)\n\n\ndescribe()\n수치형 데이터의 요약 통계량(평균, 표준편차 등) 제공\n\n\n\n\ndf = pd.DataFrame({\n    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],\n    'Age': [25, 30, 35, 40, 28],\n    'Score': [85.5, 90.3, 78.2, 88.9, 92.5]\n})\n\n\n# 기본 정보\nprint(df.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 5 entries, 0 to 4\nData columns (total 3 columns):\n #   Column  Non-Null Count  Dtype  \n---  ------  --------------  -----  \n 0   Name    5 non-null      object \n 1   Age     5 non-null      int64  \n 2   Score   5 non-null      float64\ndtypes: float64(1), int64(1), object(1)\nmemory usage: 252.0+ bytes\nNone\n\n\n\n# 상위 5개 행\nprint(df.head())\n\n      Name  Age  Score\n0    Alice   25   85.5\n1      Bob   30   90.3\n2  Charlie   35   78.2\n3    David   40   88.9\n4      Eva   28   92.5\n\n\n\n# 요약 통계량\nprint(df.describe())\n\n            Age      Score\ncount   5.00000   5.000000\nmean   31.60000  87.080000\nstd     5.94138   5.576917\nmin    25.00000  78.200000\n25%    28.00000  85.500000\n50%    30.00000  88.900000\n75%    35.00000  90.300000\nmax    40.00000  92.500000\n\n\n\n\n\n\n\n\n\n\n열 이름을 사용하여 직접 선택\n\n여러 개의 열을 선택할 때는 열 이름을 리스트로 작성\n\nloc[:, ] : 레이블(label) 기반 접근 방식\niloc[:, ] : 정수(integer) 기반 접근 방식\n\n\ndf = pd.DataFrame({\n    'A': [1, 2, 3],\n    'B': [4, 5, 6],\n    'C': [7, 8, 9],\n    'D': [10, 11, 12]\n}, index=['x', 'y', 'z'])\n\n\n# 열 인덱싱과 슬라이싱1 : 열 이름 사용\ndf['A']                                      # 열 이름\ndf[['A', 'C']]                               # 열 이름 리스트\n#df['A':'B']                                 # 열 이름 슬라이싱은 안 됨, Error!\n\n\n\n\n\n\n\n\nA\nC\n\n\n\n\nx\n1\n7\n\n\ny\n2\n8\n\n\nz\n3\n9\n\n\n\n\n\n\n\n\n# 열 인덱싱과 슬라이싱2 : 레이블 기반 접근\ndf.loc[:, 'A']                               # 열 이름\ndf.loc[:, ['A', 'C']]                        # 열 이름 리스트\ndf.loc[:, 'A':'B']                           # 열 이름 슬라이싱\ndf.loc[:, 'B'::2]                            # 열 이름 스트라이딩\ndf.loc[:, [True, False, True, True]]         # bool 리스트\n\n\n\n\n\n\n\n\nA\nC\nD\n\n\n\n\nx\n1\n7\n10\n\n\ny\n2\n8\n11\n\n\nz\n3\n9\n12\n\n\n\n\n\n\n\n\n# 열 인덱싱과 슬라이싱3 : 정수 기반 접근\ndf.iloc[:, 0]                                # 정수\ndf.iloc[:, [0, 3]]                           # 정수 리스트\ndf.iloc[:, range(2)]                         # range\ndf.iloc[:, 0:3]                              # 슬라이싱\ndf.iloc[:, 1::2]                             # 스트라이딩\n\n\n\n\n\n\n\n\nB\nD\n\n\n\n\nx\n4\n10\n\n\ny\n5\n11\n\n\nz\n6\n12\n\n\n\n\n\n\n\n\n\n\n\n\nloc[, :] : 레이블(label) 기반 접근 방식\niloc[, :] : 정수(integer) 기반 접근 방식\n\n\n# 행 인덱싱과 슬라이싱1 : 레이블 기반 접근\ndf.loc['x', ]                                # 인덱스 이름\ndf.loc[['x', 'y'], :]                        # 인덱스 이름 리스트\ndf.loc['x':'y', :]                           # 인덱스 이름 슬라이싱\ndf.loc['x'::1, :]                            # 인덱스 이름 스트라이딩\ndf.loc[[True, False, True], :]               # bool 리스트\ndf.loc[list(df['A'] &lt; 3), :]                 # bool 리스트\ndf.loc[df['A'] &lt; 3, :]                       # bool 리스트\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nx\n1\n4\n7\n10\n\n\ny\n2\n5\n8\n11\n\n\n\n\n\n\n\n\n# 행 인덱싱과 슬라이싱2 : 정수 기반 접근\ndf.iloc[0, :]                                # 정수\ndf.iloc[[0, 2], :]                           # 정수 리스트\ndf.iloc[range(2), :]                         # range\ndf.iloc[0:1, :]                              # 슬라이싱\ndf.iloc[1::2, :]                             # 스트라이딩\ndf.iloc[[True, False, True], :]              # bool 리스트 (권장하지 않음)\ndf.iloc[list(df['A'] &lt; 3), :]                # bool 리스트 (권장하지 않음)\n#df.iloc[df['A'] &lt; 3, :]                     # bool 리스트 (Error!)\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nx\n1\n4\n7\n10\n\n\ny\n2\n5\n8\n11\n\n\n\n\n\n\n\n\n# 행 인덱싱과 슬라이싱3 : 정수 기반 접근\ndf.iloc[0]                                   # 정수\ndf.iloc[[0, 2]]                              # 정수 리스트\ndf.iloc[range(2)]                            # range\ndf.iloc[0:1]                                 # 슬라이싱\ndf.iloc[1::2]                                # 스트라이딩\ndf.iloc[[True, False, True]]                 # bool 리스트(권장하지 않음)\ndf.iloc[list(df['A'] &lt; 3)]                   # bool 리스트(권장하지 않음)\n#df.iloc[df['A'] &lt; 3]                        # bool 리스트 (Error!)\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nx\n1\n4\n7\n10\n\n\ny\n2\n5\n8\n11\n\n\n\n\n\n\n\n\n# 행 인덱싱과 슬라이싱4\n# 인덱싱은 열을 참조하는 반면, 슬라이싱은 행을 참조함\n#df[0]                                       # Error!\ndf[0:2]                                      # 권장하지 않음\ndf['x':'y']                                  # 권장하지 않음\ndf[df['A'] &lt; 3]                              # 불리언 인덱싱은 행 단위로 적용됨\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nx\n1\n4\n7\n10\n\n\ny\n2\n5\n8\n11\n\n\n\n\n\n\n\n\n# 행 인덱싱과 슬라이싱5\ndf = pd.DataFrame({\n    'A': [1, 2, 3],\n    'B': [4, 5, 6],\n    'C': [7, 8, 9],\n    'D': [10, 11, 12]})\n\ndf.loc[0:1]                                  # 명시적 인덱스(label) 사용 - 마지막 인덱스 포함\ndf.iloc[0:1]                                 # 암묵적 인덱스(integer) 사용 - 마지막 인덱스 제외\ndf[0:1]                                      # 암묵적 인덱스(integer) 사용, iloc와 동일\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n0\n1\n4\n7\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumPy와 동일하게 벡터화, 브로드캐스팅 모두 지원\n단항 연산: 인덱스와 열 레이블 보존\n이항 연산: 인덱스와 열 레이블을 기준으로 자동 정렬되어 연산\n\n위치가 아닌 동일한 레이블끼리 연산하며, 일치하지 않는 항목은 NaN으로 처리\n\n\n\n# 단항 연산1 : Series\nsr = pd.Series([1, 2, 3, 4, 5])\nprint(sr + 2)\n\n0    3\n1    4\n2    5\n3    6\n4    7\ndtype: int64\n\n\n\n# 단항 연산2 : DataFrame\ndf = pd.DataFrame({\n    'x': [1, 2, 3, 4, 5],\n    'y': [11, 12, 13, 14, 15] \n})\nprint(np.log(df))\n\n          x         y\n0  0.000000  2.397895\n1  0.693147  2.484907\n2  1.098612  2.564949\n3  1.386294  2.639057\n4  1.609438  2.708050\n\n\n\n# 이항 연산1 : Series\n# 두 시리즈에 존재하는 모든 행 인덱스를 포함한 결과 생성 (합집합처럼 동작)\nmath = pd.Series({'Alice': 85, 'Bob': 90, 'Charlie': 78})\nenglish = pd.Series({'Alice': 95, 'Charlie': 80, 'David': 88})\nprint(math + english)\n\nAlice      180.0\nBob          NaN\nCharlie    158.0\nDavid        NaN\ndtype: float64\n\n\n\n# 이항 연산2: DataFrame\nmidterm = pd.DataFrame({\n    'math': [85, 90, 78],\n    'science': [88, 92, 79]\n}, index=['Alice', 'Bob', 'Charlie'])\n\nfinal = pd.DataFrame({\n    'math': [95, 88, 82],\n    'english': [95, 80, 88]\n}, index=['Alice', 'Charlie', 'David'])\n\nprint(midterm + final)\n\n         english   math  science\nAlice        NaN  180.0      NaN\nBob          NaN    NaN      NaN\nCharlie      NaN  166.0      NaN\nDavid        NaN    NaN      NaN\n\n\n\n\n\n\n\n인덱스와 열 레이블이 일치하지 않아도 연산 가능\n예외 처리가 필요한 경우 기본 연산자보다 안정적임\n\nfill_value 인수를 사용하여 NaN를 다른 값으로 처리 가능\n\n\n\n\n\n연산자\n연산자 메소드\n\n\n\n\n+\nadd()\n\n\n-\nsub()\n\n\n*\nmul()\n\n\n/\ndivide()\n\n\n//\nfloordiv()\n\n\n%\nmod()\n\n\n**\npow()\n\n\n\n\n# 연산자 메소드1\n# midterm + final과 동일한 결과\nprint(midterm.add(final))\n\n         english   math  science\nAlice        NaN  180.0      NaN\nBob          NaN    NaN      NaN\nCharlie      NaN  166.0      NaN\nDavid        NaN    NaN      NaN\n\n\n\n# 연산자 메소드2\n# 하나의 데이터프레임에만 값이 있는 경우 0으로 처리하고, 둘 다 값이 없으면 NaN 반환\nprint(midterm.add(final, fill_value = 0))\n\n         english   math  science\nAlice       95.0  180.0     88.0\nBob          NaN   90.0     92.0\nCharlie     80.0  166.0     79.0\nDavid       88.0   82.0      NaN\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nassign()\n기존 데이터프레임을 수정하지 않고, 새로운 열을 추가한 복사본을 반환\n\n\neval()\n수식을 문자열로 작성하여 열 간 계산을 간결하게 수행(직관적인 수식 표현)\n\n\nwhere()\n조건에 따라 서로 다른 값을 선택하여 새로운 열 생성(NumPy 메소드)\n\n\n\n\ndf = pd.DataFrame({\n    'product': ['A', 'B', 'C', 'D', 'E'],\n    'price': [100, 200, 150, 300, 250],\n    'quantity': [10, 5, 3, 7, 6]\n})\nprint(df)\n\n  product  price  quantity\n0       A    100        10\n1       B    200         5\n2       C    150         3\n3       D    300         7\n4       E    250         6\n\n\n\n# 새로운 열 생성1: 기본 할당\n# 기본 할당은 데이터를 직접 수정하므로, 권장하지 않음\ndf['total_price'] = df['price'] * df['quantity']\nprint(df)\n\n  product  price  quantity  total_price\n0       A    100        10         1000\n1       B    200         5         1000\n2       C    150         3          450\n3       D    300         7         2100\n4       E    250         6         1500\n\n\n\n# 새로운 열 생성2: assign() 사용\nprint(df.assign(total_price = df['price'] * df['quantity']))\n\n  product  price  quantity  total_price\n0       A    100        10         1000\n1       B    200         5         1000\n2       C    150         3          450\n3       D    300         7         2100\n4       E    250         6         1500\n\n\n\n# 새로운 열 생성3: eval() 사용\n# inplace=True: 기존 데이터프레임에 직접 적용(새 객체를 반환하지 않음)\ndf.eval('total_price = price * quantity', inplace=True)\nprint(df)\n\n  product  price  quantity  total_price\n0       A    100        10         1000\n1       B    200         5         1000\n2       C    150         3          450\n3       D    300         7         2100\n4       E    250         6         1500\n\n\n\n# 새로운 열 생성4: where() 사용\n# 가격이 200 이상이면 'Expensive', 아니면 'Affordable'로 구분\ndf['price_category'] = np.where(df['price'] &gt;= 200, 'Expensive', 'Affordable')\nprint(df)\n\n  product  price  quantity  total_price price_category\n0       A    100        10         1000     Affordable\n1       B    200         5         1000      Expensive\n2       C    150         3          450     Affordable\n3       D    300         7         2100      Expensive\n4       E    250         6         1500      Expensive\n\n\n\n\n\n\n\nNumPy와 동일한 축 개념 사용\n\naxis 0 : 행 방향 연산(열 단위로 요약)\naxis 1 : 열 방향 연산(행 단위로 요약)\n\n수치형 데이터에 적용되며, NaN은 기본적으로 제외됨\n\n\n\n\n함수\n설명\n\n\n\n\ncount()\nNaN를 제외한 행의 개수\n\n\nvalue_counts()\n집단별 빈도\n\n\nsum()\n합계\n\n\nmean()\n평균\n\n\nstd()\n표준편차\n\n\nmedian()\n중앙값\n\n\nmin(), max()\n최소값, 최대값\n\n\ncumsum(), cumprod()\n누적 합계, 누적 곱\n\n\n\n\n## 실습 데이터 : tips 데이터셋\nimport seaborn as sns\ntips = sns.load_dataset('tips')\n\n\n# total_bill: 식사 금액\n# tip: 팁 금액\n# sex: 성별\n# smoker: 흡연 여부\n# day: 요일\n# time: 식사 시간(Lunch, Dinner)\n# size: 식사 인원 수\nprint(tips.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 244 entries, 0 to 243\nData columns (total 7 columns):\n #   Column      Non-Null Count  Dtype   \n---  ------      --------------  -----   \n 0   total_bill  244 non-null    float64 \n 1   tip         244 non-null    float64 \n 2   sex         244 non-null    category\n 3   smoker      244 non-null    category\n 4   day         244 non-null    category\n 5   time        244 non-null    category\n 6   size        244 non-null    int64   \ndtypes: category(4), float64(2), int64(1)\nmemory usage: 7.4 KB\nNone\n\n\n\nprint(tips.head())\n\n   total_bill   tip     sex smoker  day    time  size\n0       16.99  1.01  Female     No  Sun  Dinner     2\n1       10.34  1.66    Male     No  Sun  Dinner     3\n2       21.01  3.50    Male     No  Sun  Dinner     3\n3       23.68  3.31    Male     No  Sun  Dinner     2\n4       24.59  3.61  Female     No  Sun  Dinner     4\n\n\n\nprint(tips.describe())\n\n       total_bill         tip        size\ncount  244.000000  244.000000  244.000000\nmean    19.785943    2.998279    2.569672\nstd      8.902412    1.383638    0.951100\nmin      3.070000    1.000000    1.000000\n25%     13.347500    2.000000    2.000000\n50%     17.795000    2.900000    2.000000\n75%     24.127500    3.562500    3.000000\nmax     50.810000   10.000000    6.000000\n\n\n\n# 각 열의 유효한 데이터 수 (NaN 제외)\nprint(tips.count())\n\ntotal_bill    244\ntip           244\nsex           244\nsmoker        244\nday           244\ntime          244\nsize          244\ndtype: int64\n\n\n\n# 식사 시간별 주문 수\nprint(tips.value_counts('time'))\n\ntime\nDinner    176\nLunch      68\nName: count, dtype: int64\n\n\n\n# 전체(합계) 식사 금액, 팁 금액, 식사 인원 수\nprint(tips[['total_bill', 'tip', 'size']].sum())\n\ntotal_bill    4827.77\ntip            731.58\nsize           627.00\ndtype: float64\n\n\n\n# 고객 1인당 평균 식사 금액\nprint((tips['total_bill'] / tips['size']).mean())\n\n7.888229508196722\n\n\n\n# 고객 1인당 평균 팁 금액\nprint((tips['tip'] / tips['size']).mean())\n\n1.2127616120218578\n\n\n\n# 전체 식사 금액에서 팁이 차지하는 비율\nprint(tips['tip'] / tips['total_bill'])\n\n0      0.059447\n1      0.160542\n2      0.166587\n3      0.139780\n4      0.146808\n         ...   \n239    0.203927\n240    0.073584\n241    0.088222\n242    0.098204\n243    0.159744\nLength: 244, dtype: float64\n\n\n\n# 전체 식사 금액에서 팁이 차지하는 비율에 대한 요약 통계량\nprint((tips['tip'] / tips['total_bill']).describe())\n\ncount    244.000000\nmean       0.160803\nstd        0.061072\nmin        0.035638\n25%        0.129127\n50%        0.154770\n75%        0.191475\nmax        0.710345\ndtype: float64\n\n\n\n# 전체 식사 금액에서 팁이 차지하는 비율이 50% 이상인 경우\nprint(tips[tips['tip'] / tips['total_bill'] &gt;= 0.5])\n\n     total_bill   tip   sex smoker  day    time  size\n172        7.25  5.15  Male    Yes  Sun  Dinner     2\n\n\n\n\n\n\n\n\n\n\ngroupby() 함수를 이용하여 특정 열을 기준으로 데이터를 집단화한 후, 다양한 연산 수행 가능\nSQL의 GROUP BY와 유사한 기능을 제공하며, 집계, 변환, 필터링을 지원\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\naggregate() 또는 agg()\n여러 집계 함수를 동시에 적용(문자열, 함수, 리스트 등 가능)\n\n\nfilter()\n집단별 집계 결과를 조건으로 집단 자체를 필터링\n\n\ntransform()\n집단별 연산 결과를 원래 구조와 같은 형태로 반환(원소 개수 유지)\n\n\napply()\n임의의 함수를 전체 집단에 유연하게 적용(집계, 반환 모두 가능)\n\n\n\n\n#  실습 데이터 : tips 데이터셋\ntips = sns.load_dataset('tips')\n\n\n# 요일별 평균 식사 금액\n# observed=False: 모든 범주 포함, 실제 데이터가 없으면 NaN\nprint(tips.groupby('day', observed=False)['total_bill'].mean())\n\nday\nThur    17.682742\nFri     17.151579\nSat     20.441379\nSun     21.410000\nName: total_bill, dtype: float64\n\n\n\n# 식사 시간별 식사 금액, 팁 금액의 평균 및 표준편차\nprint(tips.groupby('time', observed=False)[['total_bill', 'tip']].agg(['mean', 'std']))\n\n       total_bill                 tip          \n             mean       std      mean       std\ntime                                           \nLunch   17.168676  7.713882  2.728088  1.205345\nDinner  20.797159  9.142029  3.102670  1.436243\n\n\n\n# 식사 시간별 식사 금액의 최대값, 팁 금액의 최소값: 딕셔너리 사용\nprint(tips.groupby('time', observed=False).agg({'total_bill': 'max', 'tip': 'min'}).reset_index())\n\n     time  total_bill   tip\n0   Lunch       43.11  1.25\n1  Dinner       50.81  1.00\n\n\n\n# 식사 시간별 식사 금액의 최대값, 팁 금액의 최소값: 튜플 사용, named aggregation 문법\nprint(tips.groupby('time', observed=False).agg(total_bill_max = ('total_bill', 'max'), tip_min = ('tip', 'min')).reset_index())\n\n     time  total_bill_max  tip_min\n0   Lunch           43.11     1.25\n1  Dinner           50.81     1.00\n\n\n\n\n[참고] 람다 함수(lamdba function)\n\n함수 이름 없이 일시적으로 정의해 사용할 수 있는 익명 함수\ndef, return 없이 간단한 함수 로직을 한 줄로 표현\n구조는 일반 함수와 같지만, 주로 짧고 단순한 연산에 사용\napply(), filter() 등 함수의 인수로 전달할 때 유용하게 활용\n\n\n\n# 함수 정의\ndef f(x, y):\n    return x + y\nf(1, 4)\n\n5\n\n\n\n# 람다 함수\n(lambda x, y: x + y)(1, 4)\n\n5\n\n\n\n# 팀 금액 평균이 3달러 이상인 요일 데이터 필터링: 함수 정의\ndef filter_tip_avg(x):\n    return x['tip'].mean() &gt;= 3\n\nprint(tips.groupby('day', observed=False).filter(filter_tip_avg))\n\n     total_bill   tip     sex smoker  day    time  size\n0         16.99  1.01  Female     No  Sun  Dinner     2\n1         10.34  1.66    Male     No  Sun  Dinner     3\n2         21.01  3.50    Male     No  Sun  Dinner     3\n3         23.68  3.31    Male     No  Sun  Dinner     2\n4         24.59  3.61  Female     No  Sun  Dinner     4\n..          ...   ...     ...    ...  ...     ...   ...\n186       20.90  3.50  Female    Yes  Sun  Dinner     3\n187       30.46  2.00    Male    Yes  Sun  Dinner     5\n188       18.15  3.50  Female    Yes  Sun  Dinner     3\n189       23.10  4.00    Male    Yes  Sun  Dinner     3\n190       15.69  1.50    Male    Yes  Sun  Dinner     2\n\n[76 rows x 7 columns]\n\n\n\n# 팀 금액 평균이 3달러 이상인 요일 데이터 필터링: 람다 함수 사용\nprint(tips.groupby('day', observed=False).filter(lambda x: x['tip'].mean() &gt;= 3))\n\n     total_bill   tip     sex smoker  day    time  size\n0         16.99  1.01  Female     No  Sun  Dinner     2\n1         10.34  1.66    Male     No  Sun  Dinner     3\n2         21.01  3.50    Male     No  Sun  Dinner     3\n3         23.68  3.31    Male     No  Sun  Dinner     2\n4         24.59  3.61  Female     No  Sun  Dinner     4\n..          ...   ...     ...    ...  ...     ...   ...\n186       20.90  3.50  Female    Yes  Sun  Dinner     3\n187       30.46  2.00    Male    Yes  Sun  Dinner     5\n188       18.15  3.50  Female    Yes  Sun  Dinner     3\n189       23.10  4.00    Male    Yes  Sun  Dinner     3\n190       15.69  1.50    Male    Yes  Sun  Dinner     2\n\n[76 rows x 7 columns]\n\n\n\n# 성별 팁 금액의 편차\ntips['tip_dev'] = tips.groupby('sex', observed=False)['tip'].transform(lambda x: x - x.mean())\nprint(tips[['sex', 'tip', 'tip_dev']].head())\n\n      sex   tip   tip_dev\n0  Female  1.01 -1.823448\n1    Male  1.66 -1.429618\n2    Male  3.50  0.410382\n3    Male  3.31  0.220382\n4  Female  3.61  0.776552\n\n\n\n# 식사 시간별 팁 금액의 사분위수범위: 함수 정의\ndef iqr(x):\n    return x.quantile(0.75) - x.quantile(0.25)\n\nprint(tips.groupby('time', observed=False)['tip'].apply(iqr))\n\ntime\nLunch     1.2875\nDinner    1.6875\nName: tip, dtype: float64\n\n\n\n# 식사 시간별 팁 금액의 사분위수범위: 람다 함수 사용\nprint(tips.groupby('time', observed=False)['tip'].apply(lambda x: x.quantile(0.75) - x.quantile(0.25)))\n\ntime\nLunch     1.2875\nDinner    1.6875\nName: tip, dtype: float64\n\n\n\n\n\n\n\neval(), query() 메소드를 사용하면 문자열 형태의 표현식을 통해 데이터를 보다 직관적으로 처리 가능\n복잡한 연산이나 조건 필터링을 간결하게 표현할 수 있어 가독성과 성능 모두에 유리함\n\n데이터프레임의 열 이름을 따옴표 없이 사용 가능\n외부 변수는 @ 기호를 사용하여 표현식에 표현 가능\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\neval()\n- 문자열로 작성한 수식을 이용하여 기존 열을 연산하거나 새로운 열을 생성 - Python 표현식을 그대로 사용할 수 있어 가독성이 높음\n\n\nquery()\n- 문자열로 작성한 조건식을 이용하여 행을 필터링- 복잡한 불리언 인덱싱보다 간결하고 직관적인 문법 제공 - 논리 연산자는 &, \\|, ~의 사용을 권장하며, 각 조건은 괄호 ()로 감싸야 함\n\n\n\n\n#  실습 데이터 : tips 데이터셋\ntips = sns.load_dataset('tips')\n\n\n# 기존 열 연산: 식사 금액에서 세금 10%를 제외한 실수령 금액\nprint(tips.eval('total_bill = total_bill * 0.9'))\n\n     total_bill   tip     sex smoker   day    time  size\n0        15.291  1.01  Female     No   Sun  Dinner     2\n1         9.306  1.66    Male     No   Sun  Dinner     3\n2        18.909  3.50    Male     No   Sun  Dinner     3\n3        21.312  3.31    Male     No   Sun  Dinner     2\n4        22.131  3.61  Female     No   Sun  Dinner     4\n..          ...   ...     ...    ...   ...     ...   ...\n239      26.127  5.92    Male     No   Sat  Dinner     3\n240      24.462  2.00  Female    Yes   Sat  Dinner     2\n241      20.403  2.00    Male    Yes   Sat  Dinner     2\n242      16.038  1.75    Male     No   Sat  Dinner     2\n243      16.902  3.00  Female     No  Thur  Dinner     2\n\n[244 rows x 7 columns]\n\n\n\n# 새로운 열 생성: 전체 식사 금액 대비 팁 금액 비율\n# inplace=True: 기존 데이터프레임에 직접 적용(새 객체를 반환하지 않음)\ntips.eval('tip_rate = tip / total_bill', inplace=True)\nprint(tips)\n\n     total_bill   tip     sex smoker   day    time  size  tip_rate\n0         16.99  1.01  Female     No   Sun  Dinner     2  0.059447\n1         10.34  1.66    Male     No   Sun  Dinner     3  0.160542\n2         21.01  3.50    Male     No   Sun  Dinner     3  0.166587\n3         23.68  3.31    Male     No   Sun  Dinner     2  0.139780\n4         24.59  3.61  Female     No   Sun  Dinner     4  0.146808\n..          ...   ...     ...    ...   ...     ...   ...       ...\n239       29.03  5.92    Male     No   Sat  Dinner     3  0.203927\n240       27.18  2.00  Female    Yes   Sat  Dinner     2  0.073584\n241       22.67  2.00    Male    Yes   Sat  Dinner     2  0.088222\n242       17.82  1.75    Male     No   Sat  Dinner     2  0.098204\n243       18.78  3.00  Female     No  Thur  Dinner     2  0.159744\n\n[244 rows x 8 columns]\n\n\n\n# 외부 변수 사용: 전체 식사 금액에 따른 기본(최소) 팁 금액\ntip_percentage = 0.15\ntips.eval('min_tip = total_bill * @tip_percentage', inplace = True)\nprint(tips)\n\n     total_bill   tip     sex smoker   day    time  size  tip_rate  min_tip\n0         16.99  1.01  Female     No   Sun  Dinner     2  0.059447   2.5485\n1         10.34  1.66    Male     No   Sun  Dinner     3  0.160542   1.5510\n2         21.01  3.50    Male     No   Sun  Dinner     3  0.166587   3.1515\n3         23.68  3.31    Male     No   Sun  Dinner     2  0.139780   3.5520\n4         24.59  3.61  Female     No   Sun  Dinner     4  0.146808   3.6885\n..          ...   ...     ...    ...   ...     ...   ...       ...      ...\n239       29.03  5.92    Male     No   Sat  Dinner     3  0.203927   4.3545\n240       27.18  2.00  Female    Yes   Sat  Dinner     2  0.073584   4.0770\n241       22.67  2.00    Male    Yes   Sat  Dinner     2  0.088222   3.4005\n242       17.82  1.75    Male     No   Sat  Dinner     2  0.098204   2.6730\n243       18.78  3.00  Female     No  Thur  Dinner     2  0.159744   2.8170\n\n[244 rows x 9 columns]\n\n\n\n# 기본(최소) 팁 금액보다 적게 준 경우 'Below', 많거나 같은 경우 'Above'로 구분\n# 기본(최소) 팁 금액보다 적게 준 경우는 108팀임\ntips['tip_group'] = np.where(tips['tip'] &lt; tips['min_tip'], 'Below', 'Above')\nprint(tips['tip_group'].value_counts())\n\ntip_group\nAbove    136\nBelow    108\nName: count, dtype: int64\n\n\n\n# 단일 조건 필터링: 식사 금액이 20달러 이상인 경우\nprint(tips.query('total_bill &gt;= 20'))\n\n     total_bill   tip     sex smoker  day    time  size  tip_rate  min_tip  \\\n2         21.01  3.50    Male     No  Sun  Dinner     3  0.166587   3.1515   \n3         23.68  3.31    Male     No  Sun  Dinner     2  0.139780   3.5520   \n4         24.59  3.61  Female     No  Sun  Dinner     4  0.146808   3.6885   \n5         25.29  4.71    Male     No  Sun  Dinner     4  0.186240   3.7935   \n7         26.88  3.12    Male     No  Sun  Dinner     4  0.116071   4.0320   \n..          ...   ...     ...    ...  ...     ...   ...       ...      ...   \n237       32.83  1.17    Male    Yes  Sat  Dinner     2  0.035638   4.9245   \n238       35.83  4.67  Female     No  Sat  Dinner     3  0.130338   5.3745   \n239       29.03  5.92    Male     No  Sat  Dinner     3  0.203927   4.3545   \n240       27.18  2.00  Female    Yes  Sat  Dinner     2  0.073584   4.0770   \n241       22.67  2.00    Male    Yes  Sat  Dinner     2  0.088222   3.4005   \n\n    tip_group  \n2       Above  \n3       Below  \n4       Below  \n5       Above  \n7       Below  \n..        ...  \n237     Below  \n238     Below  \n239     Above  \n240     Below  \n241     Below  \n\n[97 rows x 10 columns]\n\n\n\n# 다중 조건 필터링: 식사 인원 수가 3명 이상이고, 목요일에 방문한 경우\n#print(tips.query('size &gt;= 3 and day == \"Thur\"'))           # 권장하지 않음, 조건이 복잡할 경우 오류가 발생할 수 있음\nprint(tips.query('(size &gt;= 3) & (day == \"Thur\")'))          # 권장 방식: 괄호로 각 조건을 명확히 구분\n\n     total_bill   tip     sex smoker   day   time  size  tip_rate  min_tip  \\\n77        27.20  4.00    Male     No  Thur  Lunch     4  0.147059   4.0800   \n85        34.83  5.17  Female     No  Thur  Lunch     4  0.148435   5.2245   \n119       24.08  2.92  Female     No  Thur  Lunch     4  0.121262   3.6120   \n125       29.80  4.20  Female     No  Thur  Lunch     6  0.140940   4.4700   \n129       22.82  2.18    Male     No  Thur  Lunch     3  0.095530   3.4230   \n141       34.30  6.70    Male     No  Thur  Lunch     6  0.195335   5.1450   \n142       41.19  5.00    Male     No  Thur  Lunch     5  0.121389   6.1785   \n143       27.05  5.00  Female     No  Thur  Lunch     6  0.184843   4.0575   \n146       18.64  1.36  Female     No  Thur  Lunch     3  0.072961   2.7960   \n197       43.11  5.00  Female    Yes  Thur  Lunch     4  0.115982   6.4665   \n200       18.71  4.00    Male    Yes  Thur  Lunch     3  0.213789   2.8065   \n204       20.53  4.00    Male    Yes  Thur  Lunch     4  0.194837   3.0795   \n205       16.47  3.23  Female    Yes  Thur  Lunch     3  0.196114   2.4705   \n\n    tip_group  \n77      Below  \n85      Below  \n119     Below  \n125     Below  \n129     Below  \n141     Above  \n142     Below  \n143     Above  \n146     Below  \n197     Below  \n200     Above  \n204     Above  \n205     Above  \n\n\n\n# 외부 변수 사용: 기준 팁 금액 미만인 경우\nmin_tip_required = 5\nprint(tips.query('tip &lt; @min_tip_required'))\n\n     total_bill   tip     sex smoker   day    time  size  tip_rate  min_tip  \\\n0         16.99  1.01  Female     No   Sun  Dinner     2  0.059447   2.5485   \n1         10.34  1.66    Male     No   Sun  Dinner     3  0.160542   1.5510   \n2         21.01  3.50    Male     No   Sun  Dinner     3  0.166587   3.1515   \n3         23.68  3.31    Male     No   Sun  Dinner     2  0.139780   3.5520   \n4         24.59  3.61  Female     No   Sun  Dinner     4  0.146808   3.6885   \n..          ...   ...     ...    ...   ...     ...   ...       ...      ...   \n238       35.83  4.67  Female     No   Sat  Dinner     3  0.130338   5.3745   \n240       27.18  2.00  Female    Yes   Sat  Dinner     2  0.073584   4.0770   \n241       22.67  2.00    Male    Yes   Sat  Dinner     2  0.088222   3.4005   \n242       17.82  1.75    Male     No   Sat  Dinner     2  0.098204   2.6730   \n243       18.78  3.00  Female     No  Thur  Dinner     2  0.159744   2.8170   \n\n    tip_group  \n0       Below  \n1       Above  \n2       Above  \n3       Below  \n4       Below  \n..        ...  \n238     Below  \n240     Below  \n241     Below  \n242     Below  \n243     Above  \n\n[216 rows x 10 columns]\n\n\n\n# 기준 팁 금액보다 적게 준 경우는 216팀임\nprint(tips.query('tip &lt; @min_tip_required').shape[0])\nprint(len(tips.query('tip &lt; @min_tip_required')))\n\n216\n216\n\n\n\n\n\n\n\n\n\n\n일정한 시간 간격으로 관측된 연속적인 데이터\nPandas에서는 시계열 데이터를 처리하기 위한 다양한 날짜/시간 관련 객체를 제공함\n\n\n\n\n\n\n\n\n\n\n구분\n설명\n예\nPandas 객체\n\n\n\n\n타임스탬프(timestampe)\n특정 시점\n2025-03-02 09:00\npd.TimeStamp, DatetimeIndex\n\n\n시간 기간(period)\n일정한 시간 구간(시작~종료)\n2025년 3월 (월간)\npd.Period, PeriodIndex\n\n\n시간 델타(time delta)\n두 시점 사이의 시간 간격\n2일, 5시간\npd.Timedelta, TimedeltaIndex\n\n\n\n\nprint(pd.Timestamp('2025-03-02 09:00'))      # 타임스탬프\nprint(pd.Period('2025-03', freq='M'))        # 시간 기간\nprint(pd.Timedelta(days=2, hours=5))         # 시간 델타\n\n2025-03-02 09:00:00\n2025-03\n2 days 05:00:00\n\n\n\n\n\n\n\npd.to_datetime() 함수\n\n문자열이나 정수 등 다양한 형태의 데이터를 시계열 데이터(datetime 형식)로 변환\nformat 인자를 사용하여 날짜 형식을 명시적으로 지정 가능\nerrors='coerce' 인자를 사용하면 오류 발생 시 NaT(Not a Time)으로 처리\n시계열 인덱스를 설정하거나 변환할 때도 자주 사용됨\n\n\n\n\n\n코드\n설명\n예\n\n\n\n\n%Y\n전체 연도\n2025\n\n\n%B\n전체 월 이름\nMarch\n\n\n%m\n0으로 시작하는 월\n03\n\n\n%d\n0으로 시작하는 일\n02\n\n\n%H\n0으로 시작하는 시간(24시간제)\n14\n\n\n%I\n0으로 시작하는 시간(12시간제)\n09\n\n\n%p\nAM 또는 PM\nAM\n\n\n%M\n0으로 시작하는 분\n00\n\n\n%S\n0으로 시작하는 초\n00\n\n\n\n\n# Timestampe1: 문자열 리스트 사용\npd.to_datetime(['2025-03-02', '2025-03-03', '2025-03-04'])\n\nDatetimeIndex(['2025-03-02', '2025-03-03', '2025-03-04'], dtype='datetime64[ns]', freq=None)\n\n\n\n# Timestampe2: 명시적 형식 지정\npd.to_datetime(['March 2, 2025', 'March 3, 2025', 'March 4, 2025'], format='%B %d, %Y')\n\nDatetimeIndex(['2025-03-02', '2025-03-03', '2025-03-04'], dtype='datetime64[ns]', freq=None)\n\n\n\n# Timestampe3: 오류 발생 시 NaT 처리\npd.to_datetime([\"2025-03-02\", \"not a date\"], errors=\"coerce\")\n\nDatetimeIndex(['2025-03-02', 'NaT'], dtype='datetime64[ns]', freq=None)\n\n\n\n# Timestampe4: 정수 데이터프레임 사용(각 행을 날짜로 변환)\ndf = pd.DataFrame({\n    \"year\": [2025, 2025],\n    \"month\": [3, 4],\n    \"day\": [2, 15]\n})\npd.to_datetime(df)\n\n0   2025-03-02\n1   2025-04-15\ndtype: datetime64[ns]\n\n\n\n# Period: 2025년 3월 1일 ~ 31일(한 달)\npd.to_datetime('2025-03', format='%Y-%m').to_period('M')\n\nPeriod('2025-03', 'M')\n\n\n\n# Timedelta\npd.to_datetime('2025-05-13') - pd.to_datetime('2025-03-02')\n\nTimedelta('72 days 00:00:00')\n\n\n\n\n정규 날짜 시퀀스 생성\n\nPandas는 일정 간격의 날짜/시간 데이터를 생성하는 기능을 제공함\npd.date_range(), pd.period_range(), pd.timedelta_range() 함수\n\nfreq 인자를 통해 날짜 간격의 빈도(frequency) 지정 가능\n\n\n\n\n\n\n코드\n설명\n\n\n\n\nD\n일(day)\n\n\nW\n주(week)\n\n\nME\n월말(month end)\n\n\nQE\n분기말(quarer end)\n\n\nYE\n연말(year end)\n\n\nh\n시간(hour)\n\n\nmin\n분(minute)\n\n\ns\n초(second)\n\n\n\n\n# pd.date_range(): 하루씩 증가하는 날짜 시퀀스\npd.date_range('2025-03-02', periods=5, freq='D')\n\nDatetimeIndex(['2025-03-02', '2025-03-03', '2025-03-04', '2025-03-05',\n               '2025-03-06'],\n              dtype='datetime64[ns]', freq='D')\n\n\n\n# pd.date_range(): 일주일씩 증가하는 날짜 시퀀스(일요일 기준)\npd.date_range('2025-05-13', periods=5, freq='W')\n\nDatetimeIndex(['2025-05-18', '2025-05-25', '2025-06-01', '2025-06-08',\n               '2025-06-15'],\n              dtype='datetime64[ns]', freq='W-SUN')\n\n\n\n# pd.period_range(): 2025년 3월부터 시작하여 3개월 동안의 기간\npd.period_range('2025-03', periods=3, freq='M')\n\nPeriodIndex(['2025-03', '2025-04', '2025-05'], dtype='period[M]')\n\n\n\n# pd.timedelta_range(): 1시간 간격의 시간 델타 시퀀스\npd.timedelta_range(start='0s', periods=5, freq='h')\n\nTimedeltaIndex(['0 days 00:00:00', '0 days 01:00:00', '0 days 02:00:00',\n                '0 days 03:00:00', '0 days 04:00:00'],\n               dtype='timedelta64[ns]', freq='h')\n\n\n\n\n\n\n\n시계열 데이터를 인덱스로 설정하면, 시간 기반으로 데이터를 쉽게 필터링할 수 있음\n\n문자열 형태의 날짜를 인덱스 슬라이싱에 사용 가능\n예 : 연도(‘2025’), 연월(‘2025-01’), 연월일(‘2025-01-07’) 등\n\nDatetimeIndex 객체는 다음과 같은 속성을 제공\n\n.year, .month, .day, .hour, .minute, .second\n.month_name(), .day_name(), .dayofweek(0=월요일)\n\nsort_index() 메소드를 통해 날짜 인덱스를 기준으로 정렬 가능\n\n\n# 시계열 데이터 인덱스 설정\ndate_rng = pd.date_range(start='2024-12-20', end='2025-01-10', freq='D')\ndf = pd.DataFrame({'value': np.random.randint(0, 100, size=len(date_rng))}, index=date_rng)\nprint(df)\n\n            value\n2024-12-20     93\n2024-12-21     67\n2024-12-22     67\n2024-12-23     94\n2024-12-24     29\n2024-12-25     60\n2024-12-26     66\n2024-12-27     71\n2024-12-28     43\n2024-12-29     54\n2024-12-30     99\n2024-12-31     73\n2025-01-01     82\n2025-01-02     63\n2025-01-03      1\n2025-01-04     95\n2025-01-05      1\n2025-01-06      6\n2025-01-07     73\n2025-01-08     52\n2025-01-09     42\n2025-01-10     35\n\n\n\n# 날짜 기반 필터링1: 특정 연도 데이터\nprint(df.loc['2025'])\n\n            value\n2025-01-01     82\n2025-01-02     63\n2025-01-03      1\n2025-01-04     95\n2025-01-05      1\n2025-01-06      6\n2025-01-07     73\n2025-01-08     52\n2025-01-09     42\n2025-01-10     35\n\n\n\n# 날짜 기반 필터링2: 특정 날짜 이후 데이터\nprint(df.loc['2025-01-07':])\n\n            value\n2025-01-07     73\n2025-01-08     52\n2025-01-09     42\n2025-01-10     35\n\n\n\n# 날짜 기반 필터링2: 특정 날짜 범위 데이터\nprint(df.loc['2024-12-24':'2024-12-31'])\n\n            value\n2024-12-24     29\n2024-12-25     60\n2024-12-26     66\n2024-12-27     71\n2024-12-28     43\n2024-12-29     54\n2024-12-30     99\n2024-12-31     73\n\n\n\n# DatetimeIndex 속성1: 월(month)\nprint(df.index.month)\n\nIndex([12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1],\n      dtype='int32')\n\n\n\n# DatetimeIndex 속성2: 요일 이름\nprint(df.index.day_name())\n\nIndex(['Friday', 'Saturday', 'Sunday', 'Monday', 'Tuesday', 'Wednesday',\n       'Thursday', 'Friday', 'Saturday', 'Sunday', 'Monday', 'Tuesday',\n       'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', 'Monday',\n       'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n      dtype='object')\n\n\n\n# 날짜 인덱스 정렬: 내림차순\nprint(df.sort_index(ascending=False))\n\n            value\n2025-01-10     35\n2025-01-09     42\n2025-01-08     52\n2025-01-07     73\n2025-01-06      6\n2025-01-05      1\n2025-01-04     95\n2025-01-03      1\n2025-01-02     63\n2025-01-01     82\n2024-12-31     73\n2024-12-30     99\n2024-12-29     54\n2024-12-28     43\n2024-12-27     71\n2024-12-26     66\n2024-12-25     60\n2024-12-24     29\n2024-12-23     94\n2024-12-22     67\n2024-12-21     67\n2024-12-20     93\n\n\n\n\n\n\n\n리샘플링(resampling) : 시계열 데이터의 빈도를 변경하는 방법(예 : 월별 데이터 → 연간 데이터)\n시간 이동(time-shift) : 시계열 데이터를 시간 축을 기준으로 이동시키는 방법으로, 이전 시점의 데이터와 비교할 때 유용함\n롤링 윈도우(rolling windows): 일정한 기간을 기준으로 이동 평균 등을 방법으로, 주기적인 변동성을 관할할 때 유용함\n\n\n## 실습 데이터 : flights 데이터셋\nflights = sns.load_dataset(\"flights\")\n\n\nprint(flights.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 144 entries, 0 to 143\nData columns (total 3 columns):\n #   Column      Non-Null Count  Dtype   \n---  ------      --------------  -----   \n 0   year        144 non-null    int64   \n 1   month       144 non-null    category\n 2   passengers  144 non-null    int64   \ndtypes: category(1), int64(2)\nmemory usage: 2.9 KB\nNone\n\n\n\nprint(flights.head())\n\n   year month  passengers\n0  1949   Jan         112\n1  1949   Feb         118\n2  1949   Mar         132\n3  1949   Apr         129\n4  1949   May         121\n\n\n\n# 시계열 데이터 인덱스 설정\nflights['date'] = pd.to_datetime(flights['year'].astype(str) + '-' + flights['month'].astype(str), format='%Y-%b')\nflights.set_index('date', inplace=True)\nflights.drop(['year', 'month'], axis=1, inplace=True)\nprint(flights.head())\n\n            passengers\ndate                  \n1949-01-01         112\n1949-02-01         118\n1949-03-01         132\n1949-04-01         129\n1949-05-01         121\n\n\n\n# 리샘플링: 월별 데이터 → 연간 데이터(연도별 총합)\nannual_passengers = flights.resample('YE').sum()\nprint(annual_passengers)\n\n            passengers\ndate                  \n1949-12-31        1520\n1950-12-31        1676\n1951-12-31        2042\n1952-12-31        2364\n1953-12-31        2700\n1954-12-31        2867\n1955-12-31        3408\n1956-12-31        3939\n1957-12-31        4421\n1958-12-31        4572\n1959-12-31        5140\n1960-12-31        5714\n\n\n\nimport matplotlib.pyplot as plt\n\n\n# 리샘플링: 연간 데이터 시각화\nplt.figure(figsize=(5, 3))\nplt.plot(annual_passengers['passengers'])\nplt.title('Annual Total Passengers')\nplt.xlabel('Year')\nplt.ylabel('Number of Passengers')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n# 시간 이동: 직전 분기 대비 승객 수 증감률(%)\nquarterly = flights['passengers'].resample('QE').sum()\nprevious_quarter = quarterly.shift(1)\nchange_rate = (quarterly - previous_quarter) / previous_quarter * 100\n\nquarterly_df = pd.DataFrame({\n    'quarterly_passengers': quarterly,\n    'change_rate': change_rate\n})\nprint(quarterly_df)\n\n            quarterly_passengers  change_rate\ndate                                         \n1949-03-31                   362          NaN\n1949-06-30                   385     6.353591\n1949-09-30                   432    12.207792\n1949-12-31                   341   -21.064815\n1950-03-31                   382    12.023460\n1950-06-30                   409     7.068063\n1950-09-30                   498    21.760391\n1950-12-31                   387   -22.289157\n1951-03-31                   473    22.222222\n1951-06-30                   513     8.456660\n1951-09-30                   582    13.450292\n1951-12-31                   474   -18.556701\n1952-03-31                   544    14.767932\n1952-06-30                   582     6.985294\n1952-09-30                   681    17.010309\n1952-12-31                   557   -18.208517\n1953-03-31                   628    12.746858\n1953-06-30                   707    12.579618\n1953-09-30                   773     9.335219\n1953-12-31                   592   -23.415265\n1954-03-31                   627     5.912162\n1954-06-30                   725    15.629984\n1954-09-30                   854    17.793103\n1954-12-31                   661   -22.599532\n1955-03-31                   742    12.254160\n1955-06-30                   854    15.094340\n1955-09-30                  1023    19.789227\n1955-12-31                   789   -22.873900\n1956-03-31                   878    11.280101\n1956-06-30                  1005    14.464692\n1956-09-30                  1173    16.716418\n1956-12-31                   883   -24.722933\n1957-03-31                   972    10.079275\n1957-06-30                  1125    15.740741\n1957-09-30                  1336    18.755556\n1957-12-31                   988   -26.047904\n1958-03-31                  1020     3.238866\n1958-06-30                  1146    12.352941\n1958-09-30                  1400    22.164049\n1958-12-31                  1006   -28.142857\n1959-03-31                  1108    10.139165\n1959-06-30                  1288    16.245487\n1959-09-30                  1570    21.894410\n1959-12-31                  1174   -25.222930\n1960-03-31                  1227     4.514480\n1960-06-30                  1468    19.641402\n1960-09-30                  1736    18.256131\n1960-12-31                  1283   -26.094470\n\n\n\n# 시프팅: 직전 분기 대비 승객 수 증감률(%) 시각화\nplt.figure(figsize=(5, 3))\nplt.plot(quarterly_df['change_rate'])\nplt.title('Quarter-over-Quarter Change in Airline Passengers (%)')\nplt.xlabel('Quarter')\nplt.ylabel('Change Rate (%)')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n# 롤링 윈도우: 12개월 단순이동평균\nflights['moving_avg_12months'] = flights['passengers'].rolling(window=12).mean()\nprint(flights)\n\n            passengers  moving_avg_12months\ndate                                       \n1949-01-01         112                  NaN\n1949-02-01         118                  NaN\n1949-03-01         132                  NaN\n1949-04-01         129                  NaN\n1949-05-01         121                  NaN\n...                ...                  ...\n1960-08-01         606           463.333333\n1960-09-01         508           467.083333\n1960-10-01         461           471.583333\n1960-11-01         390           473.916667\n1960-12-01         432           476.166667\n\n[144 rows x 2 columns]\n\n\n\n# 롤링 윈도우: 12개월 단순이동평균 시각화\nplt.figure(figsize=(5, 3))\nplt.plot(flights['passengers'], label='Original Data')\nplt.plot(flights['moving_avg_12months'], label='12-Month Moving Average', color='orange')\nplt.title('Airline Passenger Trend with 12-Month Moving Average')\nplt.xlabel('Date')\nplt.ylabel('Number of Passengers')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n(과제) 시계열 데이터 처리 실습\n\nair_quality_no2_long.csv 데이터셋은 Pandas 공식 문서에서 제공하는 유럽 도시 대기 중 이산화질소(NO2) 농도 측정 자료이다.\n\n문제1. 날짜 정보(date.utc) 열을 datetime 형식으로 변환하고, 이를 인덱스로 설정하라.\n문제2. 2019년 5월에 속하는 데이터 중 월요일에 해당하는 데이터만 추출하라.\n문제3. 이산화질소 농도(value)의 주(week)별 최대값을 계산하라.\n\n\n\n\nyfinance 라이브러리를 통해 2023년 1월 1일부터 12월 31일까지의 Apple(AAPL) 일별 주가 데이터를 다운로드할 수 있다.\n\n문제4. 전일 종가(Close) 대비 당일 시가(Open)의 변동률이 3% 이상인 데이터를 추출하라.\n문제5. 종가(Close)에 대해 5일 이동평균과 10일 이동평균을 각각 계산한 후 시각화하라.\n\n\n\n# air_quality_no2_long.csv\nair = pd.read_csv(\"https://raw.githubusercontent.com/pandas-dev/pandas/main/doc/data/air_quality_no2_long.csv\")\n\n\n# 2023년 Apple 일별 주가 데이터\n# !pip install yfinance\n# import yfinance as yf\n# stock = yf.download(\"AAPL\", start=\"2023-01-01\", end=\"2023-12-31\")\n# stock.columns = stock.columns.droplevel(\"Ticker\")"
  },
  {
    "objectID": "4_2_pandas.html#pandas-라이브러리",
    "href": "4_2_pandas.html#pandas-라이브러리",
    "title": "4. 라이브러리",
    "section": "",
    "text": "Pandas\n\nNumPy를 기반으로 만들어진 데이터 분석용 라이브러리\n레이블(label)로 식별되는 데이터를 쉽게 다룰 수 있도록 지원\n고성능 데이터 조작, 탐색, 전처리, 변환, 요약, 통계 연산 기능 제공\n주요 객체로는 Series(1차원), DataFrame(2차원), Index(레이블 관리 구조)가 있음\n\n\n\n\n\n\n\n\n\n\n객체\n설명\n\n\n\n\nSeries\n- 1차원 레이블이 붙은 배열로, 각 데이터에 고유한 인덱스가 있음 - 모든 원소가 동일한 자료형으로 저장되며, 숫자, 문자열, bool 등 다양한 자료형을 지원\n\n\nDataFrame\n- 2차원 표 형태의 데이터 구조로, 행(row)과 열(column)로 구성됨 - 각 열은 Series로 구성되어 있으며, 각 열이 서로 다른 자료형을 가질 수 있음 - DataFrame은 정렬(같은 인덱스 공유)된 Series 객체의 연속으로 볼 수 있음\n\n\nIndex\n- 데이터에 레이블을 부여하는 객체로, 행 또는 열에 사용됨 - 데이터 정렬, 선택, 결합 등을 효율적으로 할 수 있도록 지원\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\npd.Series()\n1차원 Series 객체 생성\n\n\npd.DataFrame()\n2차원 DataFrame 객체 생성\n\n\npd.Index()\nIndex 객체 생성\n\n\n\n\nimport numpy as np\nimport pandas as pd\n\n\n# Series 생성1 : 리스트 사용\nsr = pd.Series([1, 2, 3, 4, 5])\nprint(sr)\n\n0    1\n1    2\n2    3\n3    4\n4    5\ndtype: int64\n\n\n\n# Series 생성2 : 넘파이 배열 사용\nsr = pd.Series(np.array([1, 2, 3, 4, 5]))\nprint(sr)\n\n0    1\n1    2\n2    3\n3    4\n4    5\ndtype: int32\n\n\n\n# Series 생성3 : 딕셔너리 사용\n# 딕셔너리 키는 인덱스로 자동 지정됨\nsr = pd.Series({'a': 10, 'b': 20, 'c': 30})\nprint(sr)\n\na    10\nb    20\nc    30\ndtype: int64\n\n\n\n# Series 생성4 : 인덱스 지정\nsr = pd.Series([1, 2, 3], index = ['a', 'b', 'c'])\nprint(sr)\n\na    1\nb    2\nc    3\ndtype: int64\n\n\n\n# DataFrame 생성1 : Series 사용\nsr = pd.Series([1, 2, 3], index = ['a', 'b', 'c'])\ndf = pd.DataFrame(sr, columns = ['value'])\nprint(df)\n\n   value\na      1\nb      2\nc      3\n\n\n\n# DataFrame 생성2 : 리스트 사용\nlst = [['Alice', 22], ['Bob', 20], ['Charlie', 27]]\ndf = pd.DataFrame(lst, columns=['Name', 'Age'])\nprint(df)\n\n      Name  Age\n0    Alice   22\n1      Bob   20\n2  Charlie   27\n\n\n\n# DataFrame 생성3 : 넘파이 배열 사용\narr = np.array([['Alice', 22], ['Bob', 20], ['Charlie', 27]])\ndf = pd.DataFrame(arr, columns=['Name', 'Age'])\nprint(df)\n\n      Name Age\n0    Alice  22\n1      Bob  20\n2  Charlie  27\n\n\n\n# DataFrame 생성4 : 딕셔너리 사용\n# 딕셔너리 키는 열 이름으로 자동 지정됨\ndct = {'Name': ['Alice', 'Bob', 'Charlie'], 'Age': [22, 20, 27]}\ndf = pd.DataFrame(dct)\nprint(df)\n\n      Name  Age\n0    Alice   22\n1      Bob   20\n2  Charlie   27\n\n\n\n# DataFrame 생성5 : 딕셔너리 + 리스트 컴프리헨션 사용\ndct = [{'a': i, 'b': 2*i} for i in range(3)]\ndf = pd.DataFrame(dct)\nprint(df)\n\n   a  b\n0  0  0\n1  1  2\n2  2  4\n\n\n\n# DataFrame 생성6 : Series 사용\n# 서로 다른 인덱스를 가진 Series로 DataFrame을 생성하면\n# 공통된 인덱스를 기준으로 맞춰지고, 누락된 값은 NaN(Not a Number)으로 채워짐\nsr1 = pd.Series([1, 2, 3], index = ['a', 'b', 'c'])\nsr2 = pd.Series([4, 5, 6], index = ['a', 'c', 'd'])\ndf = pd.DataFrame({'x': sr1, 'y': sr2})\nprint(df)\n\n     x    y\na  1.0  4.0\nb  2.0  NaN\nc  3.0  5.0\nd  NaN  6.0\n\n\n\n# DataFrame 생성7 : 인덱스 및 열 이름 지정\ndata = [[101, 22], [102, 20], [103, 27]]\ncolumns = ['ID', 'Age']\nindex = ['Alice', 'Bob', 'Charlie']\ndf = pd.DataFrame(data, columns=columns, index=index)\nprint(df)\n\n          ID  Age\nAlice    101   22\nBob      102   20\nCharlie  103   27\n\n\n\n# Index 생성1 : 리스트 사용\nidx = pd.Index(['a', 'b', 'c', 'd'])\nidx\n\nIndex(['a', 'b', 'c', 'd'], dtype='object')\n\n\n\n# Index 생성2 : range() 사용\nidx = pd.Index(range(1, 6))\nidx\n\nRangeIndex(start=1, stop=6, step=1)\n\n\n\n\n\n\n\n\n\n속성\n설명\n\n\n\n\n.shape\n데이터프레임의 모양(행, 열)\n\n\n.index\n행 인덱스 조회 및 변경\n\n\n.columns\n열 이름 조회 및 변경\n\n\n.dtypes\n각 열의 자료형 확인\n\n\n\n\n# 데이터프레임 속성\ndf = pd.DataFrame({\n    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],\n    'Age': [25, 30, 35, 40, 28],\n    'Score': [85.5, 90.3, 78.2, 88.9, 92.5]\n})\n\nprint(df.shape)\nprint(df.index)\nprint(df.columns)\nprint(df.dtypes)\n\n(5, 3)\nRangeIndex(start=0, stop=5, step=1)\nIndex(['Name', 'Age', 'Score'], dtype='object')\nName      object\nAge        int64\nScore    float64\ndtype: object\n\n\n\n# 행 인덱스 변경\ndf.index = ['a', 'b', 'c', 'd', 'e']\nprint(df)\n\n      Name  Age  Score\na    Alice   25   85.5\nb      Bob   30   90.3\nc  Charlie   35   78.2\nd    David   40   88.9\ne      Eva   28   92.5\n\n\n\n# 열 이름 변경\ndf.columns = ['Student Name', 'Student Age', 'Exam Score']\nprint(df)\n\n  Student Name  Student Age  Exam Score\na        Alice           25        85.5\nb          Bob           30        90.3\nc      Charlie           35        78.2\nd        David           40        88.9\ne          Eva           28        92.5\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ninfo()\n기본 정보(행 개수, 열 개수, 데이터 자료형, 결측값 여부 등) 출력\n\n\nhead()\n상위 n개의 행 출력(초기 값 n=5)\n\n\ndescribe()\n수치형 데이터의 요약 통계량(평균, 표준편차 등) 제공\n\n\n\n\ndf = pd.DataFrame({\n    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],\n    'Age': [25, 30, 35, 40, 28],\n    'Score': [85.5, 90.3, 78.2, 88.9, 92.5]\n})\n\n\n# 기본 정보\nprint(df.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 5 entries, 0 to 4\nData columns (total 3 columns):\n #   Column  Non-Null Count  Dtype  \n---  ------  --------------  -----  \n 0   Name    5 non-null      object \n 1   Age     5 non-null      int64  \n 2   Score   5 non-null      float64\ndtypes: float64(1), int64(1), object(1)\nmemory usage: 252.0+ bytes\nNone\n\n\n\n# 상위 5개 행\nprint(df.head())\n\n      Name  Age  Score\n0    Alice   25   85.5\n1      Bob   30   90.3\n2  Charlie   35   78.2\n3    David   40   88.9\n4      Eva   28   92.5\n\n\n\n# 요약 통계량\nprint(df.describe())\n\n            Age      Score\ncount   5.00000   5.000000\nmean   31.60000  87.080000\nstd     5.94138   5.576917\nmin    25.00000  78.200000\n25%    28.00000  85.500000\n50%    30.00000  88.900000\n75%    35.00000  90.300000\nmax    40.00000  92.500000\n\n\n\n\n\n\n\n\n\n\n열 이름을 사용하여 직접 선택\n\n여러 개의 열을 선택할 때는 열 이름을 리스트로 작성\n\nloc[:, ] : 레이블(label) 기반 접근 방식\niloc[:, ] : 정수(integer) 기반 접근 방식\n\n\ndf = pd.DataFrame({\n    'A': [1, 2, 3],\n    'B': [4, 5, 6],\n    'C': [7, 8, 9],\n    'D': [10, 11, 12]\n}, index=['x', 'y', 'z'])\n\n\n# 열 인덱싱과 슬라이싱1 : 열 이름 사용\ndf['A']                                      # 열 이름\ndf[['A', 'C']]                               # 열 이름 리스트\n#df['A':'B']                                 # 열 이름 슬라이싱은 안 됨, Error!\n\n\n\n\n\n\n\n\nA\nC\n\n\n\n\nx\n1\n7\n\n\ny\n2\n8\n\n\nz\n3\n9\n\n\n\n\n\n\n\n\n# 열 인덱싱과 슬라이싱2 : 레이블 기반 접근\ndf.loc[:, 'A']                               # 열 이름\ndf.loc[:, ['A', 'C']]                        # 열 이름 리스트\ndf.loc[:, 'A':'B']                           # 열 이름 슬라이싱\ndf.loc[:, 'B'::2]                            # 열 이름 스트라이딩\ndf.loc[:, [True, False, True, True]]         # bool 리스트\n\n\n\n\n\n\n\n\nA\nC\nD\n\n\n\n\nx\n1\n7\n10\n\n\ny\n2\n8\n11\n\n\nz\n3\n9\n12\n\n\n\n\n\n\n\n\n# 열 인덱싱과 슬라이싱3 : 정수 기반 접근\ndf.iloc[:, 0]                                # 정수\ndf.iloc[:, [0, 3]]                           # 정수 리스트\ndf.iloc[:, range(2)]                         # range\ndf.iloc[:, 0:3]                              # 슬라이싱\ndf.iloc[:, 1::2]                             # 스트라이딩\n\n\n\n\n\n\n\n\nB\nD\n\n\n\n\nx\n4\n10\n\n\ny\n5\n11\n\n\nz\n6\n12\n\n\n\n\n\n\n\n\n\n\n\n\nloc[, :] : 레이블(label) 기반 접근 방식\niloc[, :] : 정수(integer) 기반 접근 방식\n\n\n# 행 인덱싱과 슬라이싱1 : 레이블 기반 접근\ndf.loc['x', ]                                # 인덱스 이름\ndf.loc[['x', 'y'], :]                        # 인덱스 이름 리스트\ndf.loc['x':'y', :]                           # 인덱스 이름 슬라이싱\ndf.loc['x'::1, :]                            # 인덱스 이름 스트라이딩\ndf.loc[[True, False, True], :]               # bool 리스트\ndf.loc[list(df['A'] &lt; 3), :]                 # bool 리스트\ndf.loc[df['A'] &lt; 3, :]                       # bool 리스트\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nx\n1\n4\n7\n10\n\n\ny\n2\n5\n8\n11\n\n\n\n\n\n\n\n\n# 행 인덱싱과 슬라이싱2 : 정수 기반 접근\ndf.iloc[0, :]                                # 정수\ndf.iloc[[0, 2], :]                           # 정수 리스트\ndf.iloc[range(2), :]                         # range\ndf.iloc[0:1, :]                              # 슬라이싱\ndf.iloc[1::2, :]                             # 스트라이딩\ndf.iloc[[True, False, True], :]              # bool 리스트 (권장하지 않음)\ndf.iloc[list(df['A'] &lt; 3), :]                # bool 리스트 (권장하지 않음)\n#df.iloc[df['A'] &lt; 3, :]                     # bool 리스트 (Error!)\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nx\n1\n4\n7\n10\n\n\ny\n2\n5\n8\n11\n\n\n\n\n\n\n\n\n# 행 인덱싱과 슬라이싱3 : 정수 기반 접근\ndf.iloc[0]                                   # 정수\ndf.iloc[[0, 2]]                              # 정수 리스트\ndf.iloc[range(2)]                            # range\ndf.iloc[0:1]                                 # 슬라이싱\ndf.iloc[1::2]                                # 스트라이딩\ndf.iloc[[True, False, True]]                 # bool 리스트(권장하지 않음)\ndf.iloc[list(df['A'] &lt; 3)]                   # bool 리스트(권장하지 않음)\n#df.iloc[df['A'] &lt; 3]                        # bool 리스트 (Error!)\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nx\n1\n4\n7\n10\n\n\ny\n2\n5\n8\n11\n\n\n\n\n\n\n\n\n# 행 인덱싱과 슬라이싱4\n# 인덱싱은 열을 참조하는 반면, 슬라이싱은 행을 참조함\n#df[0]                                       # Error!\ndf[0:2]                                      # 권장하지 않음\ndf['x':'y']                                  # 권장하지 않음\ndf[df['A'] &lt; 3]                              # 불리언 인덱싱은 행 단위로 적용됨\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nx\n1\n4\n7\n10\n\n\ny\n2\n5\n8\n11\n\n\n\n\n\n\n\n\n# 행 인덱싱과 슬라이싱5\ndf = pd.DataFrame({\n    'A': [1, 2, 3],\n    'B': [4, 5, 6],\n    'C': [7, 8, 9],\n    'D': [10, 11, 12]})\n\ndf.loc[0:1]                                  # 명시적 인덱스(label) 사용 - 마지막 인덱스 포함\ndf.iloc[0:1]                                 # 암묵적 인덱스(integer) 사용 - 마지막 인덱스 제외\ndf[0:1]                                      # 암묵적 인덱스(integer) 사용, iloc와 동일\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n0\n1\n4\n7\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumPy와 동일하게 벡터화, 브로드캐스팅 모두 지원\n단항 연산: 인덱스와 열 레이블 보존\n이항 연산: 인덱스와 열 레이블을 기준으로 자동 정렬되어 연산\n\n위치가 아닌 동일한 레이블끼리 연산하며, 일치하지 않는 항목은 NaN으로 처리\n\n\n\n# 단항 연산1 : Series\nsr = pd.Series([1, 2, 3, 4, 5])\nprint(sr + 2)\n\n0    3\n1    4\n2    5\n3    6\n4    7\ndtype: int64\n\n\n\n# 단항 연산2 : DataFrame\ndf = pd.DataFrame({\n    'x': [1, 2, 3, 4, 5],\n    'y': [11, 12, 13, 14, 15] \n})\nprint(np.log(df))\n\n          x         y\n0  0.000000  2.397895\n1  0.693147  2.484907\n2  1.098612  2.564949\n3  1.386294  2.639057\n4  1.609438  2.708050\n\n\n\n# 이항 연산1 : Series\n# 두 시리즈에 존재하는 모든 행 인덱스를 포함한 결과 생성 (합집합처럼 동작)\nmath = pd.Series({'Alice': 85, 'Bob': 90, 'Charlie': 78})\nenglish = pd.Series({'Alice': 95, 'Charlie': 80, 'David': 88})\nprint(math + english)\n\nAlice      180.0\nBob          NaN\nCharlie    158.0\nDavid        NaN\ndtype: float64\n\n\n\n# 이항 연산2: DataFrame\nmidterm = pd.DataFrame({\n    'math': [85, 90, 78],\n    'science': [88, 92, 79]\n}, index=['Alice', 'Bob', 'Charlie'])\n\nfinal = pd.DataFrame({\n    'math': [95, 88, 82],\n    'english': [95, 80, 88]\n}, index=['Alice', 'Charlie', 'David'])\n\nprint(midterm + final)\n\n         english   math  science\nAlice        NaN  180.0      NaN\nBob          NaN    NaN      NaN\nCharlie      NaN  166.0      NaN\nDavid        NaN    NaN      NaN\n\n\n\n\n\n\n\n인덱스와 열 레이블이 일치하지 않아도 연산 가능\n예외 처리가 필요한 경우 기본 연산자보다 안정적임\n\nfill_value 인수를 사용하여 NaN를 다른 값으로 처리 가능\n\n\n\n\n\n연산자\n연산자 메소드\n\n\n\n\n+\nadd()\n\n\n-\nsub()\n\n\n*\nmul()\n\n\n/\ndivide()\n\n\n//\nfloordiv()\n\n\n%\nmod()\n\n\n**\npow()\n\n\n\n\n# 연산자 메소드1\n# midterm + final과 동일한 결과\nprint(midterm.add(final))\n\n         english   math  science\nAlice        NaN  180.0      NaN\nBob          NaN    NaN      NaN\nCharlie      NaN  166.0      NaN\nDavid        NaN    NaN      NaN\n\n\n\n# 연산자 메소드2\n# 하나의 데이터프레임에만 값이 있는 경우 0으로 처리하고, 둘 다 값이 없으면 NaN 반환\nprint(midterm.add(final, fill_value = 0))\n\n         english   math  science\nAlice       95.0  180.0     88.0\nBob          NaN   90.0     92.0\nCharlie     80.0  166.0     79.0\nDavid       88.0   82.0      NaN\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nassign()\n기존 데이터프레임을 수정하지 않고, 새로운 열을 추가한 복사본을 반환\n\n\neval()\n수식을 문자열로 작성하여 열 간 계산을 간결하게 수행(직관적인 수식 표현)\n\n\nwhere()\n조건에 따라 서로 다른 값을 선택하여 새로운 열 생성(NumPy 메소드)\n\n\n\n\ndf = pd.DataFrame({\n    'product': ['A', 'B', 'C', 'D', 'E'],\n    'price': [100, 200, 150, 300, 250],\n    'quantity': [10, 5, 3, 7, 6]\n})\nprint(df)\n\n  product  price  quantity\n0       A    100        10\n1       B    200         5\n2       C    150         3\n3       D    300         7\n4       E    250         6\n\n\n\n# 새로운 열 생성1: 기본 할당\n# 기본 할당은 데이터를 직접 수정하므로, 권장하지 않음\ndf['total_price'] = df['price'] * df['quantity']\nprint(df)\n\n  product  price  quantity  total_price\n0       A    100        10         1000\n1       B    200         5         1000\n2       C    150         3          450\n3       D    300         7         2100\n4       E    250         6         1500\n\n\n\n# 새로운 열 생성2: assign() 사용\nprint(df.assign(total_price = df['price'] * df['quantity']))\n\n  product  price  quantity  total_price\n0       A    100        10         1000\n1       B    200         5         1000\n2       C    150         3          450\n3       D    300         7         2100\n4       E    250         6         1500\n\n\n\n# 새로운 열 생성3: eval() 사용\n# inplace=True: 기존 데이터프레임에 직접 적용(새 객체를 반환하지 않음)\ndf.eval('total_price = price * quantity', inplace=True)\nprint(df)\n\n  product  price  quantity  total_price\n0       A    100        10         1000\n1       B    200         5         1000\n2       C    150         3          450\n3       D    300         7         2100\n4       E    250         6         1500\n\n\n\n# 새로운 열 생성4: where() 사용\n# 가격이 200 이상이면 'Expensive', 아니면 'Affordable'로 구분\ndf['price_category'] = np.where(df['price'] &gt;= 200, 'Expensive', 'Affordable')\nprint(df)\n\n  product  price  quantity  total_price price_category\n0       A    100        10         1000     Affordable\n1       B    200         5         1000      Expensive\n2       C    150         3          450     Affordable\n3       D    300         7         2100      Expensive\n4       E    250         6         1500      Expensive\n\n\n\n\n\n\n\nNumPy와 동일한 축 개념 사용\n\naxis 0 : 행 방향 연산(열 단위로 요약)\naxis 1 : 열 방향 연산(행 단위로 요약)\n\n수치형 데이터에 적용되며, NaN은 기본적으로 제외됨\n\n\n\n\n함수\n설명\n\n\n\n\ncount()\nNaN를 제외한 행의 개수\n\n\nvalue_counts()\n집단별 빈도\n\n\nsum()\n합계\n\n\nmean()\n평균\n\n\nstd()\n표준편차\n\n\nmedian()\n중앙값\n\n\nmin(), max()\n최소값, 최대값\n\n\ncumsum(), cumprod()\n누적 합계, 누적 곱\n\n\n\n\n## 실습 데이터 : tips 데이터셋\nimport seaborn as sns\ntips = sns.load_dataset('tips')\n\n\n# total_bill: 식사 금액\n# tip: 팁 금액\n# sex: 성별\n# smoker: 흡연 여부\n# day: 요일\n# time: 식사 시간(Lunch, Dinner)\n# size: 식사 인원 수\nprint(tips.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 244 entries, 0 to 243\nData columns (total 7 columns):\n #   Column      Non-Null Count  Dtype   \n---  ------      --------------  -----   \n 0   total_bill  244 non-null    float64 \n 1   tip         244 non-null    float64 \n 2   sex         244 non-null    category\n 3   smoker      244 non-null    category\n 4   day         244 non-null    category\n 5   time        244 non-null    category\n 6   size        244 non-null    int64   \ndtypes: category(4), float64(2), int64(1)\nmemory usage: 7.4 KB\nNone\n\n\n\nprint(tips.head())\n\n   total_bill   tip     sex smoker  day    time  size\n0       16.99  1.01  Female     No  Sun  Dinner     2\n1       10.34  1.66    Male     No  Sun  Dinner     3\n2       21.01  3.50    Male     No  Sun  Dinner     3\n3       23.68  3.31    Male     No  Sun  Dinner     2\n4       24.59  3.61  Female     No  Sun  Dinner     4\n\n\n\nprint(tips.describe())\n\n       total_bill         tip        size\ncount  244.000000  244.000000  244.000000\nmean    19.785943    2.998279    2.569672\nstd      8.902412    1.383638    0.951100\nmin      3.070000    1.000000    1.000000\n25%     13.347500    2.000000    2.000000\n50%     17.795000    2.900000    2.000000\n75%     24.127500    3.562500    3.000000\nmax     50.810000   10.000000    6.000000\n\n\n\n# 각 열의 유효한 데이터 수 (NaN 제외)\nprint(tips.count())\n\ntotal_bill    244\ntip           244\nsex           244\nsmoker        244\nday           244\ntime          244\nsize          244\ndtype: int64\n\n\n\n# 식사 시간별 주문 수\nprint(tips.value_counts('time'))\n\ntime\nDinner    176\nLunch      68\nName: count, dtype: int64\n\n\n\n# 전체(합계) 식사 금액, 팁 금액, 식사 인원 수\nprint(tips[['total_bill', 'tip', 'size']].sum())\n\ntotal_bill    4827.77\ntip            731.58\nsize           627.00\ndtype: float64\n\n\n\n# 고객 1인당 평균 식사 금액\nprint((tips['total_bill'] / tips['size']).mean())\n\n7.888229508196722\n\n\n\n# 고객 1인당 평균 팁 금액\nprint((tips['tip'] / tips['size']).mean())\n\n1.2127616120218578\n\n\n\n# 전체 식사 금액에서 팁이 차지하는 비율\nprint(tips['tip'] / tips['total_bill'])\n\n0      0.059447\n1      0.160542\n2      0.166587\n3      0.139780\n4      0.146808\n         ...   \n239    0.203927\n240    0.073584\n241    0.088222\n242    0.098204\n243    0.159744\nLength: 244, dtype: float64\n\n\n\n# 전체 식사 금액에서 팁이 차지하는 비율에 대한 요약 통계량\nprint((tips['tip'] / tips['total_bill']).describe())\n\ncount    244.000000\nmean       0.160803\nstd        0.061072\nmin        0.035638\n25%        0.129127\n50%        0.154770\n75%        0.191475\nmax        0.710345\ndtype: float64\n\n\n\n# 전체 식사 금액에서 팁이 차지하는 비율이 50% 이상인 경우\nprint(tips[tips['tip'] / tips['total_bill'] &gt;= 0.5])\n\n     total_bill   tip   sex smoker  day    time  size\n172        7.25  5.15  Male    Yes  Sun  Dinner     2\n\n\n\n\n\n\n\n\n\n\ngroupby() 함수를 이용하여 특정 열을 기준으로 데이터를 집단화한 후, 다양한 연산 수행 가능\nSQL의 GROUP BY와 유사한 기능을 제공하며, 집계, 변환, 필터링을 지원\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\naggregate() 또는 agg()\n여러 집계 함수를 동시에 적용(문자열, 함수, 리스트 등 가능)\n\n\nfilter()\n집단별 집계 결과를 조건으로 집단 자체를 필터링\n\n\ntransform()\n집단별 연산 결과를 원래 구조와 같은 형태로 반환(원소 개수 유지)\n\n\napply()\n임의의 함수를 전체 집단에 유연하게 적용(집계, 반환 모두 가능)\n\n\n\n\n#  실습 데이터 : tips 데이터셋\ntips = sns.load_dataset('tips')\n\n\n# 요일별 평균 식사 금액\n# observed=False: 모든 범주 포함, 실제 데이터가 없으면 NaN\nprint(tips.groupby('day', observed=False)['total_bill'].mean())\n\nday\nThur    17.682742\nFri     17.151579\nSat     20.441379\nSun     21.410000\nName: total_bill, dtype: float64\n\n\n\n# 식사 시간별 식사 금액, 팁 금액의 평균 및 표준편차\nprint(tips.groupby('time', observed=False)[['total_bill', 'tip']].agg(['mean', 'std']))\n\n       total_bill                 tip          \n             mean       std      mean       std\ntime                                           \nLunch   17.168676  7.713882  2.728088  1.205345\nDinner  20.797159  9.142029  3.102670  1.436243\n\n\n\n# 식사 시간별 식사 금액의 최대값, 팁 금액의 최소값: 딕셔너리 사용\nprint(tips.groupby('time', observed=False).agg({'total_bill': 'max', 'tip': 'min'}).reset_index())\n\n     time  total_bill   tip\n0   Lunch       43.11  1.25\n1  Dinner       50.81  1.00\n\n\n\n# 식사 시간별 식사 금액의 최대값, 팁 금액의 최소값: 튜플 사용, named aggregation 문법\nprint(tips.groupby('time', observed=False).agg(total_bill_max = ('total_bill', 'max'), tip_min = ('tip', 'min')).reset_index())\n\n     time  total_bill_max  tip_min\n0   Lunch           43.11     1.25\n1  Dinner           50.81     1.00\n\n\n\n\n[참고] 람다 함수(lamdba function)\n\n함수 이름 없이 일시적으로 정의해 사용할 수 있는 익명 함수\ndef, return 없이 간단한 함수 로직을 한 줄로 표현\n구조는 일반 함수와 같지만, 주로 짧고 단순한 연산에 사용\napply(), filter() 등 함수의 인수로 전달할 때 유용하게 활용\n\n\n\n# 함수 정의\ndef f(x, y):\n    return x + y\nf(1, 4)\n\n5\n\n\n\n# 람다 함수\n(lambda x, y: x + y)(1, 4)\n\n5\n\n\n\n# 팀 금액 평균이 3달러 이상인 요일 데이터 필터링: 함수 정의\ndef filter_tip_avg(x):\n    return x['tip'].mean() &gt;= 3\n\nprint(tips.groupby('day', observed=False).filter(filter_tip_avg))\n\n     total_bill   tip     sex smoker  day    time  size\n0         16.99  1.01  Female     No  Sun  Dinner     2\n1         10.34  1.66    Male     No  Sun  Dinner     3\n2         21.01  3.50    Male     No  Sun  Dinner     3\n3         23.68  3.31    Male     No  Sun  Dinner     2\n4         24.59  3.61  Female     No  Sun  Dinner     4\n..          ...   ...     ...    ...  ...     ...   ...\n186       20.90  3.50  Female    Yes  Sun  Dinner     3\n187       30.46  2.00    Male    Yes  Sun  Dinner     5\n188       18.15  3.50  Female    Yes  Sun  Dinner     3\n189       23.10  4.00    Male    Yes  Sun  Dinner     3\n190       15.69  1.50    Male    Yes  Sun  Dinner     2\n\n[76 rows x 7 columns]\n\n\n\n# 팀 금액 평균이 3달러 이상인 요일 데이터 필터링: 람다 함수 사용\nprint(tips.groupby('day', observed=False).filter(lambda x: x['tip'].mean() &gt;= 3))\n\n     total_bill   tip     sex smoker  day    time  size\n0         16.99  1.01  Female     No  Sun  Dinner     2\n1         10.34  1.66    Male     No  Sun  Dinner     3\n2         21.01  3.50    Male     No  Sun  Dinner     3\n3         23.68  3.31    Male     No  Sun  Dinner     2\n4         24.59  3.61  Female     No  Sun  Dinner     4\n..          ...   ...     ...    ...  ...     ...   ...\n186       20.90  3.50  Female    Yes  Sun  Dinner     3\n187       30.46  2.00    Male    Yes  Sun  Dinner     5\n188       18.15  3.50  Female    Yes  Sun  Dinner     3\n189       23.10  4.00    Male    Yes  Sun  Dinner     3\n190       15.69  1.50    Male    Yes  Sun  Dinner     2\n\n[76 rows x 7 columns]\n\n\n\n# 성별 팁 금액의 편차\ntips['tip_dev'] = tips.groupby('sex', observed=False)['tip'].transform(lambda x: x - x.mean())\nprint(tips[['sex', 'tip', 'tip_dev']].head())\n\n      sex   tip   tip_dev\n0  Female  1.01 -1.823448\n1    Male  1.66 -1.429618\n2    Male  3.50  0.410382\n3    Male  3.31  0.220382\n4  Female  3.61  0.776552\n\n\n\n# 식사 시간별 팁 금액의 사분위수범위: 함수 정의\ndef iqr(x):\n    return x.quantile(0.75) - x.quantile(0.25)\n\nprint(tips.groupby('time', observed=False)['tip'].apply(iqr))\n\ntime\nLunch     1.2875\nDinner    1.6875\nName: tip, dtype: float64\n\n\n\n# 식사 시간별 팁 금액의 사분위수범위: 람다 함수 사용\nprint(tips.groupby('time', observed=False)['tip'].apply(lambda x: x.quantile(0.75) - x.quantile(0.25)))\n\ntime\nLunch     1.2875\nDinner    1.6875\nName: tip, dtype: float64\n\n\n\n\n\n\n\neval(), query() 메소드를 사용하면 문자열 형태의 표현식을 통해 데이터를 보다 직관적으로 처리 가능\n복잡한 연산이나 조건 필터링을 간결하게 표현할 수 있어 가독성과 성능 모두에 유리함\n\n데이터프레임의 열 이름을 따옴표 없이 사용 가능\n외부 변수는 @ 기호를 사용하여 표현식에 표현 가능\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\neval()\n- 문자열로 작성한 수식을 이용하여 기존 열을 연산하거나 새로운 열을 생성 - Python 표현식을 그대로 사용할 수 있어 가독성이 높음\n\n\nquery()\n- 문자열로 작성한 조건식을 이용하여 행을 필터링- 복잡한 불리언 인덱싱보다 간결하고 직관적인 문법 제공 - 논리 연산자는 &, \\|, ~의 사용을 권장하며, 각 조건은 괄호 ()로 감싸야 함\n\n\n\n\n#  실습 데이터 : tips 데이터셋\ntips = sns.load_dataset('tips')\n\n\n# 기존 열 연산: 식사 금액에서 세금 10%를 제외한 실수령 금액\nprint(tips.eval('total_bill = total_bill * 0.9'))\n\n     total_bill   tip     sex smoker   day    time  size\n0        15.291  1.01  Female     No   Sun  Dinner     2\n1         9.306  1.66    Male     No   Sun  Dinner     3\n2        18.909  3.50    Male     No   Sun  Dinner     3\n3        21.312  3.31    Male     No   Sun  Dinner     2\n4        22.131  3.61  Female     No   Sun  Dinner     4\n..          ...   ...     ...    ...   ...     ...   ...\n239      26.127  5.92    Male     No   Sat  Dinner     3\n240      24.462  2.00  Female    Yes   Sat  Dinner     2\n241      20.403  2.00    Male    Yes   Sat  Dinner     2\n242      16.038  1.75    Male     No   Sat  Dinner     2\n243      16.902  3.00  Female     No  Thur  Dinner     2\n\n[244 rows x 7 columns]\n\n\n\n# 새로운 열 생성: 전체 식사 금액 대비 팁 금액 비율\n# inplace=True: 기존 데이터프레임에 직접 적용(새 객체를 반환하지 않음)\ntips.eval('tip_rate = tip / total_bill', inplace=True)\nprint(tips)\n\n     total_bill   tip     sex smoker   day    time  size  tip_rate\n0         16.99  1.01  Female     No   Sun  Dinner     2  0.059447\n1         10.34  1.66    Male     No   Sun  Dinner     3  0.160542\n2         21.01  3.50    Male     No   Sun  Dinner     3  0.166587\n3         23.68  3.31    Male     No   Sun  Dinner     2  0.139780\n4         24.59  3.61  Female     No   Sun  Dinner     4  0.146808\n..          ...   ...     ...    ...   ...     ...   ...       ...\n239       29.03  5.92    Male     No   Sat  Dinner     3  0.203927\n240       27.18  2.00  Female    Yes   Sat  Dinner     2  0.073584\n241       22.67  2.00    Male    Yes   Sat  Dinner     2  0.088222\n242       17.82  1.75    Male     No   Sat  Dinner     2  0.098204\n243       18.78  3.00  Female     No  Thur  Dinner     2  0.159744\n\n[244 rows x 8 columns]\n\n\n\n# 외부 변수 사용: 전체 식사 금액에 따른 기본(최소) 팁 금액\ntip_percentage = 0.15\ntips.eval('min_tip = total_bill * @tip_percentage', inplace = True)\nprint(tips)\n\n     total_bill   tip     sex smoker   day    time  size  tip_rate  min_tip\n0         16.99  1.01  Female     No   Sun  Dinner     2  0.059447   2.5485\n1         10.34  1.66    Male     No   Sun  Dinner     3  0.160542   1.5510\n2         21.01  3.50    Male     No   Sun  Dinner     3  0.166587   3.1515\n3         23.68  3.31    Male     No   Sun  Dinner     2  0.139780   3.5520\n4         24.59  3.61  Female     No   Sun  Dinner     4  0.146808   3.6885\n..          ...   ...     ...    ...   ...     ...   ...       ...      ...\n239       29.03  5.92    Male     No   Sat  Dinner     3  0.203927   4.3545\n240       27.18  2.00  Female    Yes   Sat  Dinner     2  0.073584   4.0770\n241       22.67  2.00    Male    Yes   Sat  Dinner     2  0.088222   3.4005\n242       17.82  1.75    Male     No   Sat  Dinner     2  0.098204   2.6730\n243       18.78  3.00  Female     No  Thur  Dinner     2  0.159744   2.8170\n\n[244 rows x 9 columns]\n\n\n\n# 기본(최소) 팁 금액보다 적게 준 경우 'Below', 많거나 같은 경우 'Above'로 구분\n# 기본(최소) 팁 금액보다 적게 준 경우는 108팀임\ntips['tip_group'] = np.where(tips['tip'] &lt; tips['min_tip'], 'Below', 'Above')\nprint(tips['tip_group'].value_counts())\n\ntip_group\nAbove    136\nBelow    108\nName: count, dtype: int64\n\n\n\n# 단일 조건 필터링: 식사 금액이 20달러 이상인 경우\nprint(tips.query('total_bill &gt;= 20'))\n\n     total_bill   tip     sex smoker  day    time  size  tip_rate  min_tip  \\\n2         21.01  3.50    Male     No  Sun  Dinner     3  0.166587   3.1515   \n3         23.68  3.31    Male     No  Sun  Dinner     2  0.139780   3.5520   \n4         24.59  3.61  Female     No  Sun  Dinner     4  0.146808   3.6885   \n5         25.29  4.71    Male     No  Sun  Dinner     4  0.186240   3.7935   \n7         26.88  3.12    Male     No  Sun  Dinner     4  0.116071   4.0320   \n..          ...   ...     ...    ...  ...     ...   ...       ...      ...   \n237       32.83  1.17    Male    Yes  Sat  Dinner     2  0.035638   4.9245   \n238       35.83  4.67  Female     No  Sat  Dinner     3  0.130338   5.3745   \n239       29.03  5.92    Male     No  Sat  Dinner     3  0.203927   4.3545   \n240       27.18  2.00  Female    Yes  Sat  Dinner     2  0.073584   4.0770   \n241       22.67  2.00    Male    Yes  Sat  Dinner     2  0.088222   3.4005   \n\n    tip_group  \n2       Above  \n3       Below  \n4       Below  \n5       Above  \n7       Below  \n..        ...  \n237     Below  \n238     Below  \n239     Above  \n240     Below  \n241     Below  \n\n[97 rows x 10 columns]\n\n\n\n# 다중 조건 필터링: 식사 인원 수가 3명 이상이고, 목요일에 방문한 경우\n#print(tips.query('size &gt;= 3 and day == \"Thur\"'))           # 권장하지 않음, 조건이 복잡할 경우 오류가 발생할 수 있음\nprint(tips.query('(size &gt;= 3) & (day == \"Thur\")'))          # 권장 방식: 괄호로 각 조건을 명확히 구분\n\n     total_bill   tip     sex smoker   day   time  size  tip_rate  min_tip  \\\n77        27.20  4.00    Male     No  Thur  Lunch     4  0.147059   4.0800   \n85        34.83  5.17  Female     No  Thur  Lunch     4  0.148435   5.2245   \n119       24.08  2.92  Female     No  Thur  Lunch     4  0.121262   3.6120   \n125       29.80  4.20  Female     No  Thur  Lunch     6  0.140940   4.4700   \n129       22.82  2.18    Male     No  Thur  Lunch     3  0.095530   3.4230   \n141       34.30  6.70    Male     No  Thur  Lunch     6  0.195335   5.1450   \n142       41.19  5.00    Male     No  Thur  Lunch     5  0.121389   6.1785   \n143       27.05  5.00  Female     No  Thur  Lunch     6  0.184843   4.0575   \n146       18.64  1.36  Female     No  Thur  Lunch     3  0.072961   2.7960   \n197       43.11  5.00  Female    Yes  Thur  Lunch     4  0.115982   6.4665   \n200       18.71  4.00    Male    Yes  Thur  Lunch     3  0.213789   2.8065   \n204       20.53  4.00    Male    Yes  Thur  Lunch     4  0.194837   3.0795   \n205       16.47  3.23  Female    Yes  Thur  Lunch     3  0.196114   2.4705   \n\n    tip_group  \n77      Below  \n85      Below  \n119     Below  \n125     Below  \n129     Below  \n141     Above  \n142     Below  \n143     Above  \n146     Below  \n197     Below  \n200     Above  \n204     Above  \n205     Above  \n\n\n\n# 외부 변수 사용: 기준 팁 금액 미만인 경우\nmin_tip_required = 5\nprint(tips.query('tip &lt; @min_tip_required'))\n\n     total_bill   tip     sex smoker   day    time  size  tip_rate  min_tip  \\\n0         16.99  1.01  Female     No   Sun  Dinner     2  0.059447   2.5485   \n1         10.34  1.66    Male     No   Sun  Dinner     3  0.160542   1.5510   \n2         21.01  3.50    Male     No   Sun  Dinner     3  0.166587   3.1515   \n3         23.68  3.31    Male     No   Sun  Dinner     2  0.139780   3.5520   \n4         24.59  3.61  Female     No   Sun  Dinner     4  0.146808   3.6885   \n..          ...   ...     ...    ...   ...     ...   ...       ...      ...   \n238       35.83  4.67  Female     No   Sat  Dinner     3  0.130338   5.3745   \n240       27.18  2.00  Female    Yes   Sat  Dinner     2  0.073584   4.0770   \n241       22.67  2.00    Male    Yes   Sat  Dinner     2  0.088222   3.4005   \n242       17.82  1.75    Male     No   Sat  Dinner     2  0.098204   2.6730   \n243       18.78  3.00  Female     No  Thur  Dinner     2  0.159744   2.8170   \n\n    tip_group  \n0       Below  \n1       Above  \n2       Above  \n3       Below  \n4       Below  \n..        ...  \n238     Below  \n240     Below  \n241     Below  \n242     Below  \n243     Above  \n\n[216 rows x 10 columns]\n\n\n\n# 기준 팁 금액보다 적게 준 경우는 216팀임\nprint(tips.query('tip &lt; @min_tip_required').shape[0])\nprint(len(tips.query('tip &lt; @min_tip_required')))\n\n216\n216\n\n\n\n\n\n\n\n\n\n\n일정한 시간 간격으로 관측된 연속적인 데이터\nPandas에서는 시계열 데이터를 처리하기 위한 다양한 날짜/시간 관련 객체를 제공함\n\n\n\n\n\n\n\n\n\n\n구분\n설명\n예\nPandas 객체\n\n\n\n\n타임스탬프(timestampe)\n특정 시점\n2025-03-02 09:00\npd.TimeStamp, DatetimeIndex\n\n\n시간 기간(period)\n일정한 시간 구간(시작~종료)\n2025년 3월 (월간)\npd.Period, PeriodIndex\n\n\n시간 델타(time delta)\n두 시점 사이의 시간 간격\n2일, 5시간\npd.Timedelta, TimedeltaIndex\n\n\n\n\nprint(pd.Timestamp('2025-03-02 09:00'))      # 타임스탬프\nprint(pd.Period('2025-03', freq='M'))        # 시간 기간\nprint(pd.Timedelta(days=2, hours=5))         # 시간 델타\n\n2025-03-02 09:00:00\n2025-03\n2 days 05:00:00\n\n\n\n\n\n\n\npd.to_datetime() 함수\n\n문자열이나 정수 등 다양한 형태의 데이터를 시계열 데이터(datetime 형식)로 변환\nformat 인자를 사용하여 날짜 형식을 명시적으로 지정 가능\nerrors='coerce' 인자를 사용하면 오류 발생 시 NaT(Not a Time)으로 처리\n시계열 인덱스를 설정하거나 변환할 때도 자주 사용됨\n\n\n\n\n\n코드\n설명\n예\n\n\n\n\n%Y\n전체 연도\n2025\n\n\n%B\n전체 월 이름\nMarch\n\n\n%m\n0으로 시작하는 월\n03\n\n\n%d\n0으로 시작하는 일\n02\n\n\n%H\n0으로 시작하는 시간(24시간제)\n14\n\n\n%I\n0으로 시작하는 시간(12시간제)\n09\n\n\n%p\nAM 또는 PM\nAM\n\n\n%M\n0으로 시작하는 분\n00\n\n\n%S\n0으로 시작하는 초\n00\n\n\n\n\n# Timestampe1: 문자열 리스트 사용\npd.to_datetime(['2025-03-02', '2025-03-03', '2025-03-04'])\n\nDatetimeIndex(['2025-03-02', '2025-03-03', '2025-03-04'], dtype='datetime64[ns]', freq=None)\n\n\n\n# Timestampe2: 명시적 형식 지정\npd.to_datetime(['March 2, 2025', 'March 3, 2025', 'March 4, 2025'], format='%B %d, %Y')\n\nDatetimeIndex(['2025-03-02', '2025-03-03', '2025-03-04'], dtype='datetime64[ns]', freq=None)\n\n\n\n# Timestampe3: 오류 발생 시 NaT 처리\npd.to_datetime([\"2025-03-02\", \"not a date\"], errors=\"coerce\")\n\nDatetimeIndex(['2025-03-02', 'NaT'], dtype='datetime64[ns]', freq=None)\n\n\n\n# Timestampe4: 정수 데이터프레임 사용(각 행을 날짜로 변환)\ndf = pd.DataFrame({\n    \"year\": [2025, 2025],\n    \"month\": [3, 4],\n    \"day\": [2, 15]\n})\npd.to_datetime(df)\n\n0   2025-03-02\n1   2025-04-15\ndtype: datetime64[ns]\n\n\n\n# Period: 2025년 3월 1일 ~ 31일(한 달)\npd.to_datetime('2025-03', format='%Y-%m').to_period('M')\n\nPeriod('2025-03', 'M')\n\n\n\n# Timedelta\npd.to_datetime('2025-05-13') - pd.to_datetime('2025-03-02')\n\nTimedelta('72 days 00:00:00')\n\n\n\n\n정규 날짜 시퀀스 생성\n\nPandas는 일정 간격의 날짜/시간 데이터를 생성하는 기능을 제공함\npd.date_range(), pd.period_range(), pd.timedelta_range() 함수\n\nfreq 인자를 통해 날짜 간격의 빈도(frequency) 지정 가능\n\n\n\n\n\n\n코드\n설명\n\n\n\n\nD\n일(day)\n\n\nW\n주(week)\n\n\nME\n월말(month end)\n\n\nQE\n분기말(quarer end)\n\n\nYE\n연말(year end)\n\n\nh\n시간(hour)\n\n\nmin\n분(minute)\n\n\ns\n초(second)\n\n\n\n\n# pd.date_range(): 하루씩 증가하는 날짜 시퀀스\npd.date_range('2025-03-02', periods=5, freq='D')\n\nDatetimeIndex(['2025-03-02', '2025-03-03', '2025-03-04', '2025-03-05',\n               '2025-03-06'],\n              dtype='datetime64[ns]', freq='D')\n\n\n\n# pd.date_range(): 일주일씩 증가하는 날짜 시퀀스(일요일 기준)\npd.date_range('2025-05-13', periods=5, freq='W')\n\nDatetimeIndex(['2025-05-18', '2025-05-25', '2025-06-01', '2025-06-08',\n               '2025-06-15'],\n              dtype='datetime64[ns]', freq='W-SUN')\n\n\n\n# pd.period_range(): 2025년 3월부터 시작하여 3개월 동안의 기간\npd.period_range('2025-03', periods=3, freq='M')\n\nPeriodIndex(['2025-03', '2025-04', '2025-05'], dtype='period[M]')\n\n\n\n# pd.timedelta_range(): 1시간 간격의 시간 델타 시퀀스\npd.timedelta_range(start='0s', periods=5, freq='h')\n\nTimedeltaIndex(['0 days 00:00:00', '0 days 01:00:00', '0 days 02:00:00',\n                '0 days 03:00:00', '0 days 04:00:00'],\n               dtype='timedelta64[ns]', freq='h')\n\n\n\n\n\n\n\n시계열 데이터를 인덱스로 설정하면, 시간 기반으로 데이터를 쉽게 필터링할 수 있음\n\n문자열 형태의 날짜를 인덱스 슬라이싱에 사용 가능\n예 : 연도(‘2025’), 연월(‘2025-01’), 연월일(‘2025-01-07’) 등\n\nDatetimeIndex 객체는 다음과 같은 속성을 제공\n\n.year, .month, .day, .hour, .minute, .second\n.month_name(), .day_name(), .dayofweek(0=월요일)\n\nsort_index() 메소드를 통해 날짜 인덱스를 기준으로 정렬 가능\n\n\n# 시계열 데이터 인덱스 설정\ndate_rng = pd.date_range(start='2024-12-20', end='2025-01-10', freq='D')\ndf = pd.DataFrame({'value': np.random.randint(0, 100, size=len(date_rng))}, index=date_rng)\nprint(df)\n\n            value\n2024-12-20     93\n2024-12-21     67\n2024-12-22     67\n2024-12-23     94\n2024-12-24     29\n2024-12-25     60\n2024-12-26     66\n2024-12-27     71\n2024-12-28     43\n2024-12-29     54\n2024-12-30     99\n2024-12-31     73\n2025-01-01     82\n2025-01-02     63\n2025-01-03      1\n2025-01-04     95\n2025-01-05      1\n2025-01-06      6\n2025-01-07     73\n2025-01-08     52\n2025-01-09     42\n2025-01-10     35\n\n\n\n# 날짜 기반 필터링1: 특정 연도 데이터\nprint(df.loc['2025'])\n\n            value\n2025-01-01     82\n2025-01-02     63\n2025-01-03      1\n2025-01-04     95\n2025-01-05      1\n2025-01-06      6\n2025-01-07     73\n2025-01-08     52\n2025-01-09     42\n2025-01-10     35\n\n\n\n# 날짜 기반 필터링2: 특정 날짜 이후 데이터\nprint(df.loc['2025-01-07':])\n\n            value\n2025-01-07     73\n2025-01-08     52\n2025-01-09     42\n2025-01-10     35\n\n\n\n# 날짜 기반 필터링2: 특정 날짜 범위 데이터\nprint(df.loc['2024-12-24':'2024-12-31'])\n\n            value\n2024-12-24     29\n2024-12-25     60\n2024-12-26     66\n2024-12-27     71\n2024-12-28     43\n2024-12-29     54\n2024-12-30     99\n2024-12-31     73\n\n\n\n# DatetimeIndex 속성1: 월(month)\nprint(df.index.month)\n\nIndex([12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1],\n      dtype='int32')\n\n\n\n# DatetimeIndex 속성2: 요일 이름\nprint(df.index.day_name())\n\nIndex(['Friday', 'Saturday', 'Sunday', 'Monday', 'Tuesday', 'Wednesday',\n       'Thursday', 'Friday', 'Saturday', 'Sunday', 'Monday', 'Tuesday',\n       'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', 'Monday',\n       'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n      dtype='object')\n\n\n\n# 날짜 인덱스 정렬: 내림차순\nprint(df.sort_index(ascending=False))\n\n            value\n2025-01-10     35\n2025-01-09     42\n2025-01-08     52\n2025-01-07     73\n2025-01-06      6\n2025-01-05      1\n2025-01-04     95\n2025-01-03      1\n2025-01-02     63\n2025-01-01     82\n2024-12-31     73\n2024-12-30     99\n2024-12-29     54\n2024-12-28     43\n2024-12-27     71\n2024-12-26     66\n2024-12-25     60\n2024-12-24     29\n2024-12-23     94\n2024-12-22     67\n2024-12-21     67\n2024-12-20     93\n\n\n\n\n\n\n\n리샘플링(resampling) : 시계열 데이터의 빈도를 변경하는 방법(예 : 월별 데이터 → 연간 데이터)\n시간 이동(time-shift) : 시계열 데이터를 시간 축을 기준으로 이동시키는 방법으로, 이전 시점의 데이터와 비교할 때 유용함\n롤링 윈도우(rolling windows): 일정한 기간을 기준으로 이동 평균 등을 방법으로, 주기적인 변동성을 관할할 때 유용함\n\n\n## 실습 데이터 : flights 데이터셋\nflights = sns.load_dataset(\"flights\")\n\n\nprint(flights.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 144 entries, 0 to 143\nData columns (total 3 columns):\n #   Column      Non-Null Count  Dtype   \n---  ------      --------------  -----   \n 0   year        144 non-null    int64   \n 1   month       144 non-null    category\n 2   passengers  144 non-null    int64   \ndtypes: category(1), int64(2)\nmemory usage: 2.9 KB\nNone\n\n\n\nprint(flights.head())\n\n   year month  passengers\n0  1949   Jan         112\n1  1949   Feb         118\n2  1949   Mar         132\n3  1949   Apr         129\n4  1949   May         121\n\n\n\n# 시계열 데이터 인덱스 설정\nflights['date'] = pd.to_datetime(flights['year'].astype(str) + '-' + flights['month'].astype(str), format='%Y-%b')\nflights.set_index('date', inplace=True)\nflights.drop(['year', 'month'], axis=1, inplace=True)\nprint(flights.head())\n\n            passengers\ndate                  \n1949-01-01         112\n1949-02-01         118\n1949-03-01         132\n1949-04-01         129\n1949-05-01         121\n\n\n\n# 리샘플링: 월별 데이터 → 연간 데이터(연도별 총합)\nannual_passengers = flights.resample('YE').sum()\nprint(annual_passengers)\n\n            passengers\ndate                  \n1949-12-31        1520\n1950-12-31        1676\n1951-12-31        2042\n1952-12-31        2364\n1953-12-31        2700\n1954-12-31        2867\n1955-12-31        3408\n1956-12-31        3939\n1957-12-31        4421\n1958-12-31        4572\n1959-12-31        5140\n1960-12-31        5714\n\n\n\nimport matplotlib.pyplot as plt\n\n\n# 리샘플링: 연간 데이터 시각화\nplt.figure(figsize=(5, 3))\nplt.plot(annual_passengers['passengers'])\nplt.title('Annual Total Passengers')\nplt.xlabel('Year')\nplt.ylabel('Number of Passengers')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n# 시간 이동: 직전 분기 대비 승객 수 증감률(%)\nquarterly = flights['passengers'].resample('QE').sum()\nprevious_quarter = quarterly.shift(1)\nchange_rate = (quarterly - previous_quarter) / previous_quarter * 100\n\nquarterly_df = pd.DataFrame({\n    'quarterly_passengers': quarterly,\n    'change_rate': change_rate\n})\nprint(quarterly_df)\n\n            quarterly_passengers  change_rate\ndate                                         \n1949-03-31                   362          NaN\n1949-06-30                   385     6.353591\n1949-09-30                   432    12.207792\n1949-12-31                   341   -21.064815\n1950-03-31                   382    12.023460\n1950-06-30                   409     7.068063\n1950-09-30                   498    21.760391\n1950-12-31                   387   -22.289157\n1951-03-31                   473    22.222222\n1951-06-30                   513     8.456660\n1951-09-30                   582    13.450292\n1951-12-31                   474   -18.556701\n1952-03-31                   544    14.767932\n1952-06-30                   582     6.985294\n1952-09-30                   681    17.010309\n1952-12-31                   557   -18.208517\n1953-03-31                   628    12.746858\n1953-06-30                   707    12.579618\n1953-09-30                   773     9.335219\n1953-12-31                   592   -23.415265\n1954-03-31                   627     5.912162\n1954-06-30                   725    15.629984\n1954-09-30                   854    17.793103\n1954-12-31                   661   -22.599532\n1955-03-31                   742    12.254160\n1955-06-30                   854    15.094340\n1955-09-30                  1023    19.789227\n1955-12-31                   789   -22.873900\n1956-03-31                   878    11.280101\n1956-06-30                  1005    14.464692\n1956-09-30                  1173    16.716418\n1956-12-31                   883   -24.722933\n1957-03-31                   972    10.079275\n1957-06-30                  1125    15.740741\n1957-09-30                  1336    18.755556\n1957-12-31                   988   -26.047904\n1958-03-31                  1020     3.238866\n1958-06-30                  1146    12.352941\n1958-09-30                  1400    22.164049\n1958-12-31                  1006   -28.142857\n1959-03-31                  1108    10.139165\n1959-06-30                  1288    16.245487\n1959-09-30                  1570    21.894410\n1959-12-31                  1174   -25.222930\n1960-03-31                  1227     4.514480\n1960-06-30                  1468    19.641402\n1960-09-30                  1736    18.256131\n1960-12-31                  1283   -26.094470\n\n\n\n# 시프팅: 직전 분기 대비 승객 수 증감률(%) 시각화\nplt.figure(figsize=(5, 3))\nplt.plot(quarterly_df['change_rate'])\nplt.title('Quarter-over-Quarter Change in Airline Passengers (%)')\nplt.xlabel('Quarter')\nplt.ylabel('Change Rate (%)')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n# 롤링 윈도우: 12개월 단순이동평균\nflights['moving_avg_12months'] = flights['passengers'].rolling(window=12).mean()\nprint(flights)\n\n            passengers  moving_avg_12months\ndate                                       \n1949-01-01         112                  NaN\n1949-02-01         118                  NaN\n1949-03-01         132                  NaN\n1949-04-01         129                  NaN\n1949-05-01         121                  NaN\n...                ...                  ...\n1960-08-01         606           463.333333\n1960-09-01         508           467.083333\n1960-10-01         461           471.583333\n1960-11-01         390           473.916667\n1960-12-01         432           476.166667\n\n[144 rows x 2 columns]\n\n\n\n# 롤링 윈도우: 12개월 단순이동평균 시각화\nplt.figure(figsize=(5, 3))\nplt.plot(flights['passengers'], label='Original Data')\nplt.plot(flights['moving_avg_12months'], label='12-Month Moving Average', color='orange')\nplt.title('Airline Passenger Trend with 12-Month Moving Average')\nplt.xlabel('Date')\nplt.ylabel('Number of Passengers')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n(과제) 시계열 데이터 처리 실습\n\nair_quality_no2_long.csv 데이터셋은 Pandas 공식 문서에서 제공하는 유럽 도시 대기 중 이산화질소(NO2) 농도 측정 자료이다.\n\n문제1. 날짜 정보(date.utc) 열을 datetime 형식으로 변환하고, 이를 인덱스로 설정하라.\n문제2. 2019년 5월에 속하는 데이터 중 월요일에 해당하는 데이터만 추출하라.\n문제3. 이산화질소 농도(value)의 주(week)별 최대값을 계산하라.\n\n\n\n\nyfinance 라이브러리를 통해 2023년 1월 1일부터 12월 31일까지의 Apple(AAPL) 일별 주가 데이터를 다운로드할 수 있다.\n\n문제4. 전일 종가(Close) 대비 당일 시가(Open)의 변동률이 3% 이상인 데이터를 추출하라.\n문제5. 종가(Close)에 대해 5일 이동평균과 10일 이동평균을 각각 계산한 후 시각화하라.\n\n\n\n# air_quality_no2_long.csv\nair = pd.read_csv(\"https://raw.githubusercontent.com/pandas-dev/pandas/main/doc/data/air_quality_no2_long.csv\")\n\n\n# 2023년 Apple 일별 주가 데이터\n# !pip install yfinance\n# import yfinance as yf\n# stock = yf.download(\"AAPL\", start=\"2023-01-01\", end=\"2023-12-31\")\n# stock.columns = stock.columns.droplevel(\"Ticker\")"
  },
  {
    "objectID": "5_class.html",
    "href": "5_class.html",
    "title": "5. 클래스",
    "section": "",
    "text": "객체지향 프로그래밍(Object-Oriented Programming; OOP)\n\n프로그램을 여러 개의 독립된 단위(객체)들의 모임으로 구성하는 프로그래밍 패러다임\n현실 세계에 존재하는 모든 것을 객체로 표현 → 프로그램이 더 직관적이고 이해하기 쉬워짐\n코드의 재사용성, 유지보수성, 확장성이 높아짐\n\n\n\n\n객체(object)\n\n현실 세계의 사물이나 개념을 코드로 구현한 것\n데이터를 저장하는 속성(attribute)과 기능을 수행하는 메소드(method)를 가짐\n(예) 은행계좌\n\n속성 : 잔액\n메소드 : 입금, 출금\n\n\n\n\n\n클래스(class)\n\n객체를 생성하기 위한 일종의 설계도(template)\n공통된 속성(attribute)과 메소드(method)를 가지는 객체들을 하나의 구조로 정의\n\n같은 클래스에서 만들어진 객체들은 구조와 동작 방식이 동일함\n\n클래스로부터 만들어지는 객체를 그 클래스의 인스턴스(instance)라 함\n(예) Account 클래스 → 여러 개의 은행계좌 객체를 생성할 수 있음"
  },
  {
    "objectID": "5_class.html#클래스와-객체",
    "href": "5_class.html#클래스와-객체",
    "title": "5. 클래스",
    "section": "",
    "text": "객체지향 프로그래밍(Object-Oriented Programming; OOP)\n\n프로그램을 여러 개의 독립된 단위(객체)들의 모임으로 구성하는 프로그래밍 패러다임\n현실 세계에 존재하는 모든 것을 객체로 표현 → 프로그램이 더 직관적이고 이해하기 쉬워짐\n코드의 재사용성, 유지보수성, 확장성이 높아짐\n\n\n\n\n객체(object)\n\n현실 세계의 사물이나 개념을 코드로 구현한 것\n데이터를 저장하는 속성(attribute)과 기능을 수행하는 메소드(method)를 가짐\n(예) 은행계좌\n\n속성 : 잔액\n메소드 : 입금, 출금\n\n\n\n\n\n클래스(class)\n\n객체를 생성하기 위한 일종의 설계도(template)\n공통된 속성(attribute)과 메소드(method)를 가지는 객체들을 하나의 구조로 정의\n\n같은 클래스에서 만들어진 객체들은 구조와 동작 방식이 동일함\n\n클래스로부터 만들어지는 객체를 그 클래스의 인스턴스(instance)라 함\n(예) Account 클래스 → 여러 개의 은행계좌 객체를 생성할 수 있음"
  },
  {
    "objectID": "5_class.html#클래스-정의와-인스턴스-구성",
    "href": "5_class.html#클래스-정의와-인스턴스-구성",
    "title": "5. 클래스",
    "section": "5.2. 클래스 정의와 인스턴스 구성",
    "text": "5.2. 클래스 정의와 인스턴스 구성\n\n클래스 정의\n\nclass 키워드를 사용하여 정의함\n클래스 이름은 일반적으로 대문자로 시작(예 : Account, Student)\n클래스 본문에는 속성(변수)와 메소드(함수)를 정의함\n\n\n\n\n생성자 메소드 __init__()\n\n인스턴스가 생성될 때 자동으로 호출되는 특별한 메소드\n인스턴스마다 고유한 속성(인스턴스 변수)을 초기화하는 데 주로 사용됨\n인스턴스 변수는 __init__() 내부에서 self.변수 이름 형태로 정의되어 각 인스턴스마다 독립적인 값을 가짐\n첫 번째 매개변수는 항상 self로, 생성된 인스턴스 자신을 가리킴\n\n\n\n\n\n\n\n\n\n구분\n설명\n\n\n\n\n인스턴스 변수\n- 메소드 내부에서 self.변수이름 형태로 정의 - 인스턴스마다 독립적인 값을 가짐\n\n\n인스턴스 메소드\n- 클래스 내부에 정의된 함수 - 첫 번째 매개변수로 self를 사용하여 해당 인스턴스에 접근함 - 인스턴스를 통해 호출됨\n\n\n\n\n## 클래스 정의1 : 은행계좌\n# 잔액의 초기값은 항상 0으로 설정\nclass Account:\n    # 생성자 메소드\n    def __init__(self):                      # 첫 번째 매개변수는 반드시 self여야 함\n        self.balance = 0                     # (속성) 잔액, 인스턴스마다 독립적\n\n    # (메소드) 입금\n    def deposit(self, amount):               # 첫 번째 매개변수는 반드시 self여야 함\n        self.balance += amount               # 인스턴스 변수에 접근하기 위해 self.balance 사용\n        return self.balance\n\n    # (메소드) 출금\n    def withdraw(self, amount):\n        self.balance -= amount\n        return self.balance\n\n\n# 인스턴스 생성\nmy_acc = Account()\n\n\n# 인스턴스 속성 확인 : 잔액\nprint(my_acc.balance)\n\n0\n\n\n\n# 인스턴스 메소드 사용1 : 입금\nprint(my_acc.deposit(10000))\n\n10000\n\n\n\n# 인스턴스 메소드 사용2 : 출금\nprint(my_acc.withdraw(3000))\n\n7000\n\n\n\n# 인스턴스 속성 확인 : 잔액\nprint(my_acc.balance)\n\n7000\n\n\n\n## 클래스 정의2 : 은행계좌\n# 잔액의 초기값을 인스턴스를 생성할 때 직접 입력받아 설정(입력히지 않으면 0)\nclass Account:\n    # 생성자 메소드\n    def __init__(self, amount=0):\n        self.balance = amount                # (속성) 잔액\n\n    def deposit(self, amount):               # (메소드) 입금\n        self.balance += amount\n        return self.balance\n        \n    def withdraw(self, amount):              # (메소드) 출금\n        self.balance -= amount\n        return self.balance\n\n\n# 인스턴스 생성 및 속성 확인\nmy_acc = Account(50000)\nprint(my_acc.balance)\n\n50000"
  },
  {
    "objectID": "5_class.html#매직-메소드",
    "href": "5_class.html#매직-메소드",
    "title": "5. 클래스",
    "section": "5.3. 매직 메소드",
    "text": "5.3. 매직 메소드\n\n5.3.1. 매직 메소드 소개\n\n매직 메소드(magic method)\n\n이름 앞뒤에 ___(double underscore)가 붙는 특별한 메소드\nPython 내부 동작과 자동으로 연결되며, 다양한 상황에서 자동 호출됨\n\n(예) print(인스턴스) → __str__() 호출\n(예) for x in 인스턴스 → __iter__() 호출\n\n오버라이드하면 내가 정의한 클래스가 Python 기본 동작과 자연스럽게 연동됨\n클래스 사용성과 직관성을 크게 향상시킴\n\n\n\n\n\n5.3.2. 문자열 표현 메소드\n\n__str__() 메소드\n\n인스턴스를 print()하거나 str()로 변환할 때 자동으로 호출되는 메소드\n인스턴스의 상태를 사람이 읽기 쉬운 문자열 형태로 반환함\n디버깅이나 결과 출력 시 인스턴스 정보를 명확히 확인할 수 있도록 도와줌\n\n\n\n\n__repr__() 메소드\n\n인스턴스를 대화형 환경에서 출력하거나 repr()로 변환할 때 자동으로 호출되는 메소드\n인스턴스의 상태를 개발자가 이해하기 쉽고, 가능하면 인스턴스 재생성이 가능한 정확한 문자열 형태로 반환함\n\nrepr() 함수 : 인스턴스의 표준 문자열 표현을 반환하며, eval() 함수에 전달 시 일반적으로 원래 인스턴스가 생성됨\n일반적으로 eval(repr(obj)) == obj이 성립하도록 설계함\n\n주로 디버깅, 로깅, 인스턴스 재생성 코드 출력 등에 유용하게 사용됨\n__str__() 메소드가 정의되지 않은 경우 __repr__()의 반환값이 대신 사용됨(반대는 성립 ×)\n\n\n\n## 클래스 정의 : 책\nclass Book:\n    def __init__(self, title, author, price):\n        self.title = title                   # (속성) 책 제목\n        self.author = author                 # (속성) 저자 이름\n        self.price = price                   # (속성) 가격\n\n    # 가격 할인 적용 후 price 값 변경(소수점 이하 버림)\n    def apply_discount(self, percent):       # (메소드) 가격 할인 적용 (percent : 0~100)\n        self.price = int(self.price * (1 - percent / 100))\n\n    # 사람이 읽기 좋은 문자열 표현\n    def __str__(self):\n        return f\"Book(title: '{self.title}', author: '{self.author}', price: {self.price}원)\"\n\n    # 개발자용 문자열 표현\n    def __repr__(self):\n        return f\"Book('{self.title}', '{self.author}', {self.price})\"\n\n\n# 인스턴스 생성\nmy_book = Book(\"Python Programming\", \"Park\", 30000)\n\n\n# 인스턴스를 문자열로 출력1 : __str__() 메소드 자동 호출\nprint(my_book)\n\nBook(title: 'Python Programming', author: 'Park', price: 30000원)\n\n\n\n# 인스턴스를 문자열로 출력2 : __repr__() 메소드 자동 호출\nmy_book\n\nBook('Python Programming', 'Park', 30000)\n\n\n\n# 인스턴스를 문자열로 출력3 : __repr__() 메소드 자동 호출\nrepr(my_book)\n\n\"Book('Python Programming', 'Park', 30000)\"\n\n\n\n# eval() 함수로 repr() 결과를 실행하여 새로운 인스턴스 생성\nmy_book.apply_discount(10)\nnew_book = eval(repr(my_book))\nprint(new_book)\n\nBook(title: 'Python Programming', author: 'Park', price: 27000원)\n\n\n\n\n\n5.3.3. 시퀀스 동작 메소드\n\n리스트, 튜플처럼 순서가 존재하는 자료형(sequence data type)에서 동작하는 매직 메소드\n사용자 정의 클래스에 시퀀스 특성을 부여하며, len(), 인덱싱, 반복문 등과 자연스럽게 연동됨\n\n\n\n\n\n\n\n\n\n유형\n설명\n\n\n\n\n__len__() 메소드\n- 인스턴스를 len()로 변환할 때 자동으로 호출되는 메소드 - 인스턴스가 포함하고 있는 원소의 개수를 정수형으로 반환함\n\n\n__getitem__() 메소드\n- 인스턴스를 인덱싱(인스턴스[index])할 때 자동으로 호출되는 메소드 - 특정 위치의 값을 반환하며, 슬라이싱 처리도 가능하게 만들 수 있음\n\n\n__iter__() 메소드\n- for 문에서 사용할 수 있는 iterable 객체를 반환하는 메소드 - 일반적으로 return iter(내부_시퀀스) 형태로 구현함\n\n\n\n\n## 클래스 정의 : 음악 플레이리스트\nclass Playlist:\n    def __init__(self, name, songs):\n        self.name = name                     # (속성) 플레이리스트 이름\n        self.songs = songs                   # (속성) 노래 목록 (리스트)\n        \n    def add_song(self, song):                # (메소드) 노래 추가\n        self.songs.append(song)\n\n    def __str__(self):\n        return f\"Playlist '{self.name}' with {len(self)} songs\"\n\n    def __repr__(self):\n        return f\"Playlist('{self.name}', {self.songs})\"\n\n    # 포함된 원소의 개수 반환\n    def __len__(self):\n        return len(self.songs)\n\n    # 특정 위치의 원소를 반환 (인덱싱 가능)\n    def __getitem__(self, index):\n        return self.songs[index]\n\n    # iterable 객체 반환 (for 문 등에서 사용 가능)\n    def __iter__(self):\n        return iter(self.songs)\n\n\n# 인스턴스 생성\nmy_playlist = Playlist(\"My Favorites\", [\"Hype Boy\", \"APT.\", \"Mantra\"])\n\n\n# 원소의 개수 : __len__() 메소드 자동 호출\nlen(my_playlist)\n\n3\n\n\n\n# 인덱싱 : __getitem__() 메소드 자동 호출\nmy_playlist[1]\n\n'APT.'\n\n\n\n# for 문에서 iterable 객체 사용 : __iter__() 메소드 자동 호출\nfor song in my_playlist:\n    print(song)\n\nHype Boy\nAPT.\nMantra\n\n\n\n# 인스턴스 메소드 사용 : 노래 추가\nmy_playlist.add_song(\"Ditto\")\nmy_playlist\n\nPlaylist('My Favorites', ['Hype Boy', 'APT.', 'Mantra', 'Ditto'])\n\n\n\n\n\n5.3.4. 호출 동작 메소드\n\n__call__() 메소드\n\n인스턴스를 함수처럼 호출할 때 자동으로 실행되는 메소드\n인스턴스() 형태로 호출되며, 내부에서 필요한 로직을 자유롭게 구현 가능\n사용자 정의 클래스에 유연하고 직관적인 기능을 부여할 때 유용함\n\n(예) 파라미터를 받아 계산 수행, 누적 처리, 조건 평가 등\n\n\n\n\n## 함수 정의1 : 누적 처리\ndef add_count(count, step=1):\n    count += step\n    return count\n\n# 누적값은 함수 외부에서 직접 관리해야 함\n# → 함수는 상태를 기억하지 않으므로, 매번 결과를 외부 변수에 저장해야 함\nc = 0\nc = add_count(c)                             # 1\nc = add_count(c, 2)                          # 3\nc = add_count(c)                             # 4\nprint(c)\n\n4\n\n\n\n## 클래스 정의1 : 누적 처리\n# 클래스는 인스턴스 변수를 통해 상태(state)를 내부에 저장함\n# → 상태를 직접 조작하지 않아도 내부에서 자동으로 관리됨\n#   인스턴스마다 독립적인 값을 유지하므로, 여러 개의 상태를 동시에 관리하기 편함\nclass Counter:\n    def __init__(self):\n        self.count = 0                       # (속성) 현재값(누적값)\n\n    # 인스턴스를 함수처럼 호출 가능하게 함\n    def __call__(self, step=1):\n        self.count += step\n        return self.count\n\n\n# 인스턴스 생성\nc1 = Counter()\nc2 = Counter()\n\n\n# 인스턴스를 함수처럼 호출1 : __call__() 메소드 자동 호출\nc1()\n\n1\n\n\n\n# 인스턴스를 함수처럼 호출2 : __call__() 메소드 자동 호출\nc1(5)\n\n6\n\n\n\n# 인스턴스를 함수처럼 호출3 : __call__() 메소드 자동 호출\n# 인스턴스마다 독립적인 값 유지\nc2()\n\n1\n\n\n\n## 클래스 정의2 : 조건 평가\n# 클래스는 인스턴스 변수를 통해 상태(state)를 내부에 저장하고,\n# 관련 기능을 하나의 객체에 통합하여 확장성과 재사용성을 높일 수 있음\nclass PassCounter:\n    def __init__(self, threshold):\n        self.threshold = threshold           # (속성) 기준값\n        self.count = 0                       # (속성) 조건 통과 횟수\n\n    def __call__(self, value):\n        # 값이 기준을 넘으면 count 누적\n        if value &gt;= self.threshold:\n            self.count += 1\n            return True\n        return False\n\n    def reset(self):                         # (메소드) 조건 통과 횟수 초기화\n        self.count = 0\n\n\n# 기준값이 70인 인스턴스 생성\npc = PassCounter(70)\n\n\n# 인스턴스를 함수처럼 호출 : __call__() 메소드 자동 호출\npc(85)                                       # True\npc(60)                                       # False\npc(75)                                       # True\npc.count\n\n2\n\n\n\n# 인스턴스 메소드 사용\npc.reset()\npc.count\n\n0"
  },
  {
    "objectID": "5_class.html#클래스와-리스트",
    "href": "5_class.html#클래스와-리스트",
    "title": "5. 클래스",
    "section": "5.4. 클래스와 리스트",
    "text": "5.4. 클래스와 리스트\n\n여러 개의 인스턴스를 관리하기 위해 리스트를 사용하면 효율적임\n\n인덱스를 사용하여 특정 인스턴스에 접근 가능\n반복문을 통해 리스트 내 모든 인스턴스에 접근하여 메소드를 호출하거나 속성을 조회할 수 있음\n\n같은 클래스를 기반으로 다양한 인스턴스를 생성하고, 이를 리스트로 묶으면 프로그램 구조가 더 유연하고 확장 가능해짐\n\n\n## 클래스 정의 : 은행계좌\nclass Account:\n    def __init__(self, account_number, owner, amount=0):\n        self.account_number = account_number # (속성) 계좌 번호\n        self.owner = owner                   # (속성) 계좌 소유주\n        self.balance = amount                # (속성) 잔액\n        self.history = []                    # (속성) 거래 내역\n\n    def deposit(self, amount):               # (메소드) 입금\n        self.balance += amount\n        self.history.append(f\"입금: {amount}\")\n        return self.balance\n\n    def withdraw(self, amount):              # (메소드) 출금\n        self.balance -= amount\n        self.history.append(f\"출금: {amount}\")\n        return self.balance\n\n    \n    # 매직 메소드 ----------------------------------------\n    def __str__(self):\n        return f\"현재 잔액은 {self.balance}원입니다.\"\n\n    def __repr__(self):\n        return f\"Account(balance={self.balance})\"\n    \n    def __len__(self):\n        return len(self.history)             # 거래 횟수 확인\n\n    def __getitem__(self, index):\n        return self.history[index]           # 인덱스 활용 → 거래 내역 접근\n\n    def __iter__(self):\n        return iter(self.history)            # 거래 내역 반복 가능\n\n    def __call__(self, amount):              # 함수처럼 호출 → 자동 입금 처리\n        return self.deposit(amount)\n\n\n# 여러 계좌를 리스트로 관리\naccounts = [\n    Account(\"123-01\", \"Kim\", 12000),\n    Account(\"123-02\", \"Lee\", 45000),\n    Account(\"123-03\", \"Park\", 33000),\n    Account(\"123-04\", \"Park\", 70000)\n]\n\n\n# 전체 계좌 잔액 출력\nfor acc in accounts:\n    print(f\"{acc.owner}님의 {acc.account_number} 계좌 → {acc}\")\n\nKim님의 123-01 계좌 → 현재 잔액은 12000원입니다.\nLee님의 123-02 계좌 → 현재 잔액은 45000원입니다.\nPark님의 123-03 계좌 → 현재 잔액은 33000원입니다.\nPark님의 123-04 계좌 → 현재 잔액은 70000원입니다.\n\n\n\n# 모든 계좌에 5,000원 입금\nfor acc in accounts:\n    acc.deposit(5000)\n\n\n# 모든 계좌의 최종 잔액 출력\nprint(\"입금 후 잔액:\")\nfor acc in accounts:\n    print(f\"{acc.owner}님의 계좌 → {acc}\")\n\n입금 후 잔액:\nKim님의 계좌 → 현재 잔액은 17000원입니다.\nLee님의 계좌 → 현재 잔액은 50000원입니다.\nPark님의 계좌 → 현재 잔액은 38000원입니다.\nPark님의 계좌 → 현재 잔액은 75000원입니다.\n\n\n\n# 특정 인덱스로 접근하여 사용\nprint(\"가장 첫 번째 계좌 소유주:\", accounts[0].owner)\n\n가장 첫 번째 계좌 소유주: Kim\n\n\n\n# 계좌 번호가 123-03인 계좌 리스트\nmy_acc = [acc for acc in accounts if acc.account_number == \"123-03\"]\nmy_acc\n\n[Account(balance=38000)]\n\n\n\n# 잔액이 5만원 이상인 계좌 리스트\nvip_acc = [acc for acc in accounts if acc.balance &gt;= 50000]\nvip_names = [acc.owner for acc in vip_acc]\nvip_names\n\n['Lee', 'Park']\n\n\n\n# 리스트 내 모든 계좌의 잔액 합계\ntotal_balance = sum(acc.balance for acc in accounts)\nprint(f\"전체 잔액 합계: {total_balance}원\")\n\n전체 잔액 합계: 180000원\n\n\n\n(과제) 클래스와 리스트 실습\n\nPlaylist 클래스 인스턴스들이 담긴 리스트 mylists를 활용하여 다음 문제를 해결하라.\n\n문제1. playlists 리스트에서 플레이리스트 이름이 “Pop Hits”인 인스턴스를 찾아서 출력하라.\n문제2. 모든 플레이리스트의 총 노래 개수를 출력하라.\n문제3. “Jazz Vibes” 플레이리스트에 “Autumn Leaves” 노래를 추가하고, 노래 목록을 출력하라.\n문제4. 노래 개수가 3개 이상인 플레이리스트만 별도의 리스트로 만들어 출력하라.\n문제5. 모든 플레이리스트의 첫 번째 노래 제목만 모아서 리스트로 만들어 출력하라.\n\n\n\n## 클래스 정의 : 음악 플레이리스트\nclass Playlist:\n    def __init__(self, name, songs=None):\n        self.name = name                     # (속성) 플레이리스트 이름\n        self.songs = songs if songs else []  # (속성) 노래 목록 (리스트)\n        \n    def add_song(self, song):                # (메소드) 노래 추가\n        self.songs.append(song)\n\n    def remove_song(self, song):             # (메소드) 노래 삭제 (있으면)\n        if song in self.songs:\n            self.songs.remove(song)\n\n    def clear(self):                         # (메소드) 플레이리스트 초기화\n        self.songs.clear()\n\n    def __str__(self):\n        return f\"Playlist '{self.name}' with {len(self)} songs\"\n\n    def __repr__(self):\n        return f\"Playlist('{self.name}', {self.songs})\"\n\n    def __len__(self):\n        return len(self.songs)\n\n    def __getitem__(self, index):\n        return self.songs[index]\n\n    def __iter__(self):\n        return iter(self.songs)\n\n    def __call__(self):                      # 함수처럼 호출 → 노래 제목 리스트 반환\n        return [song for song in self.songs]\n\n\n# Playlist 인스턴스 3개 생성\nplaylist1 = Playlist(\"Rock Classics\", [\"Bohemian Rhapsody\", \"Stairway to Heaven\", \"Hotel California\"])\nplaylist2 = Playlist(\"Pop Hits\", [\"Bad Guy\", \"Shape of You\", \"Blinding Lights\"])\nplaylist3 = Playlist(\"Jazz Vibes\", [\"So What\", \"Take Five\", \"Blue in Green\"])\n\n# Playlist 인스턴스 리스트\nmylists = [playlist1, playlist2, playlist3]"
  },
  {
    "objectID": "5_class.html#정보-은닉과-접근-제어",
    "href": "5_class.html#정보-은닉과-접근-제어",
    "title": "5. 클래스",
    "section": "5.5. 정보 은닉과 접근 제어",
    "text": "5.5. 정보 은닉과 접근 제어\n\n클래스는 내부 데이터를 직접 노출하지 않고, 메소드를 통해 인스턴스 상태를 보호함\n외부에서 속성에 무분별하게 접근하거나 변경하는 것을 막기 위해 접근 제어를 사용함\n이러한 개념을 캡슐화(encapsulation)라고 하며, 객체지향 프로그래밍의 핵심 원칙 중 하나임\n\n데이터 보호, 유지보수성 향상, 인터페이스의 안전성 확보에 기여\n\n\n\n\n\n\n\n\n\n\n\n접근 수준\n사용\n설명\n\n\n\n\npublic\nself.value, method()\n외부에서 자유롭게 접근 가능\n\n\nprotected\n_value, _method()\n관례상 내부 전용, 하위 클래스에서 접근 가능\n\n\nprivate\n__value, __method()\n클래스 외부에서 직접 접근 불가(name mangling 적용)\n\n\n\n\n\nproteced와 private는 문법적으로 엄격히 강제되지는 않으며, 개발자 간의 약속과 안전성 목적에서 사용됨\nprivate는 클래스 내부에서만 접근할 수 있도록 name mangling이 적용됨\n\n이름이 _클래스 이름__속성 이름 형태로 자동 변경되어 외부 접근을 어렵게 함\n\n외부에서 private 속성에 접근해야 할 경우 getter, setter 메소드를 통해 우회적으로 접근함\n\ngetter : 속성 값을 읽는 메소드로, 일반적으로 get_속성 이름() 형태 사용\nsetter : 속성 값을 설정하는 메소드로, 일반적으로 set_속성 이름(값) 형태 사용\n\n(예) 음수 값 입력을 막거나, 주민번호와 같은 민감한 정보 보호에 활용\n\n\n## 클래스 정의 : 학생 정보\nclass Student:\n    def __init__(self, name, age, student_id):\n        self.name = name                     # (속성) 이름, public : 자유 접근\n        self._age = age                      # (속성) 연령, protected : 내부/상속용\n        self.__student_id = student_id       # (속성) 학번, private : 외부 접근 차단\n\n    # getter 메소드\n    def get_student_id(self):\n        return self.__student_id\n\n    # setter 메소드\n    def set_student_id(self, new_id):\n        if isinstance(new_id, str) and new_id.startswith(\"S\"):\n            self.__student_id = new_id\n        else:\n            print(\"학번은 'S'로 시작하는 문자열이어야 합니다.\")\n\n\n# 인스턴스 생성\ns = Student(\"홍길동\", 20, \"S20250605\")\n\n\n# public 속성 접근\ns.name\n\n'홍길동'\n\n\n\n# protected 속성 접근 : 문법적으로는 가능하나, 관례상 외부에서 접근하지 않음\ns._age\n\n20\n\n\n\n# protected 속성 수정 : 문법적으로 가능하나, 사용 권장되지 않음\ns._age = 22\ns._age\n\n22\n\n\n\n# private 속성 접근 → 직접 접근 불가\n#s.__student_id                              # Error!\n\n\n# private 속성 접근 : name mangling 방식으로 우회 가능하나, 절대 사용 권장하지 않음\ns._Student__student_id\n\n'S20250605'\n\n\n\n# private 속성 수정 : 우회 가능하나, 절대 사용 권장하지 않음 → 내부 구현 침해\ns._Student__student_id = \"S20250302\"\ns._Student__student_id\n\n'S20250302'\n\n\n\n# private 속성 접근 : getter 메소드 사용\ns.get_student_id()\n\n'S20250302'\n\n\n\n# private 속성 수정1 : setter 메소드 사용\ns.set_student_id(\"A20250612\")\n\n학번은 'S'로 시작하는 문자열이어야 합니다.\n\n\n\n# private 속성 수정2 : setter 메소드 사용\ns.set_student_id(\"S20250612\")\n\n\n# private 속성 접근 : getter 메소드 사용\ns.get_student_id()\n\n'S20250612'\n\n\n\n## 클래스 : 비밀번호 검사기\n# private와 __call__() 매직 메소드를 이용하여\n# 내부 로직은 숨기고, 외부에는 간단한 인터페이스만 제공함\nclass PasswordChecker:\n    def __init__(self, password):\n        self.__password = password           # (속성) 비밀번호, private\n\n    # 비밀번호 길이 8 이상, 숫자 포함 여부 검사\n    # → 복잡한 검증 로직은 숨기고, 인스턴스를 함수처럼 호출하여 사용 가능\n    def __call__(self):        \n        has_number = any(char.isdigit() for char in self.__password)\n        is_valid = len(self.__password) &gt;= 8 and has_number\n        return is_valid\n\n    # (메소드) 비밀번호 직접 노출 방지\n    def show_password(self):\n        return \"비밀번호는 볼 수 없습니다.\"\n\n\nchecker = PasswordChecker(\"mypassword123\")\nprint(checker())\nprint(checker.show_password())\n\nTrue\n비밀번호는 볼 수 없습니다.\n\n\n\n(과제) 정보 은닉과 접근 제어 실습\n\n다음 조건을 만족하는 은행계좌 클래스 Account를 작성하라.\n\n속성(attributes)\n\n계좌 번호, 계좌 소유주 : 한 번 설정되면 변경할 수 없음\n잔액, 거래 내역 : 입금, 출금을 통해서만 변경 가능\n\n메소드(method)\n\n입금, 출금, 현재 잔액 확인, 거래 내역 확인, 계좌 번호 확인, 계좌 소유주 확인\n단, 1회 출금 금액은 1,000만원을 초과할 수 없음"
  },
  {
    "objectID": "5_class.html#클래스-상속",
    "href": "5_class.html#클래스-상속",
    "title": "5. 클래스",
    "section": "5.6. 클래스 상속",
    "text": "5.6. 클래스 상속\n\n5.6.1. 클래스 상속 소개\n\n클래스 상속(class inheritance)\n\n기존 클래스의 속성과 메소드를 물려받아 새로운 클래스를 만드는 개념\n코드 재사용과 유지보수성 향상에 매우 유리함\n자식 클래스는 부모 클래스의 모든 특성을 물려받으며, 필요에 따라 새로운 속성이나 메소드를 추가할 수 있음\n\n부모 클래스의 속성이나 메소드는 super() 함수로 호출함\n부모 클래스의 메소드를 자식 클래스에서 다시 정의하는 것을 오버라이딩(overriding)이라고 함\n\n공통된 기능은 부모 클래스에 정의하고, 각각의 차이는 자식 클래스에서 구현하여 코드의 구조화와 확장성을 도모함\n\n\n\n\n\n\n\n\n\n\n구분\n설명\n\n\n\n\n부모 클래스(parent class, superclass)\n상속해주는 기존 클래스\n\n\n자식 클래스(child class, subclass)\n상속받아 새롭게 정의되는 클래스\n\n\n단일 상속(single inheritance)\n하나의 부모 클래스로부터 상속받는 경우\n\n\n다중 상속(multiple inheritance)\n둘 이상의 부모 클래스로부터 상속받는 경우\n\n\n\n\n\n(예) 자동차 클래스 Car 구조\n\n공통 특성 : 모델명, 색상, 제조사, 시동 켜기 기능, 시동 끄기 기능\n가솔린차 GasolineCar : 연료 탱크 용량, 주유 기능\n디젤차 DieselCar : 연료 탱크 용량, 주유 기능, 배출가스 측정 기능\n전기차 ElectricCar : 배터리 용량, 충전 기능\n\n\n\n\n\nClass Parent:  　　# 부모 클래스 정의   Class Child(Parent):  　　# 자식 클래스 정의, 부모 클래스 상속 \n\n\n## 부모 클래스 : Car\nclass Car:\n    def __init__(self, model, color, manufacturer):\n        self.model = model                                  # (속성) 모델명\n        self.color = color                                  # (속성) 색상\n        self.manufacturer = manufacturer                    # (속성) 제조사\n\n    \n    def start_engine(self):                                 # (메소드) 시동 켜기\n        print(f\"{self.model}의 시동을 켭니다.\")\n    \n    def stop_engine(self):                                  # (메소드) 시동 끄기\n        print(f\"{self.model}의 시동을 끕니다.\")\n\n\n## 자식 클래스1 : GasolineCar\nclass GasolineCar(Car):\n    def __init__(self, model, color, manufacturer, fuel_tank_capacity):\n        super().__init__(model, color, manufacturer)        # (속성) 부모 클래스 속성 상속\n        self.fuel_tank_capacity = fuel_tank_capacity        # (속성) 연료 탱크 용량, 가솔린차 고유 속성\n\n    \n    def refuel(self):                                       # (메소드) 주유, 가솔린차 고유 메소드\n        print(f\"{self.model}에 주유합니다. 탱크 용량: {self.fuel_tank_capacity}L\")\n\n\n## 자식 클래스2 : DieselCar\nclass DieselCar(Car):\n    def __init__(self, model, color, manufacturer, fuel_tank_capacity):\n        super().__init__(model, color, manufacturer)        # (속성) 부모 클래스 속성 상속\n        self.fuel_tank_capacity = fuel_tank_capacity        # (속성) 연료 탱크 용량, 디젤차 고유 속성\n\n    \n    def refuel(self):                                       # (메소드) 주유, 디젤차 고유 메소드\n        print(f\"{self.model}에 디젤 주유합니다. 탱크 용량: {self.fuel_tank_capacity}L\")\n    \n    def check_emission(self):                               # (메소드) 배출가스 측정, 디젤차 고유 메소드\n        print(f\"{self.model}의 배출가스를 측정합니다.\")\n\n\n## 자식 클래스3 : ElectricCar\nclass ElectricCar(Car):\n    def __init__(self, model, color, manufacturer, battery_capacity):\n        super().__init__(model, color, manufacturer)        # (속성) 부모 클래스 속성 상속\n        self.battery_capacity = battery_capacity            # (속성) 배터리 용량, 전기차 고유 속성\n\n    def charge(self):                                       # (메소드) 충전, 전기차 고유 메소드\n        print(f\"{self.model}을 충전합니다. 배터리 용량: {self.battery_capacity}kWh\")\n\n\n# 인스턴스 생성\ngas_car = GasolineCar(\"Car A\", \"Red\", \"Manufacturer A\", 50)\ndiesel_car = DieselCar(\"Car B\", \"Blue\", \"Manufacturer B\", 60)\nelectric_car = ElectricCar(\"Car C\", \"White\", \"Manufacturer C\", 40)\n\n\n# 인스턴스 메소드 사용1\ngas_car.start_engine()                       # 부모 클래스 메소드\ngas_car.refuel()                             # 자식 클래스 고유 메소드\ngas_car.stop_engine()                        # 부모 클래스 메소드\n\nCar A의 시동을 켭니다.\nCar A에 주유합니다. 탱크 용량: 50L\nCar A의 시동을 끕니다.\n\n\n\n# 인스턴스 메소드 사용2\ndiesel_car.start_engine()\ndiesel_car.refuel()\ndiesel_car.check_emission()\ndiesel_car.stop_engine()\n\nCar B의 시동을 켭니다.\nCar B에 디젤 주유합니다. 탱크 용량: 60L\nCar B의 배출가스를 측정합니다.\nCar B의 시동을 끕니다.\n\n\n\n# 인스턴스 메소드 사용3\nelectric_car.start_engine()\nelectric_car.charge()\nelectric_car.stop_engine()\n\nCar C의 시동을 켭니다.\nCar C을 충전합니다. 배터리 용량: 40kWh\nCar C의 시동을 끕니다.\n\n\n\n## 보조 클래스(Mixin): 원격 시동 기능\n# Mixmin 클래스 : 독립적인 기능을 다른 클래스에 추가하기 위해 설계된 클래스\n# 자체로는 완전한 객체가 되지 않으며, 다른 클래스와 함께 상속되어 기능을 보완함\nclass RemoteControlMixin:\n    def remote_start(self):\n        print(f\"{self.model}의 시동을 원격으로 켭니다.\")\n\n    def remote_stop(self):\n        print(f\"{self.model}의 시동을 원격으로 끕니다.\")\n\n\n## 다중 상속 자식 클래스: 가솔린차 + 원격 제어 기능\n# 다중 상속 : 괄호 안에 부모 클래스를 쉼표로 나열하여 순서대로 상속함\nclass RemoteGasolineCar(Car, RemoteControlMixin):\n    def __init__(self, model, color, manufacturer, fuel_tank_capacity):\n        super().__init__(model, color, manufacturer)\n        self.fuel_tank_capacity = fuel_tank_capacity\n\n    def fuel_info(self):\n        print(f\"{self.model}는 가솔린차이며, 연료 탱크 용량은 {self.fuel_tank_capacity}L입니다.\")\n\n\n# 인스턴스 생성 및 메소드 사용\ncar = RemoteGasolineCar(\"Car D\", \"Black\", \"Manufacturer D\", 55)\n\ncar.start_engine()                           # Car 클래스 메소드\ncar.remote_start()                           # RemoteControlMixin 클래스 메소드\ncar.fuel_info()                              # 자식 클래스 고유 메소드\n\nCar D의 시동을 켭니다.\nCar D의 시동을 원격으로 켭니다.\nCar D는 가솔린차이며, 연료 탱크 용량은 55L입니다.\n\n\n\n\n\n5.6.2. 메소드 오버라이딩\n\n자식 클래스가 부모 클래스의 메소드를 재정의하여 다르게 동작하도록 만드는 것\n자식 클래스의 역할과 동작 방식에 맞게 메소드를 새롭게 구현할 수 있음\n\n메소드 이름과 매개변수 구조는 부모 클래스와 동일해야 함\n\n오버라이딩은 상속의 유연성과 확장성을 높여줌\n\n\n## 부모 클래스 : 동물\nclass Animal:\n    def __init__(self, name):\n        self.name = name                     # (속성) 동물 이름\n\n    def speak(self):                         # (메소드) 소리 내기\n        print(f\"{self.name}가 소리를 냅니다.\")\n\n\n## 자식 클래스 : 개\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        super().__init__(name)               # (속성) 부모 클래스 속성 상속\n        self.breed = breed                   # (속성) 품종, 개 고유 속성\n    \n    def speak(self):                         # (메소드 오버라이딩) 소리 내기 - 개 고유 동작(멍멍)\n        super().speak()                      # 부모 클래스의 sound 메소드 호출\n        print(f\"{self.name}는 멍멍 짖습니다.\")\n\n\n# 인스턴스 생성 및 메소드 사용\ndog = Dog(\"구름이\", \"말티즈\")\ndog.speak()\n\n구름이가 소리를 냅니다.\n구름이는 멍멍 짖습니다."
  }
]