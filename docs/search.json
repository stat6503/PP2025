[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python프로그래밍",
    "section": "",
    "text": "본 강의에서는 파이썬을 이용한 프로그래밍 방법을 학습하고, 데이터 분석에 필수적인 몇 가지 패키지를 소개한다.\n또한 클래스와 객체지향적 프로그래밍의 개념을 설명한다."
  },
  {
    "objectID": "index.html#강의-소개",
    "href": "index.html#강의-소개",
    "title": "Python프로그래밍",
    "section": "",
    "text": "본 강의에서는 파이썬을 이용한 프로그래밍 방법을 학습하고, 데이터 분석에 필수적인 몇 가지 패키지를 소개한다.\n또한 클래스와 객체지향적 프로그래밍의 개념을 설명한다."
  },
  {
    "objectID": "index.html#학습-평가",
    "href": "index.html#학습-평가",
    "title": "Python프로그래밍",
    "section": "학습 평가",
    "text": "학습 평가\n\n중간 30%, 기말 40%, 출석 10%, 과제 20%\n결석 1회 1점 감점, 지각 3회 1점 감점(1/4 이상 결석하면 F학점)"
  },
  {
    "objectID": "index.html#설문조사",
    "href": "index.html#설문조사",
    "title": "Python프로그래밍",
    "section": "설문조사",
    "text": "설문조사\n\nPython 프로그래밍에 대한 기초적인 이해도와 경험을 파악하기 위해 설문조사를 실시함\n25-1 Python프로그래밍 사전 설문조사"
  },
  {
    "objectID": "index.html#문의",
    "href": "index.html#문의",
    "title": "Python프로그래밍",
    "section": "문의",
    "text": "문의\n\nE-mail: stat6503@gmail.com\nLMS는 파일 제출용으로만 사용하니 쪽지 보내지 말 것"
  },
  {
    "objectID": "index.html#참고문헌",
    "href": "index.html#참고문헌",
    "title": "Python프로그래밍",
    "section": "참고문헌",
    "text": "참고문헌\n\n실생활 융합 예제로 배우는 파이썬 마스터 / 김종훈, 김동건 / 2025 / 한빛아카데미\n데이터 과학을 위한 파이썬 프로그래밍 / 최성철 / 2023 / 한빛아카데미\n혼자 공부하는 파이썬(개정판) / 윤인성 / 2022 / 한빛아카데미\nwebsite : 점프 투 파이썬"
  },
  {
    "objectID": "3_5_dictionary.html",
    "href": "3_5_dictionary.html",
    "title": "3. 자료구조",
    "section": "",
    "text": "딕셔너리(dictionary)\n\n여러 개의 키-값(key-value) 쌍을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 있는 매핑 자료형(mapping data type)(Python 3.7+)\n키(key)를 통해 값(value)을 찾는 구조\n\n키는 중복될 수 없고(해시 가능한 자료형만 가능), 값은 중복 가능함(모든 자료형 가능)\n\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n\n\n\n\n딕셔너리 생성\n\n리터럴 방식(dictionary literal)\n\n{key: value}를 사용하여 딕셔너리를 직접 정의하는 방법\n{} 안에 여러 개의 key: value 쌍을 ,로 구분하여 나열함\n중복된 키가 있으면 마지막에 정의한 값이 적용됨\n\n생성자 방식(dictionary constructor)\n\ndict() 함수를 사용하여 딕셔너리를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 딕셔너리를 생성할 때 유용함\n\nzip() 함수를 이용하여 여러 개의 리스트나 튜플을 병렬로 묶어 키-값 쌍의 형태로 구성할 수 있음\nenumerate() 함수를 이용하여 인덱스를 키로, 원소를 값으로 하여 쌍으로 묶어 딕셔너리를 생성할 수 있음\n\n\n\n\n\n# 딕셔너리 생성1\ndct = {'a': 1, 'b': 2, 'c': 3}\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 생성2\ndct = dict(a=1, b=2, c=3)\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 생성3 : 키는 중복될 수 없음\ndct = {'a':1, 'b': 2, 'c': 3, 'a': 4, 'b': 5}\nprint(dct)\n\n{'a': 4, 'b': 5, 'c': 3}\n\n\n\n# 딕셔너리 생성4 : (key, value) 쌍의 리스트 사용\ndct = dict([('x', 100), ('y', 200)])\nprint(dct)\n\n{'x': 100, 'y': 200}\n\n\n\n# 딕셔너리 생성5 : zip() 함수 사용\nkeys = ['name', 'age', 'city']\nvalues = ['Alice', 28, 'Jeonju']\ndct = dict(zip(keys, values))\nprint(dct)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n\n\n\n# 딕셔너리 생성6 : enumerate() 함수 사용\nfruits = ['apple', 'banana', 'cherry']\ndct = dict(enumerate(fruits))\nprint(dct)\n\n{0: 'apple', 1: 'banana', 2: 'cherry'}\n\n\n\n\n\n\n\n딕셔너리는 키를 사용하여 값에 접근함\n리스트, 튜플처럼 정수 인덱스를 이용한 접근은 불가능함\n\n\n# 키를 이용한 값 접근\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(info['name'])\nprint(info['age'])\n\nAlice\n28\n\n\n\n# 딕셔너리는 가변형 객체이므로 키를 이용한 수정이 가능함\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ninfo['city'] = 'Iksan'\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Iksan'}\n\n\n\n# 새로운 키-값 쌍 추가\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ninfo['email'] = 'alice123@gmail.com'\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju', 'email': 'alice123@gmail.com'}\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nkeys()\n딕셔너리의 모든 키를 반환(dict_keys 객체)\n\n\nvalues()\n딕셔너리의 모든 값을 반환(dict_values 객체)\n\n\nitems()\n(키, 값) 쌍을 튜플 형태로 반환(dict_items 객체)\n\n\nget()\n지정한 키의 값을 반환하며, 없으면 None 반환\n\n\nin 연산자\n특정 키가 딕셔너리에 있다면 True, 없다면 False 반환\n\n\n\n\n# 모든 키\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.keys()))\n\n['name', 'age', 'city']\n\n\n\n# 모든 값\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.values()))\n\n['Alice', 28, 'Jeonju']\n\n\n\n# (키, 값) 쌍\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.items()))\n\n[('name', 'Alice'), ('age', 28), ('city', 'Jeonju')]\n\n\n\n# 키를 이용한 값 조회\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(info.get('name'))\nprint(info.get('email'))\n\nAlice\nNone\n\n\n\n# 특정 키 찾기\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint('age' in info)\nprint('email' in info)\n\nTrue\nFalse\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nupdate()\n다른 딕셔너리나 키워드 인자를 이용하여 원소를 추가 및 수정\n\n\npop()\n특정 키의 값을 삭제하고 그 값을 반환하며, 키가 없으면 오류 발생\n\n\npopitem()\n마지막 (키, 값) 쌍을 삭제하고 반환\n\n\ndel 키워드\n특정 키의 원소를 삭제하며, 키가 없으면 오류 발생\n\n\nclear()\n딕셔너리의 모든 원소를 삭제\n\n\n\n\n# 원소 추가 및 수정1\ninfo = {'name': 'Alice', 'age': 28}\ninfo.update({'age': 29, 'city': 'Jeonju'})\nprint(info)\n\n{'name': 'Alice', 'age': 29, 'city': 'Jeonju'}\n\n\n\n# 원소 추가 및 수정2\ninfo = {'name': 'Alice', 'age': 28}\ninfo.update(age=29, city='Jeonju')\nprint(info)\n\n{'name': 'Alice', 'age': 29, 'city': 'Jeonju'}\n\n\n\n# 특정 키의 값 삭제1\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nage = info.pop('age')\nprint(info)\nprint(age)\n\n{'name': 'Alice', 'city': 'Jeonju'}\n28\n\n\n\n# 특정 키의 값 삭제2\n#info = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n#age = info.pop('email')\n#print(info)\n#print(email)\n\n\n# 마지막 (키, 값) 쌍 삭제\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nlast_item = info.popitem()\nprint(info)\nprint(last_item)\n\n{'name': 'Alice', 'age': 28}\n('city', 'Jeonju')\n\n\n\n# 특정 키의 원소 삭제1\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ndel info['age']\nprint(info)\n\n{'name': 'Alice', 'city': 'Jeonju'}\n\n\n\n# 특정 키의 원소 삭제2\n#info = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n#del info['email']\n#print(info)\n\n\n\n\n\n\n\n\n\n패킹(packing) : 여러 개의 키-값 쌍을 하나의 딕셔너리로 묶어 할당하는 것\n언패킹(unpacking) : 하나의 딕셔너리에 묶인 키-값 쌍을 개별 변수에 분리하여 할당하는 것\n\n\n# 딕셔너리 패킹\ndct = {'a': 1, 'b': 2, 'c': 3}\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 언패킹\nd = {'a': 1, 'b': 2, 'c': 3}\na, b, c = d.values()\nprint(a)\nprint(b)\nprint(c)\n\n1\n2\n3\n\n\n\n\n\n\n\n딕셔너리를 이용하여 함수의 키워드 가변 인수(keyword variable-length arguments)를 처리할 수 있음\n**를 사용하여 딕셔너리를 언패킹하면, 각 키-쌍이 함수의 키워드 인수로 전달됨\n\n\n# 키워드 가변 인수와 패킹, 언패킹\ndef print_info(**kwargs):\n    for key, value in kwargs.items():                       # 전달된 값이 딕셔너리로 패킹됨\n        print(f\"{key}: {value}\")\n\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint_info(**info)                                          # 딕셔너리를 언패킹하여 함수에 전달\n\nname: Alice\nage: 28\ncity: Jeonju\n\n\n\n\n\n\n\n\n{키식: 값식 for 변수 in 반복범위 if 조건식}\n\n\n리스트 컴프리헨션과 문법이 유사하지만, 키:값 형태로 표현\n\n\n# 문자 개수 세기\nword = \"Hello\"\nchar_count = {char: word.count(char) for char in word}\nprint(char_count)\n\n{'H': 1, 'e': 1, 'l': 2, 'o': 1}\n\n\n\n# 두 리스트를 키와 값으로 합치기\nkeys = ['name', 'age', 'city']\nvalues = ['Alice', 28, 'Jeonju']\ninfo = {k: v for k, v in zip(keys, values)}\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n\n\n\n# 리스트를 인덱스와 함께 딕셔너리로 변환\nfruits = ['apple', 'banana', 'cherry']\ndct = {i: fruit for i, fruit in enumerate(fruits)}\nprint(dct)\n\n{0: 'apple', 1: 'banana', 2: 'cherry'}\n\n\n\n# 점수(값) 80 이상만 필터링\nscores = {'Alice': 85, 'Bob': 92, 'Charlie': 77, 'David': 90}\npassed = {name: score for name, score in scores.items() if score &gt;= 80}\nprint(passed)\n\n{'Alice': 85, 'Bob': 92, 'David': 90}\n\n\n\n# 가격(값)에 5% 할인 적용\nprices = {'apple': 1000, 'banana': 800, 'cherry': 1500}\ndiscounted_prices = {item: price * 0.95 for item, price in prices.items()}\nprint(discounted_prices)\n\n{'apple': 950.0, 'banana': 760.0, 'cherry': 1425.0}"
  },
  {
    "objectID": "3_5_dictionary.html#딕셔너리",
    "href": "3_5_dictionary.html#딕셔너리",
    "title": "3. 자료구조",
    "section": "",
    "text": "딕셔너리(dictionary)\n\n여러 개의 키-값(key-value) 쌍을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 있는 매핑 자료형(mapping data type)(Python 3.7+)\n키(key)를 통해 값(value)을 찾는 구조\n\n키는 중복될 수 없고(해시 가능한 자료형만 가능), 값은 중복 가능함(모든 자료형 가능)\n\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n\n\n\n\n딕셔너리 생성\n\n리터럴 방식(dictionary literal)\n\n{key: value}를 사용하여 딕셔너리를 직접 정의하는 방법\n{} 안에 여러 개의 key: value 쌍을 ,로 구분하여 나열함\n중복된 키가 있으면 마지막에 정의한 값이 적용됨\n\n생성자 방식(dictionary constructor)\n\ndict() 함수를 사용하여 딕셔너리를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 딕셔너리를 생성할 때 유용함\n\nzip() 함수를 이용하여 여러 개의 리스트나 튜플을 병렬로 묶어 키-값 쌍의 형태로 구성할 수 있음\nenumerate() 함수를 이용하여 인덱스를 키로, 원소를 값으로 하여 쌍으로 묶어 딕셔너리를 생성할 수 있음\n\n\n\n\n\n# 딕셔너리 생성1\ndct = {'a': 1, 'b': 2, 'c': 3}\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 생성2\ndct = dict(a=1, b=2, c=3)\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 생성3 : 키는 중복될 수 없음\ndct = {'a':1, 'b': 2, 'c': 3, 'a': 4, 'b': 5}\nprint(dct)\n\n{'a': 4, 'b': 5, 'c': 3}\n\n\n\n# 딕셔너리 생성4 : (key, value) 쌍의 리스트 사용\ndct = dict([('x', 100), ('y', 200)])\nprint(dct)\n\n{'x': 100, 'y': 200}\n\n\n\n# 딕셔너리 생성5 : zip() 함수 사용\nkeys = ['name', 'age', 'city']\nvalues = ['Alice', 28, 'Jeonju']\ndct = dict(zip(keys, values))\nprint(dct)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n\n\n\n# 딕셔너리 생성6 : enumerate() 함수 사용\nfruits = ['apple', 'banana', 'cherry']\ndct = dict(enumerate(fruits))\nprint(dct)\n\n{0: 'apple', 1: 'banana', 2: 'cherry'}\n\n\n\n\n\n\n\n딕셔너리는 키를 사용하여 값에 접근함\n리스트, 튜플처럼 정수 인덱스를 이용한 접근은 불가능함\n\n\n# 키를 이용한 값 접근\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(info['name'])\nprint(info['age'])\n\nAlice\n28\n\n\n\n# 딕셔너리는 가변형 객체이므로 키를 이용한 수정이 가능함\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ninfo['city'] = 'Iksan'\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Iksan'}\n\n\n\n# 새로운 키-값 쌍 추가\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ninfo['email'] = 'alice123@gmail.com'\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju', 'email': 'alice123@gmail.com'}\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nkeys()\n딕셔너리의 모든 키를 반환(dict_keys 객체)\n\n\nvalues()\n딕셔너리의 모든 값을 반환(dict_values 객체)\n\n\nitems()\n(키, 값) 쌍을 튜플 형태로 반환(dict_items 객체)\n\n\nget()\n지정한 키의 값을 반환하며, 없으면 None 반환\n\n\nin 연산자\n특정 키가 딕셔너리에 있다면 True, 없다면 False 반환\n\n\n\n\n# 모든 키\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.keys()))\n\n['name', 'age', 'city']\n\n\n\n# 모든 값\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.values()))\n\n['Alice', 28, 'Jeonju']\n\n\n\n# (키, 값) 쌍\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.items()))\n\n[('name', 'Alice'), ('age', 28), ('city', 'Jeonju')]\n\n\n\n# 키를 이용한 값 조회\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(info.get('name'))\nprint(info.get('email'))\n\nAlice\nNone\n\n\n\n# 특정 키 찾기\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint('age' in info)\nprint('email' in info)\n\nTrue\nFalse\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nupdate()\n다른 딕셔너리나 키워드 인자를 이용하여 원소를 추가 및 수정\n\n\npop()\n특정 키의 값을 삭제하고 그 값을 반환하며, 키가 없으면 오류 발생\n\n\npopitem()\n마지막 (키, 값) 쌍을 삭제하고 반환\n\n\ndel 키워드\n특정 키의 원소를 삭제하며, 키가 없으면 오류 발생\n\n\nclear()\n딕셔너리의 모든 원소를 삭제\n\n\n\n\n# 원소 추가 및 수정1\ninfo = {'name': 'Alice', 'age': 28}\ninfo.update({'age': 29, 'city': 'Jeonju'})\nprint(info)\n\n{'name': 'Alice', 'age': 29, 'city': 'Jeonju'}\n\n\n\n# 원소 추가 및 수정2\ninfo = {'name': 'Alice', 'age': 28}\ninfo.update(age=29, city='Jeonju')\nprint(info)\n\n{'name': 'Alice', 'age': 29, 'city': 'Jeonju'}\n\n\n\n# 특정 키의 값 삭제1\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nage = info.pop('age')\nprint(info)\nprint(age)\n\n{'name': 'Alice', 'city': 'Jeonju'}\n28\n\n\n\n# 특정 키의 값 삭제2\n#info = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n#age = info.pop('email')\n#print(info)\n#print(email)\n\n\n# 마지막 (키, 값) 쌍 삭제\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nlast_item = info.popitem()\nprint(info)\nprint(last_item)\n\n{'name': 'Alice', 'age': 28}\n('city', 'Jeonju')\n\n\n\n# 특정 키의 원소 삭제1\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ndel info['age']\nprint(info)\n\n{'name': 'Alice', 'city': 'Jeonju'}\n\n\n\n# 특정 키의 원소 삭제2\n#info = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n#del info['email']\n#print(info)\n\n\n\n\n\n\n\n\n\n패킹(packing) : 여러 개의 키-값 쌍을 하나의 딕셔너리로 묶어 할당하는 것\n언패킹(unpacking) : 하나의 딕셔너리에 묶인 키-값 쌍을 개별 변수에 분리하여 할당하는 것\n\n\n# 딕셔너리 패킹\ndct = {'a': 1, 'b': 2, 'c': 3}\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 언패킹\nd = {'a': 1, 'b': 2, 'c': 3}\na, b, c = d.values()\nprint(a)\nprint(b)\nprint(c)\n\n1\n2\n3\n\n\n\n\n\n\n\n딕셔너리를 이용하여 함수의 키워드 가변 인수(keyword variable-length arguments)를 처리할 수 있음\n**를 사용하여 딕셔너리를 언패킹하면, 각 키-쌍이 함수의 키워드 인수로 전달됨\n\n\n# 키워드 가변 인수와 패킹, 언패킹\ndef print_info(**kwargs):\n    for key, value in kwargs.items():                       # 전달된 값이 딕셔너리로 패킹됨\n        print(f\"{key}: {value}\")\n\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint_info(**info)                                          # 딕셔너리를 언패킹하여 함수에 전달\n\nname: Alice\nage: 28\ncity: Jeonju\n\n\n\n\n\n\n\n\n{키식: 값식 for 변수 in 반복범위 if 조건식}\n\n\n리스트 컴프리헨션과 문법이 유사하지만, 키:값 형태로 표현\n\n\n# 문자 개수 세기\nword = \"Hello\"\nchar_count = {char: word.count(char) for char in word}\nprint(char_count)\n\n{'H': 1, 'e': 1, 'l': 2, 'o': 1}\n\n\n\n# 두 리스트를 키와 값으로 합치기\nkeys = ['name', 'age', 'city']\nvalues = ['Alice', 28, 'Jeonju']\ninfo = {k: v for k, v in zip(keys, values)}\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n\n\n\n# 리스트를 인덱스와 함께 딕셔너리로 변환\nfruits = ['apple', 'banana', 'cherry']\ndct = {i: fruit for i, fruit in enumerate(fruits)}\nprint(dct)\n\n{0: 'apple', 1: 'banana', 2: 'cherry'}\n\n\n\n# 점수(값) 80 이상만 필터링\nscores = {'Alice': 85, 'Bob': 92, 'Charlie': 77, 'David': 90}\npassed = {name: score for name, score in scores.items() if score &gt;= 80}\nprint(passed)\n\n{'Alice': 85, 'Bob': 92, 'David': 90}\n\n\n\n# 가격(값)에 5% 할인 적용\nprices = {'apple': 1000, 'banana': 800, 'cherry': 1500}\ndiscounted_prices = {item: price * 0.95 for item, price in prices.items()}\nprint(discounted_prices)\n\n{'apple': 950.0, 'banana': 760.0, 'cherry': 1425.0}"
  },
  {
    "objectID": "3_3_tuple.html",
    "href": "3_3_tuple.html",
    "title": "3. 자료구조",
    "section": "",
    "text": "튜플(tuple)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 존재하는 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에는 수정할 수 없는 불변형(immutable) 객체\n정수형, 부동소수점형, 문자열형, bool형, 리스트, 튜플, 딕셔너리 등 다양한 자료형을 저장할 수 있는 컨테이너형 객체\n리스트와 구조 및 사용 방법이 거의 동일하지만, 수정이 불가능하다는 차이점이 있음\n\n\n\n\n튜플 생성\n\n리터럴 방식(tuple literal)\n\n()를 사용하여 튜플을 직접 정의하는 방법\n() 안에 원소(element)를 ,로 구분하여 나열함\n()을 생략할 수도 있지만, 원소가 하나인 경우에는 (값,)처럼 반드시 ,를 포함해야 함\n\n생성자 방식(tuple constructor)\n\ntuple() 함수를 사용하여 튜플을 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 튜플을 생성할 때 유용함\n\n\n\n\n# 튜플 생성1\ntpl = (1, 2, 3, 4, 5)\nprint(tpl)\n\n(1, 2, 3, 4, 5)\n\n\n\n# 튜플 생성2\ntpl = 1, 2, 3, 4, 5\nprint(tpl)\n\n(1, 2, 3, 4, 5)\n\n\n\n# 튜플 생성3 : 원소가 하나인 경우에는 반드시 ,를 포함해야 함\ntpl = (1,)\nprint(tpl)\n\n(1,)\n\n\n\n# 튜플 생성4 : 튜플은 다양한 자료형을 저장할 수 있음\ntpl = (1, 3.14, \"Hello\", True, [11, 12, 13], (21, 22))\nprint(tpl)\n\n(1, 3.14, 'Hello', True, [11, 12, 13], (21, 22))\n\n\n\n# 튜플 생성5 : iterable 객체 사용\ntpl = tuple(\"Hello\")\nprint(tpl)\n\n('H', 'e', 'l', 'l', 'o')\n\n\n\n# 튜플 생성6 : iterable 객체 사용\ntpl = tuple([1, 2, 3])\nprint(tpl)\n\n(1, 2, 3)\n\n\n\n\n\n\n\n리스트 연산과 문법이 동일함\n튜플 연결 연산자 + : 두 튜플을 연결해서 새로운 튜플 생성\n튜플 반복 연산자 * : 튜플을 숫자만큼 반복하여 새로운 튜플 생성 - (예) 튜플*숫자\n튜플 전개 연산자 * : 튜플의 개별 원소를 분리하여 다른 튜플 전개 - (예) (*튜플)\n\n\n# 튜플 연결\ntpl1 = 1, 2, 3\ntpl2 = 11, 12, 13\nprint(tpl1 + tpl2)\n\n(1, 2, 3, 11, 12, 13)\n\n\n\n# 튜플 반복\nprint(tpl1 * 3)\n\n(1, 2, 3, 1, 2, 3, 1, 2, 3)\n\n\n\n# 튜플 전개\ntpl = 1, 2, 3, 4, 5\nprint((tpl, tpl))\nprint((*tpl, *tpl))\n\n((1, 2, 3, 4, 5), (1, 2, 3, 4, 5))\n(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)\n\n\n\n\n\n\n\n\n\n패킹(packing) : 여러 개의 데이터를 한 변수에 묶어 할당하는 것\n언패킹(unpacking) : 한 변수에 묶인 데이터를 개별적인 변수들에 할당하는 것\n\n\n# 튜플 패킹\ntpl = 1, 2, 3\nprint(tpl)\n\n(1, 2, 3)\n\n\n\n# 튜플 언패킹\ntpl = 1, 2, 3\nx, y, z = tpl\nprint(x)\nprint(y)\nprint(z)\n\n1\n2\n3\n\n\n\n# 튜플 패킹과 언패킹 : 임시변수 없이 두 변수의 값을 쉽게 교환할 수 있음\na = 7\nb = 11\na, b = b, a\nprint(a)\nprint(b)\n\n11\n7\n\n\n\n# 언패킹 시 변수 개수 불일치 오류\n#a, b = 1, 2, 3\n#x, y, z = 4, 5\n\n\n# 언패킹 시 *을 이용한 가변 개수 처리\n# *변수는 여러 개의 값을 저장해야 하므로, 가변적인 리스트로 처리됨\n*x, y, z = 5, 6, 7, 8\nprint(x)\nprint(y)\nprint(z)\n\n[5, 6]\n7\n8\n\n\n\n\n\n\n\n가변 인수를 사용하면 전달된 인수들은 튜플로 패킹됨\n*를 사용하여 튜플을 언패킹하여 함수에 전달함\n\n\n# 가변 인수와 패킹, 언패킹\ndef print_args(*args):\n    print(\"Packed arguments:\", args)                        # 전달된 값이 튜플로 패킹됨\n\nprint_args(1, 2, 3, 4)\n\ntpl = 11, 12, 13\nprint_args(tpl)                                             # 튜플 자체를 인수로 전달\nprint_args(*tpl)                                            # 튜플을 언패킹하여 함수에 전달\n\nPacked arguments: (1, 2, 3, 4)\nPacked arguments: ((11, 12, 13),)\nPacked arguments: (11, 12, 13)\n\n\n\n# 키워드 인수와 언패킹\ndef sum_numbers(a, b, c, d):\n    return a + b + c + d\n\ntpl = 1, 2, 3, 4\n\nprint(sum_numbers(tpl[0], tpl[1], tpl[2], tpl[3]))          # 개별 원소를 인수로 전달\nprint(sum_numbers(*tpl))                                    # 튜플을 언패킹하여 함수에 전달\n\n10\n10\n\n\n\n\n\n\n\n함수에서 여러 개의 값을 반환하면 자동으로 튜플로 패킹됨\n함수가 반환한 튜플을 언패킹하여 개별 변수에 할당할 수 있음\n\n\n# 반환값과 패킹, 언패킹\ndef get_student_info():\n    return \"Alice\", 20, \"Statistics\"                        # 튜플로 자동 패킹됨\n\n# 패킹된 값 출력\ninfo = get_student_info()\nprint(info)\n\n# 언패킹하여 개별 변수에 할당\nname, age, major = get_student_info()\nprint(name)\nprint(age)\nprint(major)\n\n('Alice', 20, 'Statistics')\nAlice\n20\nStatistics\n\n\n\n\n\n\n\n\n리스트와 문법이 동일함\n인덱싱(indexing) : [index]를 사용하여 튜플의 특정 위치에 있는 원소에 접근함\n슬라이싱(slicing) : [(start index):(stop index)]를 사용하여 튜플의 일부 원소를 추출함\n\n리스트와 달리 불변형 객체이므로 슬라이싱을 이용하여 기존 튜플의 일부를 삭제하거나, 새로운 원소를 추가 및 변경할 수 없음\n\n\n\n# 튜플 인덱싱1\ntpl = 1, 2, 3, 4, 5\nprint(tpl[0])\n\n1\n\n\n\n# 튜플 인덱싱2\ntpl = 1, 2, 3, 4, 5\nprint(tpl[-1])\n\n5\n\n\n\n# 튜플 슬라이싱1\ntpl = 1, 2, 3, 4, 5\nprint(tpl[0:2])\n\n(1, 2)\n\n\n\n# 튜플 슬라이싱2\ntpl = 1, 2, 3, 4, 5\nprint(tpl[:2])\nprint(tpl[2:])\nprint(tpl[::2])\n\n(1, 2)\n(3, 4, 5)\n(1, 3, 5)\n\n\n\n# 튜플은 불변형 객체이므로 인덱스를 이용한 수정이 불가능함\n#tpl = 1, 2, 3, 4, 5\n#tpl[2] = 3\n#print(tpl)\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ncount()\n튜플 내부에 특정 값이 몇 번 나타나는지 개수를 반환\n\n\nindex()\n튜플 내부에 특정 값의 첫 번째 인덱스를 반환하며, 없으면 오류 발생\n\n\nin 연산자\n튜플 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\nlen()\n튜플 원소의 개수(튜플 길이) 반환\n\n\nsum()\n튜플 원소의 합계 반환\n\n\nmax()\n튜플 원소 중 최대값 반환\n\n\nmin()\n튜플 원소 중 최소값 반환\n\n\n\n\n# 특정 값 개수\ntpl = 1, 2, 3, 1, 4, 5, 1, 6, 7\nprint(tpl.count(1))\nprint(tpl.count(9))\n\n3\n0\n\n\n\n# 특정 값의 첫 번쩨 인덱스\ntpl = 1, 2, 3, 1, 4, 5, 1, 6, 7\nprint(tpl.index(1))\n#print(tpl.index(9))\n\n0\n\n\n\n# 특정값 찾기\ntpl = 1, 2, 3, 4, 5\nprint(3 in tpl)\nprint(6 in tpl)\n\nTrue\nFalse\n\n\n\ntpl = 1, 2, 3, 4, 5\nprint(len(tpl))\nprint(sum(tpl))\nprint(max(tpl))\nprint(min(tpl))\n\n5\n15\n5\n1"
  },
  {
    "objectID": "3_3_tuple.html#튜플",
    "href": "3_3_tuple.html#튜플",
    "title": "3. 자료구조",
    "section": "",
    "text": "튜플(tuple)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 존재하는 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에는 수정할 수 없는 불변형(immutable) 객체\n정수형, 부동소수점형, 문자열형, bool형, 리스트, 튜플, 딕셔너리 등 다양한 자료형을 저장할 수 있는 컨테이너형 객체\n리스트와 구조 및 사용 방법이 거의 동일하지만, 수정이 불가능하다는 차이점이 있음\n\n\n\n\n튜플 생성\n\n리터럴 방식(tuple literal)\n\n()를 사용하여 튜플을 직접 정의하는 방법\n() 안에 원소(element)를 ,로 구분하여 나열함\n()을 생략할 수도 있지만, 원소가 하나인 경우에는 (값,)처럼 반드시 ,를 포함해야 함\n\n생성자 방식(tuple constructor)\n\ntuple() 함수를 사용하여 튜플을 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 튜플을 생성할 때 유용함\n\n\n\n\n# 튜플 생성1\ntpl = (1, 2, 3, 4, 5)\nprint(tpl)\n\n(1, 2, 3, 4, 5)\n\n\n\n# 튜플 생성2\ntpl = 1, 2, 3, 4, 5\nprint(tpl)\n\n(1, 2, 3, 4, 5)\n\n\n\n# 튜플 생성3 : 원소가 하나인 경우에는 반드시 ,를 포함해야 함\ntpl = (1,)\nprint(tpl)\n\n(1,)\n\n\n\n# 튜플 생성4 : 튜플은 다양한 자료형을 저장할 수 있음\ntpl = (1, 3.14, \"Hello\", True, [11, 12, 13], (21, 22))\nprint(tpl)\n\n(1, 3.14, 'Hello', True, [11, 12, 13], (21, 22))\n\n\n\n# 튜플 생성5 : iterable 객체 사용\ntpl = tuple(\"Hello\")\nprint(tpl)\n\n('H', 'e', 'l', 'l', 'o')\n\n\n\n# 튜플 생성6 : iterable 객체 사용\ntpl = tuple([1, 2, 3])\nprint(tpl)\n\n(1, 2, 3)\n\n\n\n\n\n\n\n리스트 연산과 문법이 동일함\n튜플 연결 연산자 + : 두 튜플을 연결해서 새로운 튜플 생성\n튜플 반복 연산자 * : 튜플을 숫자만큼 반복하여 새로운 튜플 생성 - (예) 튜플*숫자\n튜플 전개 연산자 * : 튜플의 개별 원소를 분리하여 다른 튜플 전개 - (예) (*튜플)\n\n\n# 튜플 연결\ntpl1 = 1, 2, 3\ntpl2 = 11, 12, 13\nprint(tpl1 + tpl2)\n\n(1, 2, 3, 11, 12, 13)\n\n\n\n# 튜플 반복\nprint(tpl1 * 3)\n\n(1, 2, 3, 1, 2, 3, 1, 2, 3)\n\n\n\n# 튜플 전개\ntpl = 1, 2, 3, 4, 5\nprint((tpl, tpl))\nprint((*tpl, *tpl))\n\n((1, 2, 3, 4, 5), (1, 2, 3, 4, 5))\n(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)\n\n\n\n\n\n\n\n\n\n패킹(packing) : 여러 개의 데이터를 한 변수에 묶어 할당하는 것\n언패킹(unpacking) : 한 변수에 묶인 데이터를 개별적인 변수들에 할당하는 것\n\n\n# 튜플 패킹\ntpl = 1, 2, 3\nprint(tpl)\n\n(1, 2, 3)\n\n\n\n# 튜플 언패킹\ntpl = 1, 2, 3\nx, y, z = tpl\nprint(x)\nprint(y)\nprint(z)\n\n1\n2\n3\n\n\n\n# 튜플 패킹과 언패킹 : 임시변수 없이 두 변수의 값을 쉽게 교환할 수 있음\na = 7\nb = 11\na, b = b, a\nprint(a)\nprint(b)\n\n11\n7\n\n\n\n# 언패킹 시 변수 개수 불일치 오류\n#a, b = 1, 2, 3\n#x, y, z = 4, 5\n\n\n# 언패킹 시 *을 이용한 가변 개수 처리\n# *변수는 여러 개의 값을 저장해야 하므로, 가변적인 리스트로 처리됨\n*x, y, z = 5, 6, 7, 8\nprint(x)\nprint(y)\nprint(z)\n\n[5, 6]\n7\n8\n\n\n\n\n\n\n\n가변 인수를 사용하면 전달된 인수들은 튜플로 패킹됨\n*를 사용하여 튜플을 언패킹하여 함수에 전달함\n\n\n# 가변 인수와 패킹, 언패킹\ndef print_args(*args):\n    print(\"Packed arguments:\", args)                        # 전달된 값이 튜플로 패킹됨\n\nprint_args(1, 2, 3, 4)\n\ntpl = 11, 12, 13\nprint_args(tpl)                                             # 튜플 자체를 인수로 전달\nprint_args(*tpl)                                            # 튜플을 언패킹하여 함수에 전달\n\nPacked arguments: (1, 2, 3, 4)\nPacked arguments: ((11, 12, 13),)\nPacked arguments: (11, 12, 13)\n\n\n\n# 키워드 인수와 언패킹\ndef sum_numbers(a, b, c, d):\n    return a + b + c + d\n\ntpl = 1, 2, 3, 4\n\nprint(sum_numbers(tpl[0], tpl[1], tpl[2], tpl[3]))          # 개별 원소를 인수로 전달\nprint(sum_numbers(*tpl))                                    # 튜플을 언패킹하여 함수에 전달\n\n10\n10\n\n\n\n\n\n\n\n함수에서 여러 개의 값을 반환하면 자동으로 튜플로 패킹됨\n함수가 반환한 튜플을 언패킹하여 개별 변수에 할당할 수 있음\n\n\n# 반환값과 패킹, 언패킹\ndef get_student_info():\n    return \"Alice\", 20, \"Statistics\"                        # 튜플로 자동 패킹됨\n\n# 패킹된 값 출력\ninfo = get_student_info()\nprint(info)\n\n# 언패킹하여 개별 변수에 할당\nname, age, major = get_student_info()\nprint(name)\nprint(age)\nprint(major)\n\n('Alice', 20, 'Statistics')\nAlice\n20\nStatistics\n\n\n\n\n\n\n\n\n리스트와 문법이 동일함\n인덱싱(indexing) : [index]를 사용하여 튜플의 특정 위치에 있는 원소에 접근함\n슬라이싱(slicing) : [(start index):(stop index)]를 사용하여 튜플의 일부 원소를 추출함\n\n리스트와 달리 불변형 객체이므로 슬라이싱을 이용하여 기존 튜플의 일부를 삭제하거나, 새로운 원소를 추가 및 변경할 수 없음\n\n\n\n# 튜플 인덱싱1\ntpl = 1, 2, 3, 4, 5\nprint(tpl[0])\n\n1\n\n\n\n# 튜플 인덱싱2\ntpl = 1, 2, 3, 4, 5\nprint(tpl[-1])\n\n5\n\n\n\n# 튜플 슬라이싱1\ntpl = 1, 2, 3, 4, 5\nprint(tpl[0:2])\n\n(1, 2)\n\n\n\n# 튜플 슬라이싱2\ntpl = 1, 2, 3, 4, 5\nprint(tpl[:2])\nprint(tpl[2:])\nprint(tpl[::2])\n\n(1, 2)\n(3, 4, 5)\n(1, 3, 5)\n\n\n\n# 튜플은 불변형 객체이므로 인덱스를 이용한 수정이 불가능함\n#tpl = 1, 2, 3, 4, 5\n#tpl[2] = 3\n#print(tpl)\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ncount()\n튜플 내부에 특정 값이 몇 번 나타나는지 개수를 반환\n\n\nindex()\n튜플 내부에 특정 값의 첫 번째 인덱스를 반환하며, 없으면 오류 발생\n\n\nin 연산자\n튜플 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\nlen()\n튜플 원소의 개수(튜플 길이) 반환\n\n\nsum()\n튜플 원소의 합계 반환\n\n\nmax()\n튜플 원소 중 최대값 반환\n\n\nmin()\n튜플 원소 중 최소값 반환\n\n\n\n\n# 특정 값 개수\ntpl = 1, 2, 3, 1, 4, 5, 1, 6, 7\nprint(tpl.count(1))\nprint(tpl.count(9))\n\n3\n0\n\n\n\n# 특정 값의 첫 번쩨 인덱스\ntpl = 1, 2, 3, 1, 4, 5, 1, 6, 7\nprint(tpl.index(1))\n#print(tpl.index(9))\n\n0\n\n\n\n# 특정값 찾기\ntpl = 1, 2, 3, 4, 5\nprint(3 in tpl)\nprint(6 in tpl)\n\nTrue\nFalse\n\n\n\ntpl = 1, 2, 3, 4, 5\nprint(len(tpl))\nprint(sum(tpl))\nprint(max(tpl))\nprint(min(tpl))\n\n5\n15\n5\n1"
  },
  {
    "objectID": "3_1_structure.html",
    "href": "3_1_structure.html",
    "title": "3. 자료구조",
    "section": "",
    "text": "자료구조(data structure) : 데이터의 특징을 고려하여 메모리에 효율적으로 저장 및 반환하는 방법으로 데이터를 관리하는 방식\n자료구조의 중요성\n\n데이터 저장과 검색 효율화 : (예) 빠른 검색이 필요한 경우 딕셔너리 사용\n연산 속도 최적화 : (예) 중복을 제거하는 경우 리스트보다 세트가 효율적임\n메모리 사용 절약 : (예) 불변형 객체를 다룰 때는 리스트 대신 튜플 사용\n코드 가독성 및 유지보수성 향상\n\n\n\n\n\n\n\nPython은 리스트(list), 튜플(tuple), 세트(set), 딕셔너리(dictionary)의 4개 대표적인 자료구조를 제공함\n\n\n\n\n\n\n\n\n자료구조\n설명\n\n\n\n\n리스트(list)\n여러 개의 값을 저장할 수 있는 순차적인 자료구조\n\n\n튜플(tuple)\n리스트와 같지만 데이터의 변경을 허용하지 않는 자료구조\n\n\n세트(set)\n데이터의 중복을 허용하지 않고, 수학의 집합 연산을 지원하는 자료구조\n\n\n딕셔너리(dictionary)\n키(key)와 값(value)의 형태로 데이터를 저장하는 자료구조\n\n\n\n\n\n자료구조 비교\n\n\n\n\n자료구조\n순서 유지\n변경 가능\n중복 허용\n특징\n\n\n\n\n리스트(list)\n○\n○\n○\n가장 기본적인 자료구조, 인덱스로 접근\n\n\n튜플(tuple)\n○\n×\n○\n리스트와 유사하지만 불변형(immutable)\n\n\n세트(set)\n×\n○\n×\n중복 제거, 수학적 집합 연산 가능\n\n\n딕셔너리(dictionary)\n○\n○\n△\n키-값(key-value) 형태로 저장"
  },
  {
    "objectID": "3_1_structure.html#자료구조",
    "href": "3_1_structure.html#자료구조",
    "title": "3. 자료구조",
    "section": "",
    "text": "자료구조(data structure) : 데이터의 특징을 고려하여 메모리에 효율적으로 저장 및 반환하는 방법으로 데이터를 관리하는 방식\n자료구조의 중요성\n\n데이터 저장과 검색 효율화 : (예) 빠른 검색이 필요한 경우 딕셔너리 사용\n연산 속도 최적화 : (예) 중복을 제거하는 경우 리스트보다 세트가 효율적임\n메모리 사용 절약 : (예) 불변형 객체를 다룰 때는 리스트 대신 튜플 사용\n코드 가독성 및 유지보수성 향상\n\n\n\n\n\n\n\nPython은 리스트(list), 튜플(tuple), 세트(set), 딕셔너리(dictionary)의 4개 대표적인 자료구조를 제공함\n\n\n\n\n\n\n\n\n자료구조\n설명\n\n\n\n\n리스트(list)\n여러 개의 값을 저장할 수 있는 순차적인 자료구조\n\n\n튜플(tuple)\n리스트와 같지만 데이터의 변경을 허용하지 않는 자료구조\n\n\n세트(set)\n데이터의 중복을 허용하지 않고, 수학의 집합 연산을 지원하는 자료구조\n\n\n딕셔너리(dictionary)\n키(key)와 값(value)의 형태로 데이터를 저장하는 자료구조\n\n\n\n\n\n자료구조 비교\n\n\n\n\n자료구조\n순서 유지\n변경 가능\n중복 허용\n특징\n\n\n\n\n리스트(list)\n○\n○\n○\n가장 기본적인 자료구조, 인덱스로 접근\n\n\n튜플(tuple)\n○\n×\n○\n리스트와 유사하지만 불변형(immutable)\n\n\n세트(set)\n×\n○\n×\n중복 제거, 수학적 집합 연산 가능\n\n\n딕셔너리(dictionary)\n○\n○\n△\n키-값(key-value) 형태로 저장"
  },
  {
    "objectID": "2_4_function.html",
    "href": "2_4_function.html",
    "title": "2. Python 기초",
    "section": "",
    "text": "함수(function)\n\n특정한 기능을 수행하도록 미리 만들어 놓고, 필요할 때마다 호출하여 사용하는 일련의 코드\nPython에서 기본적으로 제공하는 내장 함수와 사용자가 직접 만들어서 사용할 수 있는 사용자 정의 함수가 있음\n\n\n\n\n함수 장점\n\n필요할 때마다 호출 가능 : 반복적으로 수행해야 하는 업무를 한 번만 작성해 놓고 필요할 때마다 호출하여 사용할 수 있음\n논리적인 단위로 분할 가능 : (예) 도형 계산 프로그램 - 덧셈 코드, 곱셈 코드, 나눗셈 코드 등으로 나눔\n코드의 캡슐화 가능 : 함수의 인터페이스만 잘 정의하면 다른 사람이 자신의 코드를 쉽게 가져다 사용할 수 있음\n\n\n\n# 절대값 반환 함수\nabs(-10)\n\n10\n\n\n\n\n\n\n\ndef 함수 이름(매개변수1, 매개변수2, …):  　　문장  　　return 반환값\n\n\n\n함수 이름 규칙\n\n변수 이름 규칙과 동일함\n일반적으로 소문자로 입력\n작업을 나타내기 위해 동사와 명사를 함께 사용하는 경우가 많음 - (예) find_number\n외부에 공개하는 함수일 경우 줄임말을 사용하지 않고 짧고 명료한 이름으로 정함\n\n\n\n\n매개변수(parameter)\n\n함수에서 입력값으로 사용하는 변수로, 1개 이상의 값을 적을 수 있음\n\n\n\n\n함수 형태\n\n\n\n\n\n\n\n\n\n구분\n매개변수 없음\n매개변수 있음\n\n\n\n\n반환값 없음\n함수 내부 명령문만 수행\n매개변수를 사용하여 명령문만 수행\n\n\n반환값 있음\n매개변수 없이 명령문을 수행한 후 결과값 반환\n매개변수를 사용하여 명령문을 수행한 후 결과값 반환\n\n\n\n\n# 매개변수 ×, 반환값 ×\ndef func():\n    print('함수입니다.')\n\nprint('함수 호출 전입니다')\nfunc()\nprint('함수 호출 후입니다')\n\n함수 호출 전입니다\n함수입니다.\n함수 호출 후입니다\n\n\n\n# 매개변수 ○, 반환값 ×\ndef add1(x, y):\n    print(x+y)\n\nres1 = add1(10,20)\nprint(res1)\n\n30\nNone\n\n\n\n# 매개변수 ○, 반환값 ○\ndef add2(x, y):\n    return x+y\n\nres2 = add2(10,20)\nprint(res2)\n\n30\n\n\n\n## 섭씨온도를 화씨온도로 변환하는 함수\n# (섭씨온도) = (화씨온도 - 32) × 5/9\ndef f_to_c(fahrenheit):\n    return (fahrenheit-32) * 5/9\n\nf_to_c(100)\n\n37.77777777777778"
  },
  {
    "objectID": "2_4_function.html#함수",
    "href": "2_4_function.html#함수",
    "title": "2. Python 기초",
    "section": "",
    "text": "함수(function)\n\n특정한 기능을 수행하도록 미리 만들어 놓고, 필요할 때마다 호출하여 사용하는 일련의 코드\nPython에서 기본적으로 제공하는 내장 함수와 사용자가 직접 만들어서 사용할 수 있는 사용자 정의 함수가 있음\n\n\n\n\n함수 장점\n\n필요할 때마다 호출 가능 : 반복적으로 수행해야 하는 업무를 한 번만 작성해 놓고 필요할 때마다 호출하여 사용할 수 있음\n논리적인 단위로 분할 가능 : (예) 도형 계산 프로그램 - 덧셈 코드, 곱셈 코드, 나눗셈 코드 등으로 나눔\n코드의 캡슐화 가능 : 함수의 인터페이스만 잘 정의하면 다른 사람이 자신의 코드를 쉽게 가져다 사용할 수 있음\n\n\n\n# 절대값 반환 함수\nabs(-10)\n\n10\n\n\n\n\n\n\n\ndef 함수 이름(매개변수1, 매개변수2, …):  　　문장  　　return 반환값\n\n\n\n함수 이름 규칙\n\n변수 이름 규칙과 동일함\n일반적으로 소문자로 입력\n작업을 나타내기 위해 동사와 명사를 함께 사용하는 경우가 많음 - (예) find_number\n외부에 공개하는 함수일 경우 줄임말을 사용하지 않고 짧고 명료한 이름으로 정함\n\n\n\n\n매개변수(parameter)\n\n함수에서 입력값으로 사용하는 변수로, 1개 이상의 값을 적을 수 있음\n\n\n\n\n함수 형태\n\n\n\n\n\n\n\n\n\n구분\n매개변수 없음\n매개변수 있음\n\n\n\n\n반환값 없음\n함수 내부 명령문만 수행\n매개변수를 사용하여 명령문만 수행\n\n\n반환값 있음\n매개변수 없이 명령문을 수행한 후 결과값 반환\n매개변수를 사용하여 명령문을 수행한 후 결과값 반환\n\n\n\n\n# 매개변수 ×, 반환값 ×\ndef func():\n    print('함수입니다.')\n\nprint('함수 호출 전입니다')\nfunc()\nprint('함수 호출 후입니다')\n\n함수 호출 전입니다\n함수입니다.\n함수 호출 후입니다\n\n\n\n# 매개변수 ○, 반환값 ×\ndef add1(x, y):\n    print(x+y)\n\nres1 = add1(10,20)\nprint(res1)\n\n30\nNone\n\n\n\n# 매개변수 ○, 반환값 ○\ndef add2(x, y):\n    return x+y\n\nres2 = add2(10,20)\nprint(res2)\n\n30\n\n\n\n## 섭씨온도를 화씨온도로 변환하는 함수\n# (섭씨온도) = (화씨온도 - 32) × 5/9\ndef f_to_c(fahrenheit):\n    return (fahrenheit-32) * 5/9\n\nf_to_c(100)\n\n37.77777777777778"
  },
  {
    "objectID": "2_2_conditional.html",
    "href": "2_2_conditional.html",
    "title": "2. Python 기초",
    "section": "",
    "text": "프로그램 구조는 크게 순차 구조, 선택 구조, 반복 구조로 구분됨\n\n순차 구조 : 위에서부터 아래로 순차적으로 실행되는 구조\n선택 구조 : 조건에 따라 문장을 선택적으로 실행하는 구조로, 조건이 참(True)인지 거짓(False)인지에 따라 실행되는 문장이 달라짐\n반복 구조 : 임의의 문장을 반복해서 실행하는 구조\n\n\n\n\n\n\n\n\nif 조건식:  　　문장\n\n\n조건식이 참이면 문장을 실행하고 거짓이면 문장을 실행하지 않음\n조건식 오른쪽에 :이 위치하고, 참인 경우 실행될 문장은 반드시 들여쓰기(indentation)해야 함\n\n\n\n# 무작위로 1~100 사이의 두 정수를 생성한 후, 큰 수부터 작은 수 순으로 출력\nimport random\na = random.randint(1, 100)\nb = random.randint(1, 100)\n\nif a&lt;b:\n    a, b = b, a\n\nprint(a, b)\n\n44 8\n\n\n\n\n\n\n\nif 조건식:  　　문장1  else:  　　문장2\n\n\n조건식이 참이면 문장1을 실행하고, 거짓이면 문장2를 실행함\n조건식 오른쪽에 :이 위치하고, else 오른쪽에는 조건식 없이 :이 위치함\n문장1과 문장2는 반드시 들여쓰기해야 함\n\n\n\n# 무작위로 1~100 사이의 정수를 생성한 후, 짝수인지 홀수인지 판단\nimport random\na = random.randint(1, 100)\n\nif a % 2 == 0:\n    print(f'{a}는 짝수입니다')\nelse:\n    print(f'{a}는 홀수입니다')\n\n91는 홀수입니다\n\n\n\n\n\n\n\nif 조건식1:  　　문장1  elif 조건식2:  　　문장2  else:  　　문장3\n\n\n조건식1이 거짓인 경우에 또 다른 선택구조를 연결하는 구조\n조건식1이 참이면 문장1을 실행하고, 조건식1이 거짓이면서 조건식2가 참이면 문장2를 실행하고, 두 조건식 모두 거짓이면 문장3을 실행함\n조건식1, 조건식2 오른쪽에 :이 위치하고, 문장1, 문장2, 문장3은 반드시 들여쓰기해야 함\n\n\n\n# 놀이공원 기본 입장료는 5,000원임\n# 8세 미만은 기본 입장료 30% 할인, 65세 이상은 기본 입장료 20% 할인 적용함\n# 연령이 주어졌을 때, 놀이공원 입장료 산출\nfee = 5000\nage = 7\n\nif age &lt; 8:\n    print('입장료:', fee*0.7)\nelif age &lt; 65:\n    print('입장료:', fee)\nelse:\n    print('입장료:', fee*0.8)\n\n입장료: 3500.0"
  },
  {
    "objectID": "2_2_conditional.html#조건문",
    "href": "2_2_conditional.html#조건문",
    "title": "2. Python 기초",
    "section": "",
    "text": "프로그램 구조는 크게 순차 구조, 선택 구조, 반복 구조로 구분됨\n\n순차 구조 : 위에서부터 아래로 순차적으로 실행되는 구조\n선택 구조 : 조건에 따라 문장을 선택적으로 실행하는 구조로, 조건이 참(True)인지 거짓(False)인지에 따라 실행되는 문장이 달라짐\n반복 구조 : 임의의 문장을 반복해서 실행하는 구조\n\n\n\n\n\n\n\n\nif 조건식:  　　문장\n\n\n조건식이 참이면 문장을 실행하고 거짓이면 문장을 실행하지 않음\n조건식 오른쪽에 :이 위치하고, 참인 경우 실행될 문장은 반드시 들여쓰기(indentation)해야 함\n\n\n\n# 무작위로 1~100 사이의 두 정수를 생성한 후, 큰 수부터 작은 수 순으로 출력\nimport random\na = random.randint(1, 100)\nb = random.randint(1, 100)\n\nif a&lt;b:\n    a, b = b, a\n\nprint(a, b)\n\n44 8\n\n\n\n\n\n\n\nif 조건식:  　　문장1  else:  　　문장2\n\n\n조건식이 참이면 문장1을 실행하고, 거짓이면 문장2를 실행함\n조건식 오른쪽에 :이 위치하고, else 오른쪽에는 조건식 없이 :이 위치함\n문장1과 문장2는 반드시 들여쓰기해야 함\n\n\n\n# 무작위로 1~100 사이의 정수를 생성한 후, 짝수인지 홀수인지 판단\nimport random\na = random.randint(1, 100)\n\nif a % 2 == 0:\n    print(f'{a}는 짝수입니다')\nelse:\n    print(f'{a}는 홀수입니다')\n\n91는 홀수입니다\n\n\n\n\n\n\n\nif 조건식1:  　　문장1  elif 조건식2:  　　문장2  else:  　　문장3\n\n\n조건식1이 거짓인 경우에 또 다른 선택구조를 연결하는 구조\n조건식1이 참이면 문장1을 실행하고, 조건식1이 거짓이면서 조건식2가 참이면 문장2를 실행하고, 두 조건식 모두 거짓이면 문장3을 실행함\n조건식1, 조건식2 오른쪽에 :이 위치하고, 문장1, 문장2, 문장3은 반드시 들여쓰기해야 함\n\n\n\n# 놀이공원 기본 입장료는 5,000원임\n# 8세 미만은 기본 입장료 30% 할인, 65세 이상은 기본 입장료 20% 할인 적용함\n# 연령이 주어졌을 때, 놀이공원 입장료 산출\nfee = 5000\nage = 7\n\nif age &lt; 8:\n    print('입장료:', fee*0.7)\nelif age &lt; 65:\n    print('입장료:', fee)\nelse:\n    print('입장료:', fee*0.8)\n\n입장료: 3500.0"
  },
  {
    "objectID": "1_python.html",
    "href": "1_python.html",
    "title": "1. Python 소개 및 설치",
    "section": "",
    "text": "컴퓨터 프로그램과 프로그래밍 언어\n\n컴퓨터 프로그램 (computer program) : 컴퓨터로 문제를 해결하기 위해 작성하는 명령어의 모음\n프로그래밍 언어(programming language)\n\n컴퓨터에 어떤 동작을 수행하도록 지시하는 언어\n프로그래밍 언어를 사용하여 프로그램을 논리적으로 작성하는 작업을 코딩(coding)이라고 함\n\n\n\n\n\nPython\n\n1991년 귀도 반 로섬(Guido van Rossum)이 개발한 프로그래밍 언어\n빅데이터 분석과 인공지능 분야에서 가장 널리 사용되고 있음\n문법이 쉽고 간결하여 프로그래밍을 처음 접하는 사람이 배우기 적합함\n\n\n\n\nPython 특징\n\n플랫폼 독립적인 언어 : 컴퓨터 운영체제나 하드웨어의 종류에 관계없이 사용할 수 있음\n인터프리터 언어 : 소스코드 자체가 바로 실행되어 간편하게 사용할 수 있음(속도는 느림)\n동적 타이핑 언어\n\n프로그램의 실행 시점에서 각 프로그램 변수의 타입(type)을 결정하는 언어\n인터프리터 언어이므로 프로그램의 실행 시점에 변수들의 메모리 공간을 자유롭게 할당받을 수 있음\n\n객체 지향 언어\n\n프로그램이 해결해야 할 문제의 구성요소를 요소별로 정의한 다음, 각 요소의 기능(method)과 정보(attribute)를 프로그래밍한 다음 요소들을 결합하는 방식으로 프로그램을 작성함\n이때 각 요소를 객체(object)라고 하며, 한 번 만들어진 객체는 재사용(reusability)할 수 있음"
  },
  {
    "objectID": "1_python.html#python-소개",
    "href": "1_python.html#python-소개",
    "title": "1. Python 소개 및 설치",
    "section": "",
    "text": "컴퓨터 프로그램과 프로그래밍 언어\n\n컴퓨터 프로그램 (computer program) : 컴퓨터로 문제를 해결하기 위해 작성하는 명령어의 모음\n프로그래밍 언어(programming language)\n\n컴퓨터에 어떤 동작을 수행하도록 지시하는 언어\n프로그래밍 언어를 사용하여 프로그램을 논리적으로 작성하는 작업을 코딩(coding)이라고 함\n\n\n\n\n\nPython\n\n1991년 귀도 반 로섬(Guido van Rossum)이 개발한 프로그래밍 언어\n빅데이터 분석과 인공지능 분야에서 가장 널리 사용되고 있음\n문법이 쉽고 간결하여 프로그래밍을 처음 접하는 사람이 배우기 적합함\n\n\n\n\nPython 특징\n\n플랫폼 독립적인 언어 : 컴퓨터 운영체제나 하드웨어의 종류에 관계없이 사용할 수 있음\n인터프리터 언어 : 소스코드 자체가 바로 실행되어 간편하게 사용할 수 있음(속도는 느림)\n동적 타이핑 언어\n\n프로그램의 실행 시점에서 각 프로그램 변수의 타입(type)을 결정하는 언어\n인터프리터 언어이므로 프로그램의 실행 시점에 변수들의 메모리 공간을 자유롭게 할당받을 수 있음\n\n객체 지향 언어\n\n프로그램이 해결해야 할 문제의 구성요소를 요소별로 정의한 다음, 각 요소의 기능(method)과 정보(attribute)를 프로그래밍한 다음 요소들을 결합하는 방식으로 프로그램을 작성함\n이때 각 요소를 객체(object)라고 하며, 한 번 만들어진 객체는 재사용(reusability)할 수 있음"
  },
  {
    "objectID": "1_python.html#python-설치",
    "href": "1_python.html#python-설치",
    "title": "1. Python 소개 및 설치",
    "section": "1.2. Python 설치",
    "text": "1.2. Python 설치\n\n1.2.1. Jupyter Notebook과 Jupyter Lab\n\nJupyter Notebook\n\n가장 많이 사용되는 Python IDE 중 하나로, 웹 브라우저에서 실행되는 대화형 개발 도구\n코드 작성과 실행을 한 화면에서 쉽게 수행할 수 있으며, 텍스트(markdown), 수식(LaTeX), 그래프(Matplotlib) 등을 함께 포함할 수 있음\n실행 결과가 셀 단위로 저장되어, 데이터 분석 과정을 논리적인 흐름으로 문서화하여 공유하기 용이함\n특히 데이터 과학, 머신러닝, 교육, 연구 분야에서 많이 활용됨\n\n\n\n\nJupyter Lab\n\nJupyter Notebook을 확장한 차세대 인터페이스로, 더욱 유연하고 강력한 기능을 제공하는 개발 환경\n탭(tab) 기반 인터페이스를 지원하여 여러 개의 노트북, 터미널, 텍스트 파일, 콘솔 등을 동시에 열고 작업할 수 있음\n코드 편집, 데이터 분석, 시각화 등 데이터 과학 및 머신러닝 작업에 최적화된 다양한 편의 기능이 포함됨\n파일 브라우저, 터미널, markdown 편집기, 확장 플러그인 지원 등으로 보다 통합적인 워크플로우 제공\nJupyter Notebook과 호환되며, 확장성을 고려하여 설계되어 다양한 플로그인 추가가 가능함\n\n\n\n\n가상 환경(virtual environment)\n\n독립적인 작업 공간을 제공하여, 하나의 컴퓨터에서 여러 프로젝트를 각각의 독립된 환경으로 격리하여 실행할 수 있음\n하나의 시스템에서 여러 버전의 Python, 라이브러리 등을 설치하고, 프로젝트마다 서로 다른 버전의 의존성을 관리할 수 있음\n충돌 방지 및 의존성 관리에 유용하며, 특정 프로젝트에 필요한 패키지나 라이브러리만 설치하여 다른 프로젝트에 영향을 주지 않음\n프로젝트 간의 의존성 충돌을 피하고, 재현 가능한 환경을 제공하여 코드의 안정성을 높이고 협업을 용이하게 함\n\n\n\n\n가상 환경을 만든 후, Jupyter Lab 설치 및 실행\n\nAnaconda3 설치\nAnaconda Prompt 실행\n가상 환경 생성 : conda create -n myenv python=3.9\n가상 환경 리스트 조회 : conda info --envs\n가상 환경 접속(활성화) : conda activate myenv\n가상 환경에서 Jupyter Lab 설치 : conda install -c conda-forge jupyterlab\nJupyter Lab 접속 : jupyter lab\n\n\n\n\n\n1.2.2. Google Colab\n\nGoogle Colab\n\n구글에서 제공하는 클라우드 기반의 Jupyter Notebook 개발 환경으로, 웹 브라우저에서 Python 코드 작성 및 실행이 가능함\n별도의 설치 없이 바로 사용할 수 있으며, 구글 드라이브와 연동하여 작성한 파일을 클라우드에 저장하고 쉽게 관리 가능\n다양한 라이브러리(Numpy, Pandas, Matplotlib 등)가 기본적으로 설치되어 있음\nGPU, TPU 지원을 통해 대규모 데이터 처리와 딥러닝 모델 학습에 유리함\n협업 기능을 제공하여, 여러 사람이 동시에 실시간으로 작업하고 프로그램을 공유할 수 있음"
  },
  {
    "objectID": "2_1_basic.html",
    "href": "2_1_basic.html",
    "title": "2. Python 기초",
    "section": "",
    "text": "변수\n\n프로그램이 실행되는 동안 값을 저장하는 공간\n하나의 프로그램에서 여러 개의 변수를 만들어 사용할 수 있으며, 각 변수를 구분하기 위해 변수마다 이름을 붙여 관리함\n변수에는 언제든지 새로운 값을 저장할 수 있음\n(정의) 변수 이름 = 값\n\n\n\n\n대입 연산자 =\n\n변수에 값을 저장할 때 사용하는 연산자로, 할당 연산자라고도 함\n= 기호 오른쪽의 값을 = 기호 왼쪽의 변수에 저장한다는 의미\n\n\n\n# 변수에 값을 저장하고 출력\nage = 20\nprint(age)\n\n20\n\n\n\n# 변수에 저장된 값 변경\nage = 21\nprint(age)\n\n21\n\n\n\n# 여러 변수에 값 대입\na = b = c = 7\nprint(a)\nprint(b)\nprint(c)\n\n7\n7\n7\n\n\n\n# 코드 한 줄에서 여러 개의 변수에 각각 다른 값을 한번에 대입할 수 있음\na, b, c = 7, 11, 19\nprint(a)\nprint(b)\nprint(c)\n\n7\n11\n19\n\n\n\n# 두 변수의 값 교환\na = 7\nb = 11\ntemp = a\na = b\nb = temp\nprint(a, b)\n\n11 7\n\n\n\n# Python에서는 패킹과 언패킹을 활용하여 임시변수 없이 두 변수의 값을 쉽게 교환할 수 있음\na = 7\nb = 11\na, b = b, a\nprint(a, b)\n\n11 7\n\n\n\n변수 이름 규칙\n\n변수가 어떤 용도로 쓰이는지 잘 설명하는 이름으로 만드는 것이 좋음\n첫 번째 글자는 문자 또는 _이어야 하고, 나머지 글자는 문자, 숫자, _이어야 함\n영문 대문자와 소문자를 구분함\n키워드(예약어; keyword)는 변수 이름으로 사용할 수 없음\n\n키워드 : 프로그래밍 언어에서 사용하기 위해 쓰임새를 미리 정해 놓은 단어\n\n\n\n\nimport keyword\nprint(keyword.kwlist)\n\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n\n\n\n\n\n\n\n기본 자료형\n\n단순한 값을 저장하는 자료형\n(예) 정수(1,2,3,…), 부동소수점수(1.23, 3.14, …), 복소수(2+3j), 문자열(“Hello”), bool(True, False)\n\n구조적 자료형\n\n여러 개의 값을 담을 수 있는 자료형\n(예) 리스트(list), 튜플(tuple), 세트(set), 딕셔너리(dictionary)\n\ntype() 함수를 이용하여 자료형을 확인할 수 있음\n\n\n# 정수형\na = 20                      # 10진수\nb = 0o34                    # 8진수\nc = 0xA1                    # 16진수\nd = 0b1110                  # 2진수\nprint(a, b, c, d)\nprint(type(a))\n\n20 28 161 14\n&lt;class 'int'&gt;\n\n\n\n# 부동소수점수형\na = 3.14\nb = 1.23e5                  # 지수 표현 방식\nprint(a, b)\nprint(type(a))\n\n3.14 123000.0\n&lt;class 'float'&gt;\n\n\n\n# 문자열형\na = 'Hello'\nb = \"Python\"\nprint(a, b)\nprint(type(a))\n\nHello Python\n&lt;class 'str'&gt;\n\n\n\n# bool형\na = 10&gt;20\nprint(a)\nprint(type(a))\n\nFalse\n&lt;class 'bool'&gt;\n\n\n\n\n\n\n\n입력\n\n사용자로부터 데이터를 입력받기 위해 input() 함수를 이용함\ninput() 함수는 안내문을 출력한 후 사용자의 입력을 기다리며, 입력한 데이터를 문자열 형식으로 반환함\n변수 = input(안내문)\n\n출력\n\n데이터를 출력하기 위해 print() 함수를 이용함\n여러 개의 값을 출력하려면 ,로 구분한 값을 나열하면 됨\n\n\n\n# 문자열 입력\n#name = input(\"이름: \")\n#age = input(\"나이: \")\n#print(name, \"나이:\", age)\n\n\n# 정수 형식의 문자열 입력\n# input 함수를 통해서 입력받은 데이터는 문자열형임\n# 따라서 int() 함수를 이용하여 정수 형식의 문자열을 정수로 변환해야 함\n#a = int(input(\"정수: \"))\n#b = int(input(\"정수: \"))\n#print(a-b)\n\n\n# 부동소수점 형식의 문자열 입력\n# float() 함수를 이용하여 부동소수점수 형식의 문자열을 부동소수점수로 변환함\n#minute = float(input(\"분 단위 시간: \"))\n#second = minute * 60\n#print(second, \"초\")\n\n\n# 문자열 출력\nprint(\"반갑습니다.\")\nscore = 99\nprint(\"성적은\", score, \"입니다.\")\n\n반갑습니다.\n성적은 99 입니다.\n\n\n\n# print() 함수가 여러 개일 때는 다음 줄로 넘어가서 값을 출력함\na = 25\nb = 42\nprint(a)\nprint(b)\n\n25\n42\n\n\n\n# print() 함수가 여러 개일 때 다음 줄로 넘어가는 대신 공백이 출력되기를 원하면 end 매개변수를 공백으로 설정함\na = 25\nb = 42\nprint(a, end=' ')\nprint(b)\n\n25 42\n\n\n\nf-문자열(f-string)\n\n문자열 앞에 소문자 f나 대문자 F를 붙이고, 문자열 안의 변수를 {}로 감싸서 표현하는 것\nf-문자열을 이용하면 변수 값이 출력되는 형식을 지정할 수 있음\n\n\n\n# f-문자열 사용\nname = \"홍길동\"\nage = 20\nprint(f\"이름은 {name}이고, 나이는 {age}입니다.\")\n\n이름은 홍길동이고, 나이는 20입니다.\n\n\n\n# f-문자열 출력 형식 지정\n# 변수명 옆에 :을 작성한 다음 형식을 지정함\nname = \"홍길동\"\nage = 20\nprint(f\"{name:5}, {age:3}\")\n\na = 4\nb = 3.14159265\nprint(f\"20{a:02d}\")                        # a 값을 두자리로 출력하되 앞의 빈곳은 0으로 채움\nprint(f\"{b:.3f}\")                          # b 값을 소수점 이하 세자리로 반올림하여 출력\n\n홍길동  ,  20\n2004\n3.142\n\n\n\n# 원의 넓이 구하기\n#pi = 3.14159265\n#radius = int(input(\"원의 반지름: \"))\n#area = pi * radius * radius\n#print(f\"원의 넓이: {area:.3f}\")\n\n\n\n\n\n\n연산(operation) : 덧셈, 뺄셈 등과 같이 일정한 규칙에 따라 계산하는 것\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n+\n더하기\nprint(6+4)\n10\n\n\n-\n빼기\nprint(6-4)\n2\n\n\n*\n곱하기\nprint(6*4)\n24\n\n\n/\n나누기\nprint(6/4)\n1.5\n\n\n//\n나눈 정수 몫\nprint(6//4)\n1\n\n\n%\n나눈 나머지\nprint(6%4)\n2\n\n\n**\n거듭제곱\nprint(6**4)\n1296\n\n\n\n\n\n\n\n\n크기를 비교할 때 사용하는 연산자\n연산 결과는 참(True) 또는 거짓(False)으로 나타남\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n==\n같다\nprint(10==20)\nFalse\n\n\n!=\n같지 않다\nprint(10!=20)\nTrue\n\n\n&gt;\n크다\nprint(10&gt;20)\nFalse\n\n\n&lt;\n작다\nprint(10&lt;20)\nTrue\n\n\n&gt;=\n크거나 같다\nprint(10&gt;=20)\nFalse\n\n\n&lt;=\n작거나 같다\nprint(10&lt;=20)\nTrue\n\n\n\n\n\n\n\n\n참과 거짓의 논리 동작을 다루는 연산\n여러 조건을 조합할 때 주로 사용함\n\n\n\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\nand\n왼쪽 식과 오른쪽 식 모두 참인 경우에만 True\na=25 print(a&gt;8 and a&lt;60)\nTrue\n\n\nor\n왼쪽 식과 오른쪽 식 중 하나라도 참인 경우에만 True\na=70 print(a&lt;8 or a&gt;=60)\nTrue\n\n\nnot\n오른쪽 식이 참이면 False, 거짓이면 True\na=20 print(not a==20)\nFalse\n\n\n\n\n\n\n\n\n연산한 값을 다시 대입하는 연산자\n\n\n\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n+=\n왼쪽 값에 오른쪽 값을 더한 결과를 다시 왼쪽에 대입\na, b = 2, 3 a += b  print(a)\n5\n\n\n-=\n왼쪽 값에 오른쪽 값을 뺀 결과를 다시 왼쪽에 대입\na, b = 2, 3 a -= b  print(a)\n-1\n\n\n*=\n왼쪽 값에 오른쪽 값을 곱한 결과를 다시 왼쪽에 대입\na, b = 2, 3 a *= b  print(a)\n6\n\n\n/=\n왼쪽 값에 오른쪽 값을 나눈 결과를 다시 왼쪽에 대입\na, b = 3, 2 a /= b  print(a)\n1.5\n\n\n//=\n왼쪽 값에 오른쪽 값을 나눈 몫을 다시 왼쪽에 대입\na, b = 7, 3 a //= b  print(a)\n2\n\n\n%=\n왼쪽 값에 오른쪽 값을 나눈 나머지를 다시 왼쪽에 대입\na, b = 7, 3 a %= b  print(a)\n1\n\n\n\n\n\n\n\n\n프로그래밍 언어는 연산자에 우선순위를 부여하여 우선순위가 높은 연산자를 먼저 계산함\n우선순위에 관계없이 연산의 순서를 정하려면 괄호()를 사용함\n\n\n\n\n우선순위\n연산자\n설명\n\n\n\n\n1\n**\n거듭제곱 연산자\n\n\n2\n+, -\n양수, 음수를 나타내는 단항 연산자\n\n\n3\n*, /, //, %\n곱셈, 나눗셈, 나눈 몫, 나머지\n\n\n4\n+, -\n덧셈, 뺄셈\n\n\n5\n&lt;, &lt;=, &gt;, &gt;=\n비교 연산자\n\n\n6\n==, !=\n동등 연산자\n\n\n7\n=, +=, -=, /=, //=, %=, **=\n대입 연산자\n\n\n8\nnot\n논리 연산자\n\n\n9\nand\n논리 연산자\n\n\n10\nor\n논리 연산자\n\n\n\n\n# 정수 3개의 평균 계산(틀림)\navg = 70 + 80 + 90 / 3\nprint(avg)\n\n180.0\n\n\n\n# 정수 3개의 평균 계산\navg = (70 + 80 + 90) / 3\nprint(avg)\n\n80.0\n\n\n\n# 길이 단위 변환\n#_cm = int(input(\"센티미터 단위 길이: \"))\n#m = _cm // 100\n#cm = _cm % 100\n#print(f'{m}미터 {cm}센티미터')"
  },
  {
    "objectID": "2_1_basic.html#기초-문법",
    "href": "2_1_basic.html#기초-문법",
    "title": "2. Python 기초",
    "section": "",
    "text": "변수\n\n프로그램이 실행되는 동안 값을 저장하는 공간\n하나의 프로그램에서 여러 개의 변수를 만들어 사용할 수 있으며, 각 변수를 구분하기 위해 변수마다 이름을 붙여 관리함\n변수에는 언제든지 새로운 값을 저장할 수 있음\n(정의) 변수 이름 = 값\n\n\n\n\n대입 연산자 =\n\n변수에 값을 저장할 때 사용하는 연산자로, 할당 연산자라고도 함\n= 기호 오른쪽의 값을 = 기호 왼쪽의 변수에 저장한다는 의미\n\n\n\n# 변수에 값을 저장하고 출력\nage = 20\nprint(age)\n\n20\n\n\n\n# 변수에 저장된 값 변경\nage = 21\nprint(age)\n\n21\n\n\n\n# 여러 변수에 값 대입\na = b = c = 7\nprint(a)\nprint(b)\nprint(c)\n\n7\n7\n7\n\n\n\n# 코드 한 줄에서 여러 개의 변수에 각각 다른 값을 한번에 대입할 수 있음\na, b, c = 7, 11, 19\nprint(a)\nprint(b)\nprint(c)\n\n7\n11\n19\n\n\n\n# 두 변수의 값 교환\na = 7\nb = 11\ntemp = a\na = b\nb = temp\nprint(a, b)\n\n11 7\n\n\n\n# Python에서는 패킹과 언패킹을 활용하여 임시변수 없이 두 변수의 값을 쉽게 교환할 수 있음\na = 7\nb = 11\na, b = b, a\nprint(a, b)\n\n11 7\n\n\n\n변수 이름 규칙\n\n변수가 어떤 용도로 쓰이는지 잘 설명하는 이름으로 만드는 것이 좋음\n첫 번째 글자는 문자 또는 _이어야 하고, 나머지 글자는 문자, 숫자, _이어야 함\n영문 대문자와 소문자를 구분함\n키워드(예약어; keyword)는 변수 이름으로 사용할 수 없음\n\n키워드 : 프로그래밍 언어에서 사용하기 위해 쓰임새를 미리 정해 놓은 단어\n\n\n\n\nimport keyword\nprint(keyword.kwlist)\n\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n\n\n\n\n\n\n\n기본 자료형\n\n단순한 값을 저장하는 자료형\n(예) 정수(1,2,3,…), 부동소수점수(1.23, 3.14, …), 복소수(2+3j), 문자열(“Hello”), bool(True, False)\n\n구조적 자료형\n\n여러 개의 값을 담을 수 있는 자료형\n(예) 리스트(list), 튜플(tuple), 세트(set), 딕셔너리(dictionary)\n\ntype() 함수를 이용하여 자료형을 확인할 수 있음\n\n\n# 정수형\na = 20                      # 10진수\nb = 0o34                    # 8진수\nc = 0xA1                    # 16진수\nd = 0b1110                  # 2진수\nprint(a, b, c, d)\nprint(type(a))\n\n20 28 161 14\n&lt;class 'int'&gt;\n\n\n\n# 부동소수점수형\na = 3.14\nb = 1.23e5                  # 지수 표현 방식\nprint(a, b)\nprint(type(a))\n\n3.14 123000.0\n&lt;class 'float'&gt;\n\n\n\n# 문자열형\na = 'Hello'\nb = \"Python\"\nprint(a, b)\nprint(type(a))\n\nHello Python\n&lt;class 'str'&gt;\n\n\n\n# bool형\na = 10&gt;20\nprint(a)\nprint(type(a))\n\nFalse\n&lt;class 'bool'&gt;\n\n\n\n\n\n\n\n입력\n\n사용자로부터 데이터를 입력받기 위해 input() 함수를 이용함\ninput() 함수는 안내문을 출력한 후 사용자의 입력을 기다리며, 입력한 데이터를 문자열 형식으로 반환함\n변수 = input(안내문)\n\n출력\n\n데이터를 출력하기 위해 print() 함수를 이용함\n여러 개의 값을 출력하려면 ,로 구분한 값을 나열하면 됨\n\n\n\n# 문자열 입력\n#name = input(\"이름: \")\n#age = input(\"나이: \")\n#print(name, \"나이:\", age)\n\n\n# 정수 형식의 문자열 입력\n# input 함수를 통해서 입력받은 데이터는 문자열형임\n# 따라서 int() 함수를 이용하여 정수 형식의 문자열을 정수로 변환해야 함\n#a = int(input(\"정수: \"))\n#b = int(input(\"정수: \"))\n#print(a-b)\n\n\n# 부동소수점 형식의 문자열 입력\n# float() 함수를 이용하여 부동소수점수 형식의 문자열을 부동소수점수로 변환함\n#minute = float(input(\"분 단위 시간: \"))\n#second = minute * 60\n#print(second, \"초\")\n\n\n# 문자열 출력\nprint(\"반갑습니다.\")\nscore = 99\nprint(\"성적은\", score, \"입니다.\")\n\n반갑습니다.\n성적은 99 입니다.\n\n\n\n# print() 함수가 여러 개일 때는 다음 줄로 넘어가서 값을 출력함\na = 25\nb = 42\nprint(a)\nprint(b)\n\n25\n42\n\n\n\n# print() 함수가 여러 개일 때 다음 줄로 넘어가는 대신 공백이 출력되기를 원하면 end 매개변수를 공백으로 설정함\na = 25\nb = 42\nprint(a, end=' ')\nprint(b)\n\n25 42\n\n\n\nf-문자열(f-string)\n\n문자열 앞에 소문자 f나 대문자 F를 붙이고, 문자열 안의 변수를 {}로 감싸서 표현하는 것\nf-문자열을 이용하면 변수 값이 출력되는 형식을 지정할 수 있음\n\n\n\n# f-문자열 사용\nname = \"홍길동\"\nage = 20\nprint(f\"이름은 {name}이고, 나이는 {age}입니다.\")\n\n이름은 홍길동이고, 나이는 20입니다.\n\n\n\n# f-문자열 출력 형식 지정\n# 변수명 옆에 :을 작성한 다음 형식을 지정함\nname = \"홍길동\"\nage = 20\nprint(f\"{name:5}, {age:3}\")\n\na = 4\nb = 3.14159265\nprint(f\"20{a:02d}\")                        # a 값을 두자리로 출력하되 앞의 빈곳은 0으로 채움\nprint(f\"{b:.3f}\")                          # b 값을 소수점 이하 세자리로 반올림하여 출력\n\n홍길동  ,  20\n2004\n3.142\n\n\n\n# 원의 넓이 구하기\n#pi = 3.14159265\n#radius = int(input(\"원의 반지름: \"))\n#area = pi * radius * radius\n#print(f\"원의 넓이: {area:.3f}\")\n\n\n\n\n\n\n연산(operation) : 덧셈, 뺄셈 등과 같이 일정한 규칙에 따라 계산하는 것\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n+\n더하기\nprint(6+4)\n10\n\n\n-\n빼기\nprint(6-4)\n2\n\n\n*\n곱하기\nprint(6*4)\n24\n\n\n/\n나누기\nprint(6/4)\n1.5\n\n\n//\n나눈 정수 몫\nprint(6//4)\n1\n\n\n%\n나눈 나머지\nprint(6%4)\n2\n\n\n**\n거듭제곱\nprint(6**4)\n1296\n\n\n\n\n\n\n\n\n크기를 비교할 때 사용하는 연산자\n연산 결과는 참(True) 또는 거짓(False)으로 나타남\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n==\n같다\nprint(10==20)\nFalse\n\n\n!=\n같지 않다\nprint(10!=20)\nTrue\n\n\n&gt;\n크다\nprint(10&gt;20)\nFalse\n\n\n&lt;\n작다\nprint(10&lt;20)\nTrue\n\n\n&gt;=\n크거나 같다\nprint(10&gt;=20)\nFalse\n\n\n&lt;=\n작거나 같다\nprint(10&lt;=20)\nTrue\n\n\n\n\n\n\n\n\n참과 거짓의 논리 동작을 다루는 연산\n여러 조건을 조합할 때 주로 사용함\n\n\n\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\nand\n왼쪽 식과 오른쪽 식 모두 참인 경우에만 True\na=25 print(a&gt;8 and a&lt;60)\nTrue\n\n\nor\n왼쪽 식과 오른쪽 식 중 하나라도 참인 경우에만 True\na=70 print(a&lt;8 or a&gt;=60)\nTrue\n\n\nnot\n오른쪽 식이 참이면 False, 거짓이면 True\na=20 print(not a==20)\nFalse\n\n\n\n\n\n\n\n\n연산한 값을 다시 대입하는 연산자\n\n\n\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n+=\n왼쪽 값에 오른쪽 값을 더한 결과를 다시 왼쪽에 대입\na, b = 2, 3 a += b  print(a)\n5\n\n\n-=\n왼쪽 값에 오른쪽 값을 뺀 결과를 다시 왼쪽에 대입\na, b = 2, 3 a -= b  print(a)\n-1\n\n\n*=\n왼쪽 값에 오른쪽 값을 곱한 결과를 다시 왼쪽에 대입\na, b = 2, 3 a *= b  print(a)\n6\n\n\n/=\n왼쪽 값에 오른쪽 값을 나눈 결과를 다시 왼쪽에 대입\na, b = 3, 2 a /= b  print(a)\n1.5\n\n\n//=\n왼쪽 값에 오른쪽 값을 나눈 몫을 다시 왼쪽에 대입\na, b = 7, 3 a //= b  print(a)\n2\n\n\n%=\n왼쪽 값에 오른쪽 값을 나눈 나머지를 다시 왼쪽에 대입\na, b = 7, 3 a %= b  print(a)\n1\n\n\n\n\n\n\n\n\n프로그래밍 언어는 연산자에 우선순위를 부여하여 우선순위가 높은 연산자를 먼저 계산함\n우선순위에 관계없이 연산의 순서를 정하려면 괄호()를 사용함\n\n\n\n\n우선순위\n연산자\n설명\n\n\n\n\n1\n**\n거듭제곱 연산자\n\n\n2\n+, -\n양수, 음수를 나타내는 단항 연산자\n\n\n3\n*, /, //, %\n곱셈, 나눗셈, 나눈 몫, 나머지\n\n\n4\n+, -\n덧셈, 뺄셈\n\n\n5\n&lt;, &lt;=, &gt;, &gt;=\n비교 연산자\n\n\n6\n==, !=\n동등 연산자\n\n\n7\n=, +=, -=, /=, //=, %=, **=\n대입 연산자\n\n\n8\nnot\n논리 연산자\n\n\n9\nand\n논리 연산자\n\n\n10\nor\n논리 연산자\n\n\n\n\n# 정수 3개의 평균 계산(틀림)\navg = 70 + 80 + 90 / 3\nprint(avg)\n\n180.0\n\n\n\n# 정수 3개의 평균 계산\navg = (70 + 80 + 90) / 3\nprint(avg)\n\n80.0\n\n\n\n# 길이 단위 변환\n#_cm = int(input(\"센티미터 단위 길이: \"))\n#m = _cm // 100\n#cm = _cm % 100\n#print(f'{m}미터 {cm}센티미터')"
  },
  {
    "objectID": "2_3_loop.html",
    "href": "2_3_loop.html",
    "title": "2. Python 기초",
    "section": "",
    "text": "for 반복변수 in 반복범위:  　　문장\n\n\n반복범위를 지정하여(정해진 횟수만큼) 반복해서 문장을 실행함\n반복범위 오른쪽에는 :이 위치하고, 반복해서 실행할 문장은 반드시 들여쓰기해야 함\n반복범위에는 범위, 문자열, 리스트, 딕셔너리 등이 사용될 수 있음\n\n그 중 범위가 가장 많이 사용되며, range() 함수로 만들 수 있음\n\n\n\n\n\n\n\n\n\n\n\n형식\n설명\n예시\n결과\n\n\n\n\nrange(종료값)\n0으로 시작해서 1씩 증가하며 종료값 전까지의 정수를 생성\nrange(5)\n0,1,2,3,4\n\n\nrange(시작값, 종료값)\n시작값으로 시작해서 1씩 증가하며 종료값 전까지의 정수를 생성\nrang(2,7)\n2,3,4,5,6\n\n\nrange(시작값, 종료값, 증가값)\n시작값으로 시작해서 증가값만큼 증가시키면서 종료값 전까지의 정수를 생성\nrange(2,11,3)\n2,5,8\n\n\n\n\n# 문자열을 3번 반복해서 출력\nfor i in range(3):\n    print(\"Hello!\")\n\nHello!\nHello!\nHello!\n\n\n\n# 반복범위의 값을 출력1\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\n\n# 반복범위의 값을 출력2\nfor i in \"World\":\n    print(i)\n\nW\no\nr\nl\nd\n\n\n\n# 1~100 정수의 합 계산\nsum = 0\n\nfor i in range(1,101):\n    sum += i\n\nprint(sum)\n\n5050\n\n\n\n# 30의 약수 출력\nnum = 30\n\nfor i in range(1, num+1):\n    if num%i == 0:\n        print(i, end=' ')\n\n1 2 3 5 6 10 15 30 \n\n\n\n\n\n\n\nwhile 조건식:  　　문장\n\n\n조건이 참인 동안 문장을 반복해서 실행하고, 조건이 거짓이면 반복문을 종료함\n\n\n# 1~100 정수의 합 계산\nsum = 0\nnum = 1\n\nwhile num&lt;=100:\n    sum += num\n    num += 1\n\nprint(sum)\n\n5050\n\n\n\n# 구구단 9단 출력\nnum = 1\n\nwhile num&lt;=9:\n    print(f'9x{num}={9*num}')\n    num += 1\n\n9x1=9\n9x2=18\n9x3=27\n9x4=36\n9x5=45\n9x6=54\n9x7=63\n9x8=72\n9x9=81"
  },
  {
    "objectID": "2_3_loop.html#반복문",
    "href": "2_3_loop.html#반복문",
    "title": "2. Python 기초",
    "section": "",
    "text": "for 반복변수 in 반복범위:  　　문장\n\n\n반복범위를 지정하여(정해진 횟수만큼) 반복해서 문장을 실행함\n반복범위 오른쪽에는 :이 위치하고, 반복해서 실행할 문장은 반드시 들여쓰기해야 함\n반복범위에는 범위, 문자열, 리스트, 딕셔너리 등이 사용될 수 있음\n\n그 중 범위가 가장 많이 사용되며, range() 함수로 만들 수 있음\n\n\n\n\n\n\n\n\n\n\n\n형식\n설명\n예시\n결과\n\n\n\n\nrange(종료값)\n0으로 시작해서 1씩 증가하며 종료값 전까지의 정수를 생성\nrange(5)\n0,1,2,3,4\n\n\nrange(시작값, 종료값)\n시작값으로 시작해서 1씩 증가하며 종료값 전까지의 정수를 생성\nrang(2,7)\n2,3,4,5,6\n\n\nrange(시작값, 종료값, 증가값)\n시작값으로 시작해서 증가값만큼 증가시키면서 종료값 전까지의 정수를 생성\nrange(2,11,3)\n2,5,8\n\n\n\n\n# 문자열을 3번 반복해서 출력\nfor i in range(3):\n    print(\"Hello!\")\n\nHello!\nHello!\nHello!\n\n\n\n# 반복범위의 값을 출력1\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\n\n# 반복범위의 값을 출력2\nfor i in \"World\":\n    print(i)\n\nW\no\nr\nl\nd\n\n\n\n# 1~100 정수의 합 계산\nsum = 0\n\nfor i in range(1,101):\n    sum += i\n\nprint(sum)\n\n5050\n\n\n\n# 30의 약수 출력\nnum = 30\n\nfor i in range(1, num+1):\n    if num%i == 0:\n        print(i, end=' ')\n\n1 2 3 5 6 10 15 30 \n\n\n\n\n\n\n\nwhile 조건식:  　　문장\n\n\n조건이 참인 동안 문장을 반복해서 실행하고, 조건이 거짓이면 반복문을 종료함\n\n\n# 1~100 정수의 합 계산\nsum = 0\nnum = 1\n\nwhile num&lt;=100:\n    sum += num\n    num += 1\n\nprint(sum)\n\n5050\n\n\n\n# 구구단 9단 출력\nnum = 1\n\nwhile num&lt;=9:\n    print(f'9x{num}={9*num}')\n    num += 1\n\n9x1=9\n9x2=18\n9x3=27\n9x4=36\n9x5=45\n9x6=54\n9x7=63\n9x8=72\n9x9=81"
  },
  {
    "objectID": "2_5_string.html",
    "href": "2_5_string.html",
    "title": "2. Python 기초",
    "section": "",
    "text": "문자열(string)\n\n문자(character)들이 나열된 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에는 수정할 수 없는 불변형(immutable) 객체\n큰 따옴표 \" 또는 작은 따옴표'로 감싸서 문자열을 생성함\n\n\n\n\n이스케이프 문자(escape character)\n\n\\ 기호와 함께 조합해서 사용하는 특수한 문자\n\\\" : 큰 따옴표\n\\' : 작은 따옴표\n\\n : 줄 바꿈(new line)\n\\t : 탭(tab)\n\n\n\n# 문자열 생성\nprint(\"안녕하세요\")\nprint('Hello')\n\n안녕하세요\nHello\n\n\n\n# 문자열 내부에 따옴표 넣기\nprint('\"안녕하세요\"라고 말했습니다.')\nprint(\"'날씨가 좋다'라고 생각했습니다.\")\n\n\"안녕하세요\"라고 말했습니다.\n'날씨가 좋다'라고 생각했습니다.\n\n\n\n# 이스케이프 문자 사용1\nprint(\"\\\"안녕하세요\\\"라고 말했습니다.\")\nprint('\\'날씨가 좋다\\'라고 생각했습니다.')\n\n\"안녕하세요\"라고 말했습니다.\n'날씨가 좋다'라고 생각했습니다.\n\n\n\n# 이스케이프 문자 사용2\nprint(\"Hello\\nWorld\")\n\nHello\nWorld\n\n\n\n# 이스케이프 문자 사용3\nprint(\"Hello\\tWorld\")\n\nHello   World\n\n\n\n# 여러 줄 문자열 만들기 : 세 번 반복한 따옴표로 감쌈\nprint(\"\"\"동해물과 백두산이 마르고 닳도록\n하느님이 보우하사 우리나라 만세\n무궁화 삼천리 화려강산\n대한사람 대한으로 길이 보전하세\"\"\")\n\n동해물과 백두산이 마르고 닳도록\n하느님이 보우하사 우리나라 만세\n무궁화 삼천리 화려강산\n대한사람 대한으로 길이 보전하세\n\n\n\n\n\n\n\n문자열 연결 연산자 + : 두 문자열을 연결해서 새로운 문자열 생성\n문자열 반복 연산자 * : 문자열을 숫자만큼 반복하여 새로운 문자열 생성 - (예) 문자열*숫자\n\n\n# 문자열 연결\nprint(\"Hello \" + \"Wolrld\")\n\nHello Wolrld\n\n\n\n# 문자열 연결 연산자는 문자열과 숫자를 연결할 수 없음\n#score = 99\n#print(\"성적은\" + score + \"입니다.\")\n\n\n# 문자열 연결 연산자로 문자열과 숫자를 연결하려면 숫자를 문자열로 변환해야 함\nscore = 99\nprint(\"성적은\" + str(score) + \"입니다.\")\n\n성적은99입니다.\n\n\n\n# 문자열 반복\nprint(\"Hello \" * 3)\n\nHello Hello Hello \n\n\n\n\n\n\n\n문자열의 각 문자에 접근할 때 문자 위치인 인덱스(index)를 사용함\n\nPython은 숫자를 0부터 세는 제로 인덱스(zero index) 유형을 사용함\n\n\n\n\n인덱싱(indexing)\n\n[index]를 사용하여 문자열의 특정 위치에 있는 항목(문자)에 접근하는 것\n리버스 인덱싱(reverse indexing) : 음수 인덱스를 사용하면 마지막 값부터 -1씩 감소하여 역순으로 접근할 수 있음\n\n\n\n\n슬라이싱(slicing)\n\n[(start index):(stop index)]를 이용하여 문자열의 일부 문자를 추출하는 것\n끝 인덱스는 포함하지 않으니 주의해야 함\n시작 인덱스를 생략하면 첫 번째 글자부터 추출하며, 끝 인덱스를 생략하면 가장 마지막 글자까지 추출함\n\n\n\n\n# 문자열 인덱싱1\ns = \"안녕하세요\"\nprint(s[0])\n\n안\n\n\n\n# 문자열 인덱싱2\ns = \"안녕하세요\"\nprint(s[-1])\n\n요\n\n\n\n# 문자열 슬라이싱1\ns = \"안녕하세요\"\nprint(s[0:2])\n\n안녕\n\n\n\n# 문자열 슬라이싱2\ns = \"안녕하세요\"\nprint(s[:2])\nprint(s[2:])\nprint(s[::2])\n\n안녕\n하세요\n안하요\n\n\n\n# 문자열은 불변형 객체이므로 인덱스를 이용한 수정은 불가능함\n#s = \"안녕하세요\"\n#s[2:5] = \"하십니까\"\n#print(s)\n\n\n# 문자열을 변경하려면 새로운 문자열을 만들어야 함\ns = \"안녕하세요\"\ns = s[:2] + \"하십니까\"\nprint(s)\n\n안녕하십니까\n\n\n\n# 문자열 거꾸로 출력하기\nmy_str = \"Hello Python!\"\nprint(my_str[::-1])\n\n!nohtyP olleH\n\n\n\n\n\n\n\n\n\nlen() 함수 : 문자열에 들어있는 문자의 개수(문자열의 길이) 반환\n\n\n# 문자열 길이\ns = \"안녕하세요\"\nprint(len(s))\n\n5\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nlower()\n문자열의 알파벳을 모두 소문자로 변환\n\n\nupper()\n문자열의 알파벳을 모두 대문자로 변환\n\n\n\n\n# 대소문자 변환 : 원본은 변하지 않음\ns = \"Hello Python!\"\nprint(s.lower())\nprint(s.upper())\nprint(s)\n\nhello python!\nHELLO PYTHON!\nHello Python!\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nfind()\n- 문자열에서 특정 문자열을 왼쪽에서부터 찾아서 인덱스를 반환 - 찾는 문자열이 없으면 -1을 반환\n\n\nrfind()\n- 문자열에서 특정 문자열을 오른쪽에서부터 찾아서 인덱스를 반환 - 찾는 문자열이 없으면 -1을 반환\n\n\ncount()\n- 문자열에서 특정 문자열의 개수를 반환\n\n\nin 연산자\n- 문자열 내부에 특정 문자열이 있다면 True, 없다면 False를 반환\n\n\n\n\n# 문자열 찾기\ns = \"Hello! Python is Python\"\nprint(s.find(\"Python\"))\nprint(s.rfind(\"Python\"))\nprint(s.count(\"Python\"))\nprint(\"Hello\" in s)\nprint(\"Hi\" in s)\n\n7\n17\n2\nTrue\nFalse\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nstrip()\n문자열 양 옆의 공백이나 특정 문자를 제거\n\n\nrstrip()\n문자열 오른쪽의 공백이나 특정 문자를 제거\n\n\nlstrip()\n문자열 왼쪽의 공백이나 특정 문자를 제거\n\n\nreplace()\n특정 문자열을 다른 문자열로 변경\n\n\n\n\n# 공백 제거\ns = \"  Hello Python!  \"\nprint(s)\nprint(s.strip())\n\n  Hello Python!  \nHello Python!\n\n\n\n# 특정 문자 제거\ns = \"##100kg, ##200kg\"\nprint(s.rstrip(\"kg\"))\nprint(s.lstrip(\"#\"))\n\n##100kg, ##200\n100kg, ##200kg\n\n\n\n# 문자열 변경\ns = \"Hello Python!\"\nprint(s.replace(\"Hello\", \"Hi\"))\n\nHi Python!\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nsplit()\n- 특정문자를 기준으로 문자열을 분리하고 리스트로 반환\n\n\njoin()\n- 여러 문자열을 모아서 하나의 문자열로 만듬 - 문자열을 구분할 구분자를 지정해야 함\n\n\n\n\n# 문자열 분리\ns = \"Hello Python!\"\ns.split(\" \")\n\n['Hello', 'Python!']\n\n\n\n# 문자열 결합\nlst = [\"one\", \"two\", \"three\"]\nprint(\", \".join(lst))\nprint(\" - \".join(lst))\n\none, two, three\none - two - three\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nisdigit()\n문자열이 숫자로만 구성되었는지 확인\n\n\nisalpha()\n문자열이 알파벳으로만 구성되었는지 확인\n\n\nisalnum()\n문자열이 알파벳과 숫자로만 구성되었는지 확인\n\n\nislower()\n문자열이 소문자로만 구성되었는지 확인\n\n\nisupper()\n문자열이 대문자로만 구성되었는지 확인\n\n\nisspace()\n문자열이 공백으로만 구성되었는지 확인\n\n\n\n\n# 문자열 구성 파악\nprint(\"1234\".isdigit())\nprint(\"Python\".isalpha())\nprint(\"pass123\".isalnum())\nprint(\"hello\".islower())\nprint(\"HELLO\".isupper())\nprint(\"     \".isspace())\n\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nstr()\n수를 문자열로 변환\n\n\nint()\n정수 형식의 문자열이나 실수를 정수로 변환\n\n\nfloat()\n실수 형식의 문자열이나 정수를 실수로 변환\n\n\n\n\n# 형 변환1\na = 1234\n#print(a + \"kg\")\nprint(str(a) + \"kg\")\n\n1234kg\n\n\n\n# 형 변환2\nprint(int(\"1234\"))\nprint(float(\"3.14\"))\n\n1234\n3.14\n\n\n\n\n\n\n\n“{자료형}”.format(인수)\n\n\n\n{}를 포함한 문자열 뒤에 .을 찍고 format() 함수를 사용하여 문자열이 출력되는 형식을 지정할 수 있음\n\n앞쪽에 있는 문자열 안의 {} 기호가 format() 함수의 매개변수로 차례로 대치되면서 숫자가 문자열이 됨\n{} 개수와 format() 함수의 매개변수 개수는 반드시 같아야 함\n\nf-문자열이 format() 함수보다 간단하고 직관적이므로, 대부분 f-문자열을 사용함\n\n\n\nf-문자열보다 format() 함수를 사용하는 것이 더 좋은 경우\n\n문자열 내용이 너무 많을 때 - 어떤 데이터를 출력하는지 모아서 볼 수 있어 더 유용함\n데이터를 리스트에 담아서 사용할 때\n\n\n\n# format() 함수1\nprint(\"{}\".format(10))\nprint(\"{} {}\".format(10, 20))\nprint(\"{} {} {} {} {}\".format(10, 20, 30, 40, 50))\n\n10\n10 20\n10 20 30 40 50\n\n\n\n# format() 함수2\nname = \"홍길동\"\nage = 20\nprint(f\"이름은 {name}이고, 나이는 {age}입니다.\")\nprint(\"이름은 {}이고, 나이는 {}입니다.\".format(name, age))\n\n이름은 홍길동이고, 나이는 20입니다.\n이름은 홍길동이고, 나이는 20입니다.\n\n\n\n# format() 함수3\na = 4\nb = 3.14159265\nprint(\"20{:02d}\".format(a))                # a 값을 두자리로 출력하되 앞의 빈곳은 0으로 채움\nprint(\"{:.3f}\".format(b))                  # b 값을 소수점 이하 세자리로 반올림하여 출력\n\n2004\n3.142\n\n\n\n# 데이터를 리스트에 담아서 사용할 때는 format() 함수를 사용하는 것이 더 좋음\ndata = [\"별\", 2, \"M\", \"Yes\"]\n\n# f-문자열 사용\nprint(f\"이름: {data[0]}, 나이: {data[1]}, 성별: {data[2]}, 중성화 여부: {data[3]}\")\n\n# format() 함수 사용\n# 전개 연산자 *를 사용하여 리스트 내용을 전개함\nprint(\"이름: {}, 나이: {}, 성별: {}, 중성화 여부: {}\".format(*data))\n\n이름: 별, 나이: 2, 성별: M, 중성화 여부: Yes\n이름: 별, 나이: 2, 성별: M, 중성화 여부: Yes"
  },
  {
    "objectID": "2_5_string.html#문자열",
    "href": "2_5_string.html#문자열",
    "title": "2. Python 기초",
    "section": "",
    "text": "문자열(string)\n\n문자(character)들이 나열된 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에는 수정할 수 없는 불변형(immutable) 객체\n큰 따옴표 \" 또는 작은 따옴표'로 감싸서 문자열을 생성함\n\n\n\n\n이스케이프 문자(escape character)\n\n\\ 기호와 함께 조합해서 사용하는 특수한 문자\n\\\" : 큰 따옴표\n\\' : 작은 따옴표\n\\n : 줄 바꿈(new line)\n\\t : 탭(tab)\n\n\n\n# 문자열 생성\nprint(\"안녕하세요\")\nprint('Hello')\n\n안녕하세요\nHello\n\n\n\n# 문자열 내부에 따옴표 넣기\nprint('\"안녕하세요\"라고 말했습니다.')\nprint(\"'날씨가 좋다'라고 생각했습니다.\")\n\n\"안녕하세요\"라고 말했습니다.\n'날씨가 좋다'라고 생각했습니다.\n\n\n\n# 이스케이프 문자 사용1\nprint(\"\\\"안녕하세요\\\"라고 말했습니다.\")\nprint('\\'날씨가 좋다\\'라고 생각했습니다.')\n\n\"안녕하세요\"라고 말했습니다.\n'날씨가 좋다'라고 생각했습니다.\n\n\n\n# 이스케이프 문자 사용2\nprint(\"Hello\\nWorld\")\n\nHello\nWorld\n\n\n\n# 이스케이프 문자 사용3\nprint(\"Hello\\tWorld\")\n\nHello   World\n\n\n\n# 여러 줄 문자열 만들기 : 세 번 반복한 따옴표로 감쌈\nprint(\"\"\"동해물과 백두산이 마르고 닳도록\n하느님이 보우하사 우리나라 만세\n무궁화 삼천리 화려강산\n대한사람 대한으로 길이 보전하세\"\"\")\n\n동해물과 백두산이 마르고 닳도록\n하느님이 보우하사 우리나라 만세\n무궁화 삼천리 화려강산\n대한사람 대한으로 길이 보전하세\n\n\n\n\n\n\n\n문자열 연결 연산자 + : 두 문자열을 연결해서 새로운 문자열 생성\n문자열 반복 연산자 * : 문자열을 숫자만큼 반복하여 새로운 문자열 생성 - (예) 문자열*숫자\n\n\n# 문자열 연결\nprint(\"Hello \" + \"Wolrld\")\n\nHello Wolrld\n\n\n\n# 문자열 연결 연산자는 문자열과 숫자를 연결할 수 없음\n#score = 99\n#print(\"성적은\" + score + \"입니다.\")\n\n\n# 문자열 연결 연산자로 문자열과 숫자를 연결하려면 숫자를 문자열로 변환해야 함\nscore = 99\nprint(\"성적은\" + str(score) + \"입니다.\")\n\n성적은99입니다.\n\n\n\n# 문자열 반복\nprint(\"Hello \" * 3)\n\nHello Hello Hello \n\n\n\n\n\n\n\n문자열의 각 문자에 접근할 때 문자 위치인 인덱스(index)를 사용함\n\nPython은 숫자를 0부터 세는 제로 인덱스(zero index) 유형을 사용함\n\n\n\n\n인덱싱(indexing)\n\n[index]를 사용하여 문자열의 특정 위치에 있는 항목(문자)에 접근하는 것\n리버스 인덱싱(reverse indexing) : 음수 인덱스를 사용하면 마지막 값부터 -1씩 감소하여 역순으로 접근할 수 있음\n\n\n\n\n슬라이싱(slicing)\n\n[(start index):(stop index)]를 이용하여 문자열의 일부 문자를 추출하는 것\n끝 인덱스는 포함하지 않으니 주의해야 함\n시작 인덱스를 생략하면 첫 번째 글자부터 추출하며, 끝 인덱스를 생략하면 가장 마지막 글자까지 추출함\n\n\n\n\n# 문자열 인덱싱1\ns = \"안녕하세요\"\nprint(s[0])\n\n안\n\n\n\n# 문자열 인덱싱2\ns = \"안녕하세요\"\nprint(s[-1])\n\n요\n\n\n\n# 문자열 슬라이싱1\ns = \"안녕하세요\"\nprint(s[0:2])\n\n안녕\n\n\n\n# 문자열 슬라이싱2\ns = \"안녕하세요\"\nprint(s[:2])\nprint(s[2:])\nprint(s[::2])\n\n안녕\n하세요\n안하요\n\n\n\n# 문자열은 불변형 객체이므로 인덱스를 이용한 수정은 불가능함\n#s = \"안녕하세요\"\n#s[2:5] = \"하십니까\"\n#print(s)\n\n\n# 문자열을 변경하려면 새로운 문자열을 만들어야 함\ns = \"안녕하세요\"\ns = s[:2] + \"하십니까\"\nprint(s)\n\n안녕하십니까\n\n\n\n# 문자열 거꾸로 출력하기\nmy_str = \"Hello Python!\"\nprint(my_str[::-1])\n\n!nohtyP olleH\n\n\n\n\n\n\n\n\n\nlen() 함수 : 문자열에 들어있는 문자의 개수(문자열의 길이) 반환\n\n\n# 문자열 길이\ns = \"안녕하세요\"\nprint(len(s))\n\n5\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nlower()\n문자열의 알파벳을 모두 소문자로 변환\n\n\nupper()\n문자열의 알파벳을 모두 대문자로 변환\n\n\n\n\n# 대소문자 변환 : 원본은 변하지 않음\ns = \"Hello Python!\"\nprint(s.lower())\nprint(s.upper())\nprint(s)\n\nhello python!\nHELLO PYTHON!\nHello Python!\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nfind()\n- 문자열에서 특정 문자열을 왼쪽에서부터 찾아서 인덱스를 반환 - 찾는 문자열이 없으면 -1을 반환\n\n\nrfind()\n- 문자열에서 특정 문자열을 오른쪽에서부터 찾아서 인덱스를 반환 - 찾는 문자열이 없으면 -1을 반환\n\n\ncount()\n- 문자열에서 특정 문자열의 개수를 반환\n\n\nin 연산자\n- 문자열 내부에 특정 문자열이 있다면 True, 없다면 False를 반환\n\n\n\n\n# 문자열 찾기\ns = \"Hello! Python is Python\"\nprint(s.find(\"Python\"))\nprint(s.rfind(\"Python\"))\nprint(s.count(\"Python\"))\nprint(\"Hello\" in s)\nprint(\"Hi\" in s)\n\n7\n17\n2\nTrue\nFalse\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nstrip()\n문자열 양 옆의 공백이나 특정 문자를 제거\n\n\nrstrip()\n문자열 오른쪽의 공백이나 특정 문자를 제거\n\n\nlstrip()\n문자열 왼쪽의 공백이나 특정 문자를 제거\n\n\nreplace()\n특정 문자열을 다른 문자열로 변경\n\n\n\n\n# 공백 제거\ns = \"  Hello Python!  \"\nprint(s)\nprint(s.strip())\n\n  Hello Python!  \nHello Python!\n\n\n\n# 특정 문자 제거\ns = \"##100kg, ##200kg\"\nprint(s.rstrip(\"kg\"))\nprint(s.lstrip(\"#\"))\n\n##100kg, ##200\n100kg, ##200kg\n\n\n\n# 문자열 변경\ns = \"Hello Python!\"\nprint(s.replace(\"Hello\", \"Hi\"))\n\nHi Python!\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nsplit()\n- 특정문자를 기준으로 문자열을 분리하고 리스트로 반환\n\n\njoin()\n- 여러 문자열을 모아서 하나의 문자열로 만듬 - 문자열을 구분할 구분자를 지정해야 함\n\n\n\n\n# 문자열 분리\ns = \"Hello Python!\"\ns.split(\" \")\n\n['Hello', 'Python!']\n\n\n\n# 문자열 결합\nlst = [\"one\", \"two\", \"three\"]\nprint(\", \".join(lst))\nprint(\" - \".join(lst))\n\none, two, three\none - two - three\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nisdigit()\n문자열이 숫자로만 구성되었는지 확인\n\n\nisalpha()\n문자열이 알파벳으로만 구성되었는지 확인\n\n\nisalnum()\n문자열이 알파벳과 숫자로만 구성되었는지 확인\n\n\nislower()\n문자열이 소문자로만 구성되었는지 확인\n\n\nisupper()\n문자열이 대문자로만 구성되었는지 확인\n\n\nisspace()\n문자열이 공백으로만 구성되었는지 확인\n\n\n\n\n# 문자열 구성 파악\nprint(\"1234\".isdigit())\nprint(\"Python\".isalpha())\nprint(\"pass123\".isalnum())\nprint(\"hello\".islower())\nprint(\"HELLO\".isupper())\nprint(\"     \".isspace())\n\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nstr()\n수를 문자열로 변환\n\n\nint()\n정수 형식의 문자열이나 실수를 정수로 변환\n\n\nfloat()\n실수 형식의 문자열이나 정수를 실수로 변환\n\n\n\n\n# 형 변환1\na = 1234\n#print(a + \"kg\")\nprint(str(a) + \"kg\")\n\n1234kg\n\n\n\n# 형 변환2\nprint(int(\"1234\"))\nprint(float(\"3.14\"))\n\n1234\n3.14\n\n\n\n\n\n\n\n“{자료형}”.format(인수)\n\n\n\n{}를 포함한 문자열 뒤에 .을 찍고 format() 함수를 사용하여 문자열이 출력되는 형식을 지정할 수 있음\n\n앞쪽에 있는 문자열 안의 {} 기호가 format() 함수의 매개변수로 차례로 대치되면서 숫자가 문자열이 됨\n{} 개수와 format() 함수의 매개변수 개수는 반드시 같아야 함\n\nf-문자열이 format() 함수보다 간단하고 직관적이므로, 대부분 f-문자열을 사용함\n\n\n\nf-문자열보다 format() 함수를 사용하는 것이 더 좋은 경우\n\n문자열 내용이 너무 많을 때 - 어떤 데이터를 출력하는지 모아서 볼 수 있어 더 유용함\n데이터를 리스트에 담아서 사용할 때\n\n\n\n# format() 함수1\nprint(\"{}\".format(10))\nprint(\"{} {}\".format(10, 20))\nprint(\"{} {} {} {} {}\".format(10, 20, 30, 40, 50))\n\n10\n10 20\n10 20 30 40 50\n\n\n\n# format() 함수2\nname = \"홍길동\"\nage = 20\nprint(f\"이름은 {name}이고, 나이는 {age}입니다.\")\nprint(\"이름은 {}이고, 나이는 {}입니다.\".format(name, age))\n\n이름은 홍길동이고, 나이는 20입니다.\n이름은 홍길동이고, 나이는 20입니다.\n\n\n\n# format() 함수3\na = 4\nb = 3.14159265\nprint(\"20{:02d}\".format(a))                # a 값을 두자리로 출력하되 앞의 빈곳은 0으로 채움\nprint(\"{:.3f}\".format(b))                  # b 값을 소수점 이하 세자리로 반올림하여 출력\n\n2004\n3.142\n\n\n\n# 데이터를 리스트에 담아서 사용할 때는 format() 함수를 사용하는 것이 더 좋음\ndata = [\"별\", 2, \"M\", \"Yes\"]\n\n# f-문자열 사용\nprint(f\"이름: {data[0]}, 나이: {data[1]}, 성별: {data[2]}, 중성화 여부: {data[3]}\")\n\n# format() 함수 사용\n# 전개 연산자 *를 사용하여 리스트 내용을 전개함\nprint(\"이름: {}, 나이: {}, 성별: {}, 중성화 여부: {}\".format(*data))\n\n이름: 별, 나이: 2, 성별: M, 중성화 여부: Yes\n이름: 별, 나이: 2, 성별: M, 중성화 여부: Yes"
  },
  {
    "objectID": "3_2_list.html",
    "href": "3_2_list.html",
    "title": "3. 자료구조",
    "section": "",
    "text": "리스트(list)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 존재하는 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n정수형, 부동소수점형, 문자열형, bool형, 리스트, 튜플, 딕셔너리 등 다양한 자료형을 저장할 수 있는 컨테이너형 객체\n\n\n\n\n리스트 생성\n\n리터럴 방식(list literal)\n\n[] 사용하여 리스트를 직접 정의하는 방법\n[] 안에 원소(element)를 ,로 구분하여 나열함\n\n생성자 방식(list constructor)\n\nlist() 함수를 사용하여 리스트를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)을 인수로 받아 리스트를 생성할 때 유용함\n\n\n\n\n# 리스트 생성1\nlst = [1, 2, 3, 4, 5]\nprint(lst)\n\n[1, 2, 3, 4, 5]\n\n\n\n# 리스트 생성2\nlst = list([1, 2, 3, 4, 5])\nprint(lst)\n\n[1, 2, 3, 4, 5]\n\n\n\n# 리스트 생성3 : 리스트는 다양한 자료형을 저장할 수 있음\nlst = [1, 3.14, \"Hello\", True, [11, 12, 13]]\nprint(lst)\n\n[1, 3.14, 'Hello', True, [11, 12, 13]]\n\n\n\n# 리스트 생성4 : iterable 객체 사용\nlst = list(\"Hello\")\nprint(lst)\n\n['H', 'e', 'l', 'l', 'o']\n\n\n\n# 리스트 생성5 : iterable 객체 사용\nlst = list(range(10))\nprint(lst)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\n\n\n\n문자열 연산과 동일함\n리스트 연결 연산자 + : 두 리스트를 연결해서 새로운 리스트 생성\n리스트 반복 연산자 * : 리스트를 숫자만큼 반복하여 새로운 리스트 생성 - (예) 리스트*숫자\n리스트 전개 연산자 * : 리스트의 개별 원소를 분리하여 다른 리스트로 전개 - (예) [*리스트]\n\n\n# 리스트 연결\nlst1 = [1, 2, 3]\nlst2 = [11, 12, 13]\nprint(lst1 + lst2)\n\n[1, 2, 3, 11, 12, 13]\n\n\n\n# 리스트 반복\nprint(lst1 * 3)\n\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n\n\n# 리스트 전개\nlst = [1, 2, 3]\nprint([lst, lst])\nprint([*lst, *lst])\n\n[[1, 2, 3], [1, 2, 3]]\n[1, 2, 3, 1, 2, 3]\n\n\n\n\n\n\n\n\n\n패킹(packing) : 여러 개의 데이터를 한 변수에 묶어 할당하는 것\n언패킹(unpacking)\n\n한 변수에 묶인 데이터를 개별적인 변수들에 할당하는 것\n언패킹 시 기본적으로 변수 개수가 맞아야 하지만, *를 사용하면 가변 개수도 처리할 수 있음\n\n\n\n# 리스트 패킹\nlst = [1, 2, 3]\nprint(lst)\n\n[1, 2, 3]\n\n\n\n# 리스트 언패킹\nlst = [1, 2, 3]\nx, y, z = lst\nprint(x)\nprint(y)\nprint(z)\n\n1\n2\n3\n\n\n\n# 언패킹 시 변수 개수 불일치 오류\n#a, b = [1, 2, 3]\n#x, y, z = [4, 5]\n\n\n# 언패킹 시 *을 이용한 가변 개수 처리\n*x, y, z = [5, 6, 7, 8]\nprint(x)\nprint(y)\nprint(z)\n\n[5, 6]\n7\n8\n\n\n\n\n\n\n\n가변 인수를 사용하면 전달된 인수들은 튜플로 패킹됨\n*를 사용하여 리스트를 언패킹하여 함수에 전달함\n\n\n\n[참고] 함수의 인수\n\n\n\n\n\n\n\n\n종류\n내용\n\n\n\n\n키워드 인수\n함수의 인터페이스에서 저장한 변수명을 사용하여 함수의 인수를 지정하는 방법\n\n\n디폴트 인수\n별도의 인수 값이 입력되지 않을 때 인터페이스 선언에서 지정한 초기 값을 사용하는 방법\n\n\n가변 인수\n함수의 인터페이스에서 지정하는 변수 이외의 추가 변수를 함수에 입력할 수 있도록 지원하는 방법\n\n\n키워드 가변 인수\n매개변수의 이름을 따로 지정하지 않고 입력하는 방법\n\n\n\n\n# 키워드 인수(keyword arguments)\ndef greet(name, greeting):\n    print(f\"{greeting}, {name}!\")\n\ngreet(name=\"Alice\", greeting=\"Hi\")\n\nHi, Alice!\n\n\n\n# 디폴트 인수(default arguments)\ndef greet(name, greeting=\"Hello\"):\n    print(f\"{greeting}, {name}!\")\n\ngreet(\"Alice\")\ngreet(\"Bob\", \"Hi\")\n\nHello, Alice!\nHi, Bob!\n\n\n\n# 가변 인수(variable-length arguments) : *로 표현\n# 함수에 전단하는 인수의 개수가 불확실할 때 사용\n# 가변 인수는 반드시 일반적인 키워드 인수에 대한 선언이 모두 끝난 후 마지막에 선언되어야 함\ndef sum_numbers(*args):\n    return sum(args)\n\nprint(sum_numbers(1, 2, 3))\nprint(sum_numbers(5, 10))\n\n6\n15\n\n\n\n# 키워드 가변 인수(keyword variable-length arguments) : **로 표현\n# 입력 받은 값은 딕셔너리 지료형임\n# 키워드 가변 인수는 반드시 모든 매개변수의 마지막에 선언되어야 함\ndef print_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"Alice\", age=25)\n\nname: Alice\nage: 25\n\n\n\n# 가변 인수와 패킹, 언패킹\ndef print_args(*args):\n    print(\"Packed arguments:\", args)                        # 전달된 값이 튜플로 패킹됨\n\nprint_args(1, 2, 3, 4)\n\nlst = [11, 12, 13]\nprint_args(lst)                                             # 리스트 자체를 인수로 전달\nprint_args(*lst)                                            # 리스트를 언패킹하여 함수에 전달\n\nPacked arguments: (1, 2, 3, 4)\nPacked arguments: ([11, 12, 13],)\nPacked arguments: (11, 12, 13)\n\n\n\n# 키워드 인수와 언패킹\ndef sum_numbers(a, b, c, d):\n    return a + b + c + d\n\nlst = [1, 2, 3, 4]\n\nprint(sum_numbers(lst[0], lst[1], lst[2], lst[3]))          # 개별 원소를 인수로 전달\nprint(sum_numbers(*lst))                                    # 리스트를 언패킹하여 함수에 전달\n\n10\n10\n\n\n\n\n\n\n\n함수에서 여러 개의 값을 반환하면 자동으로 튜플로 패킹됨\n반환 값을 리스트로 묶어(패킹) 반환할 수도 있음\n함수가 반환한 리스트를 언패킹하여 개별 변수에 할당할 수 있음\n\n\n# 반환값과 패킹, 언패킹\ndef get_student_info():\n    return [\"Alice\", 20, \"Statistics\"]                      # 리스트로 패킹함\n\n# 패킹된 값 출력\ninfo = get_student_info()\nprint(info)\n\n# 언패킹하여 개별 변수에 할당\nname, age, major = get_student_info()\nprint(name)\nprint(age)\nprint(major)\n\n['Alice', 20, 'Statistics']\nAlice\n20\nStatistics\n\n\n\n\n\n\n\n\n문자열과 문법이 동일함\n인덱싱(indexing) : [index]를 사용하여 리스트의 특정 위치에 있는 원소에 접근함\n슬라이싱(slicing) : [(start index):(stop index)]를 사용하여 리스트의 일부 원소를 추출함\n\nlist[(start index):(end index)] = iterable를 사용하면 start:end로 지정한 부분이 iterable 객체의 모든 원소로 대체됨\n슬라이싱을 이용하여 기존 리스트의 일부를 삭제하거나, 새로운 원소를 추가 및 변경할 수 있음\n\n\n\n\n# 리스트 인덱싱1\nlst = [10, 20, 30, 40, 50]\nprint(lst[0])\n\n10\n\n\n\n# 리스트 인덱싱2\nlst = [10, 20, 30, 40, 50]\nprint(lst[-1])\n\n50\n\n\n\n# 리스트 접근 연산자 []를 이중으로 사용할 수 있음\nlst = [1, 3.14, \"Hello\", True, [11, 12, 13]]\nprint(lst[2])\nprint(lst[2][0])\n\nHello\nH\n\n\n\n# 리스트 슬라이싱1\nlst = [10, 20, 30, 40, 50]\nprint(lst[0:2])\n\n[10, 20]\n\n\n\n# 리스트 슬라이싱2\nlst = [10, 20, 30, 40, 50]\nprint(lst[:2])\nprint(lst[2:])\nprint(lst[::2])\n\n[10, 20]\n[30, 40, 50]\n[10, 30, 50]\n\n\n\n# 리스트는 가변형 객체이므로 인덱스를 이용한 수정이 가능함\nlst = [10, 20, 30, 40, 50]\nlst[2] = 3\nprint(lst)\n\n[10, 20, 3, 40, 50]\n\n\n\n# 슬라이싱을 이용한 원소 삭제\nlst = [10, 20, 30, 40, 50]\nlst[1:4] = []                              # 빈 리스트를 할당하면 해당 부분이 삭제됨\nprint(lst)\n\n[10, 50]\n\n\n\n# 슬라이싱을 이용한 원소 추가\nlst = [10, 20, 30, 40, 50]\nlst[1:1] = [6, 7]                          # 인덱스 1 위치에 [6, 7]의 원소를 개별적으로 추가\nprint(lst)\n\n[10, 6, 7, 20, 30, 40, 50]\n\n\n\n# 슬라이싱을 이용한 원소 수정\nlst = [10, 20, 30, 40, 50]\nlst[1:3] = [6, 7, 8]                       # 인덱스 1~2 부분을 [6, 7, 8]로 수정\nprint(lst)\n\n[10, 6, 7, 8, 40, 50]\n\n\n\n\n\n\n\n리스트 안에 또 다른 리스트가 포함된 구조\n2차원 리스트\n\n모든 내부 리스트가 동일한 길이를 가진 경우\n일반적으로 행(row)과 열(column)로 이루어짐\n행렬(matrix)처럼 활용하거나, 데이터를 일정한 구조로 관리할 때 유용함\n\n\n\n# 중첩 리스트\nnested_lst = [\n    [1, 2, 3],\n    [4, 5, 6, 7],\n    [8, 9]\n]\n\nprint(nested_lst)\n\n[[1, 2, 3], [4, 5, 6, 7], [8, 9]]\n\n\n\nfor items in nested_lst:\n    for item in items:\n        print(item)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2차원 리스트\nkor = [80, 82, 75, 95]\neng = [67, 95, 84, 83]\nmath = [74, 88, 82, 76]\nmidterm = [kor, eng, math]\nprint(midterm)\n\n[[80, 82, 75, 95], [67, 95, 84, 83], [74, 88, 82, 76]]\n\n\n\n# 2차원 리스트 인덱싱\nmidterm[0][3]\n\n95\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nappend()\n- 새로운 값을 기존 리스트의 맨 끝에 추가\n\n\nextend()\n- 새로운 리스트를 기존 리스트에 추가(덧셈 연산과 같은 효과)\n\n\ninsert()\n- 기존 리스트의 i번째 인덱스에 새로운 값을 추가 - i번째 인덱스를 기준으로 뒤쪽의 인덱스는 하나씩 밀림\n\n\n\n\n# 리스트에 한 개의 원소 추가1\nlst = [1, 2, 3]\nlst.append(4)                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 4]\n\n\n\n# 리스트에 한 개의 원소 추가2\n# 원본 값 변화 없이 리스트에 한 개의 원소를 추가하려면 전개 연산자 *를 사용하면 됨\nlst = [1, 2, 3]\nnew_lst = [*lst, 4]\nprint(lst)                                 # lst 원본 값이 변하지 않음\nprint(new_lst)\n\n[1, 2, 3]\n[1, 2, 3, 4]\n\n\n\n# append() 함수는 여러 개의 인수를 입력하거나, 연속으로 사용할 수 없음\nlst = [1, 2, 3]\n#lst.append(4,5)\n#lst.append(4).append(5)\n\n\n# 리스트에 여러 개의 원소 추가\nlst = [1, 2, 3]\nlst.extend([11, 12])                       # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst1 원본 값이 변함\n\n[1, 2, 3, 11, 12]\n\n\n\n# extend() 함수와 리스트 연결 연산자 +의 차이\nlst1 = [1, 2, 3]\nlst2 = [11, 12, 13]\nlst1 + lst2                                # 실행 결과가 출력됨\nprint(lst1)                                # lst1 원본 값이 변하지 않음\nprint(lst2)                                # lst2 원본 값이 변하지 않음\n\n[1, 2, 3]\n[11, 12, 13]\n\n\n\n# 특정 위치에 한 개의 원소 추가\nlst = [1, 2, 3]\nlst.insert(0, 100)                         # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[100, 1, 2, 3]\n\n\n\n# 특정 위치에 여러 개의 원소 추가 : 슬라이싱을 이용\nlst = [1, 2, 3]\nlst[1:1] = [11, 12]                        # 인덱스 1의 위치에 리스트 [11, 12]의 원소를 개별적으로 삽입\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 11, 12, 2, 3]\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\npop()\n- 특정 인덱스 값을 삭제하고 그 값을 반환 - 인덱스를 생략하면 마지막 원소를 삭제\n\n\ndel 키워드\n- 특정 인덱스 값을 삭제 - 리스트 객체 자체를 삭제 가능함\n\n\nremove()\n- 리스트에서 첫 번째로 일치하는 값을 삭제 - 값으로 삭제하므로 인덱스를 사용하지 않음\n\n\nclear()\n- 리스트의 모든 원소를 삭제\n\n\n\n\n# 특정 인덱스 값 삭제1\nlst = [1, 2, 3, 4, 5]\nresult = lst.pop(3)                        # 실행 결과로 삭제한 값을 반환\nprint(lst)                                 # lst 원본 값이 변함\nprint(result)\n\n[1, 2, 3, 5]\n4\n\n\n\n# 특정 인덱스 값 삭제2\nlst = [1, 2, 3, 4, 5]\nresult = lst.pop()                         # 인덱스를 생략하면 마지막 원소를 삭제 후 반환\nprint(lst)                                 # lst 원본 값이 변함\nprint(result)\n\n[1, 2, 3, 4]\n5\n\n\n\n# 특정 인덱스 값 삭제3\nlst = [1, 2, 3, 4, 5]\ndel lst[3]                                 # 실행 결과로 아무것도 반환하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 5]\n\n\n\n# 리스트 객체 삭제\nlst = [1, 2, 3, 4, 5]\ndel lst\n#print(lst)\n\n\n# 일치하는 값 삭제1\nlst = [1, 2, 3, 4, 5]\nlst.remove(4)                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 5]\n\n\n\n# 일치하는 값 삭제2\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nlst.remove(1)                              # 첫 번째로 일치하는 값만 삭제됨\nprint(lst)                                 # lst 원본 값이 변함\n\n[2, 3, 1, 4, 5, 1, 6, 7]\n\n\n\n# 리스트 모든 원소 삭제\nlst = [1, 2, 3, 4, 5]\nlst.clear()                                # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[]\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nreverse()\n- 리스트 원소를 역순으로 재배열\n\n\nsort()\n- 리스트 원소를 오름차순(default)으로 정렬 - 내림차순으로 정렬하려면 reverse=True로 설정\n\n\n\n\n# 리스트 역순 재배열\nlst = [52, 273, 103, 32, 275, 1, 7]\nlst.reverse()                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[7, 1, 275, 32, 103, 273, 52]\n\n\n\n# 리스트 정렬\nlst = [52, 273, 103, 32, 275, 1, 7]\nlst.sort()                                 # 실행 결과로 아무것도 출력하지 않음, 오름차순 정렬\nprint(lst)                                 # lst 원본 값이 변함\n\nlst.sort(reverse=True)                     # 내림차순 정렬\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 7, 32, 52, 103, 273, 275]\n[275, 273, 103, 52, 32, 7, 1]\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ncount()\n리스트 내부에 특정 값이 몇 번 나타나는지 개수를 반환\n\n\nindex()\n리스트 내부에 특정 값의 첫 번째 인덱스를 반환하며, 없으면 오류 발생\n\n\nin 연산자\n리스트 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\n\n\n# 특정 값 개수\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nprint(lst.count(1))\nprint(lst.count(9))\n\n3\n0\n\n\n\n# 특정 값의 첫 번쩨 인덱스\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nprint(lst.index(1))\n#print(lst.index(9))\n\n0\n\n\n\n# 특정 값 찾기\nlst = [1, 2, 3, 4, 5]\nprint(3 in lst)\nprint(6 in lst)\n\nTrue\nFalse\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nlen()\n리스트 원소의 개수(리스트 길이) 반환\n\n\nsum()\n리스트 원소의 합계 반환\n\n\nmax()\n리스트 원소 중 최대값 반환\n\n\nmin()\n리스트 원소 중 최소값 반환\n\n\n\n\nlst = [1, 2, 3, 4, 5]\nprint(len(lst))\nprint(sum(lst))\nprint(max(lst))\nprint(min(lst))\n\n5\n15\n5\n1\n\n\n\n\n\n\n\n\n[식 for 변수 in 반복범위 if 조건식]\n\n\n기존 리스트를 사용하여 간결하게 새로운 리스트를 생성하는 기법\n리스트와 for 문을 한 줄에 사용할 수 있어 코드가 더 직관적으로 작성됨\n필터링, 중첩 반복문, 이차원 리스트 등 다양한 방식으로 활용됨\n\n\n\n리스트 컴프리헨션은 수학에서 집합을 정의할 때 특정 조건을 만족하는 원소들의 집합으로 표현하는 방법과 유사함\n\n수학적 집합 : S = {x | x는 0 이상 10 이하의 정수}\n리스트 컴프리헨션 : [x for x in range(10)]\n\n\n\n## 0~9 정수 저장\n# 일반적인 반복문 + 리스트\nresult1 = []\nfor i in range(10):\n    result1.append(i)\n\nprint(result1)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n## 0~9 정수 저장\n# 리스트 컴프리헨션\nresult2 = [i for i in range(10)]\nprint(result2)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n## 짝수만 저장 (필터링, if 문과 함께 사용)\n# 일반적인 반복문 + 리스트\nresult1 = []\nfor i in range(10):\n    if i % 2 == 0:\n        result1.append(i)\n\nprint(result1)\n\n[0, 2, 4, 6, 8]\n\n\n\n## 짝수만 저장 (필터링, if 문과 함께 사용)\n# 리스트 컴프리헨션\nresult2 = [i for i in range(10) if i % 2 == 0]\nprint(result2)\n\n[0, 2, 4, 6, 8]\n\n\n\n## 두 개의 문자열 조합하여 새로운 리스트 생성 (중첩 반복문)\n# 일반적인 반복문 + 리스트\nword1 = \"Hello\"\nword2 = \"World\"\nresult1 = []\n\nfor i in word1:\n    for j in word2:\n        result1.append(i+j)\n\nprint(result1)\n\n['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']\n\n\n\n## 두 개의 문자열 조합하여 새로운 리스트 생성 (중첩 반복문)\n# 리스트 컴프리헨션\nword1 = \"Hello\"\nword2 = \"World\"\n\nresult2 = [i+j for i in word1 for j in word2]\nprint(result2)\n\n['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']\n\n\n\n# 리스트 컴프리헨션 (필터링 + 중첩 반복문)\ncase1 = [\"A\", \"B\", \"C\"]\ncase2 = [\"D\", \"E\", \"A\"]\nresult = [i + j for i in case1 for j in case2 if not(i==j)]\nprint(result)\n\n['AD', 'AE', 'BD', 'BE', 'BA', 'CD', 'CE', 'CA']\n\n\n\n## 리스트의 각 원소를 대문자, 소문자, 길이로 변환하여 이차원 리스트 생성 (이차원 리스트)\n# 일반적인 반복문 + 리스트\nwords = \"The quick brown fox jumps over the lazy dog\".split()\nword_info1 = []\n\nfor w in words:\n    word_info1.append([w.upper(), w.lower(), len(w)])\n\nword_info1\n\n[['THE', 'the', 3],\n ['QUICK', 'quick', 5],\n ['BROWN', 'brown', 5],\n ['FOX', 'fox', 3],\n ['JUMPS', 'jumps', 5],\n ['OVER', 'over', 4],\n ['THE', 'the', 3],\n ['LAZY', 'lazy', 4],\n ['DOG', 'dog', 3]]\n\n\n\n## 리스트의 각 원소를 대문자, 소문자, 길이로 변환하여 이차원 리스트 생성 (이차원 리스트)\n# 리스트 컴프리헨션\nwords = \"The quick brown fox jumps over the lazy dog\".split()\nword_info2 = [[w.upper(), w.lower(), len(w)] for w in words]\nword_info2\n\n[['THE', 'the', 3],\n ['QUICK', 'quick', 5],\n ['BROWN', 'brown', 5],\n ['FOX', 'fox', 3],\n ['JUMPS', 'jumps', 5],\n ['OVER', 'over', 4],\n ['THE', 'the', 3],\n ['LAZY', 'lazy', 4],\n ['DOG', 'dog', 3]]\n\n\n\n# [주의] 중 반복문에서 대괄호의 위치에 따라 리스트의 구조가 달라짐\ncase1 = [\"A\", \"B\", \"C\"]\ncase2 = [\"1\", \"2\", \"3\"]\n\n# 일차원 리스트, 앞의 for 문이 먼저 실행됨\nresult1 = [i + j for i in case1 for j in case2]\nprint(result1)\n\n# 이차원 리스트, 뒤의 for 문이 바깥쪽에서 먼저 실행됨\nresult2 = [[i + j for i in case1] for j in case2]\nprint(result2)\n\n['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']\n[['A1', 'B1', 'C1'], ['A2', 'B2', 'C2'], ['A3', 'B3', 'C3']]\n\n\n\n(과제) 리스트 컴프리헨션 실습\n\n문제 1. 1부터 10까지의 제곱수를 리스트로 만들기 - [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n문제 2. 문자열 words = [“apple”, “banana”, “cherry”, “durian”] 에서 첫 글자만 리스트로 만들기 - [‘a’, ‘b’, ‘c’, ‘d’]\n문제 3. 두 리스트 list1 = [1,2,3], list2 = [4,5,6] 의 각 요소를 곱하여 리스트로 만들기 - [4, 10, 18]\n문제 4. 1~20까지의 수 중에서 3의 배수만 리스트로 만들기 - [3, 6, 9, 12, 15, 18]\n문제 5. 문자열 words = [“alligator”, “bear”, “cat”, “dog”, “elephant”, “fox”] 에서 길이가 5 이상인 단어만 리스트로 만들기 - [“alligator”, “elephant”]"
  },
  {
    "objectID": "3_2_list.html#리스트",
    "href": "3_2_list.html#리스트",
    "title": "3. 자료구조",
    "section": "",
    "text": "리스트(list)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 존재하는 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n정수형, 부동소수점형, 문자열형, bool형, 리스트, 튜플, 딕셔너리 등 다양한 자료형을 저장할 수 있는 컨테이너형 객체\n\n\n\n\n리스트 생성\n\n리터럴 방식(list literal)\n\n[] 사용하여 리스트를 직접 정의하는 방법\n[] 안에 원소(element)를 ,로 구분하여 나열함\n\n생성자 방식(list constructor)\n\nlist() 함수를 사용하여 리스트를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)을 인수로 받아 리스트를 생성할 때 유용함\n\n\n\n\n# 리스트 생성1\nlst = [1, 2, 3, 4, 5]\nprint(lst)\n\n[1, 2, 3, 4, 5]\n\n\n\n# 리스트 생성2\nlst = list([1, 2, 3, 4, 5])\nprint(lst)\n\n[1, 2, 3, 4, 5]\n\n\n\n# 리스트 생성3 : 리스트는 다양한 자료형을 저장할 수 있음\nlst = [1, 3.14, \"Hello\", True, [11, 12, 13]]\nprint(lst)\n\n[1, 3.14, 'Hello', True, [11, 12, 13]]\n\n\n\n# 리스트 생성4 : iterable 객체 사용\nlst = list(\"Hello\")\nprint(lst)\n\n['H', 'e', 'l', 'l', 'o']\n\n\n\n# 리스트 생성5 : iterable 객체 사용\nlst = list(range(10))\nprint(lst)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\n\n\n\n문자열 연산과 동일함\n리스트 연결 연산자 + : 두 리스트를 연결해서 새로운 리스트 생성\n리스트 반복 연산자 * : 리스트를 숫자만큼 반복하여 새로운 리스트 생성 - (예) 리스트*숫자\n리스트 전개 연산자 * : 리스트의 개별 원소를 분리하여 다른 리스트로 전개 - (예) [*리스트]\n\n\n# 리스트 연결\nlst1 = [1, 2, 3]\nlst2 = [11, 12, 13]\nprint(lst1 + lst2)\n\n[1, 2, 3, 11, 12, 13]\n\n\n\n# 리스트 반복\nprint(lst1 * 3)\n\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n\n\n# 리스트 전개\nlst = [1, 2, 3]\nprint([lst, lst])\nprint([*lst, *lst])\n\n[[1, 2, 3], [1, 2, 3]]\n[1, 2, 3, 1, 2, 3]\n\n\n\n\n\n\n\n\n\n패킹(packing) : 여러 개의 데이터를 한 변수에 묶어 할당하는 것\n언패킹(unpacking)\n\n한 변수에 묶인 데이터를 개별적인 변수들에 할당하는 것\n언패킹 시 기본적으로 변수 개수가 맞아야 하지만, *를 사용하면 가변 개수도 처리할 수 있음\n\n\n\n# 리스트 패킹\nlst = [1, 2, 3]\nprint(lst)\n\n[1, 2, 3]\n\n\n\n# 리스트 언패킹\nlst = [1, 2, 3]\nx, y, z = lst\nprint(x)\nprint(y)\nprint(z)\n\n1\n2\n3\n\n\n\n# 언패킹 시 변수 개수 불일치 오류\n#a, b = [1, 2, 3]\n#x, y, z = [4, 5]\n\n\n# 언패킹 시 *을 이용한 가변 개수 처리\n*x, y, z = [5, 6, 7, 8]\nprint(x)\nprint(y)\nprint(z)\n\n[5, 6]\n7\n8\n\n\n\n\n\n\n\n가변 인수를 사용하면 전달된 인수들은 튜플로 패킹됨\n*를 사용하여 리스트를 언패킹하여 함수에 전달함\n\n\n\n[참고] 함수의 인수\n\n\n\n\n\n\n\n\n종류\n내용\n\n\n\n\n키워드 인수\n함수의 인터페이스에서 저장한 변수명을 사용하여 함수의 인수를 지정하는 방법\n\n\n디폴트 인수\n별도의 인수 값이 입력되지 않을 때 인터페이스 선언에서 지정한 초기 값을 사용하는 방법\n\n\n가변 인수\n함수의 인터페이스에서 지정하는 변수 이외의 추가 변수를 함수에 입력할 수 있도록 지원하는 방법\n\n\n키워드 가변 인수\n매개변수의 이름을 따로 지정하지 않고 입력하는 방법\n\n\n\n\n# 키워드 인수(keyword arguments)\ndef greet(name, greeting):\n    print(f\"{greeting}, {name}!\")\n\ngreet(name=\"Alice\", greeting=\"Hi\")\n\nHi, Alice!\n\n\n\n# 디폴트 인수(default arguments)\ndef greet(name, greeting=\"Hello\"):\n    print(f\"{greeting}, {name}!\")\n\ngreet(\"Alice\")\ngreet(\"Bob\", \"Hi\")\n\nHello, Alice!\nHi, Bob!\n\n\n\n# 가변 인수(variable-length arguments) : *로 표현\n# 함수에 전단하는 인수의 개수가 불확실할 때 사용\n# 가변 인수는 반드시 일반적인 키워드 인수에 대한 선언이 모두 끝난 후 마지막에 선언되어야 함\ndef sum_numbers(*args):\n    return sum(args)\n\nprint(sum_numbers(1, 2, 3))\nprint(sum_numbers(5, 10))\n\n6\n15\n\n\n\n# 키워드 가변 인수(keyword variable-length arguments) : **로 표현\n# 입력 받은 값은 딕셔너리 지료형임\n# 키워드 가변 인수는 반드시 모든 매개변수의 마지막에 선언되어야 함\ndef print_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"Alice\", age=25)\n\nname: Alice\nage: 25\n\n\n\n# 가변 인수와 패킹, 언패킹\ndef print_args(*args):\n    print(\"Packed arguments:\", args)                        # 전달된 값이 튜플로 패킹됨\n\nprint_args(1, 2, 3, 4)\n\nlst = [11, 12, 13]\nprint_args(lst)                                             # 리스트 자체를 인수로 전달\nprint_args(*lst)                                            # 리스트를 언패킹하여 함수에 전달\n\nPacked arguments: (1, 2, 3, 4)\nPacked arguments: ([11, 12, 13],)\nPacked arguments: (11, 12, 13)\n\n\n\n# 키워드 인수와 언패킹\ndef sum_numbers(a, b, c, d):\n    return a + b + c + d\n\nlst = [1, 2, 3, 4]\n\nprint(sum_numbers(lst[0], lst[1], lst[2], lst[3]))          # 개별 원소를 인수로 전달\nprint(sum_numbers(*lst))                                    # 리스트를 언패킹하여 함수에 전달\n\n10\n10\n\n\n\n\n\n\n\n함수에서 여러 개의 값을 반환하면 자동으로 튜플로 패킹됨\n반환 값을 리스트로 묶어(패킹) 반환할 수도 있음\n함수가 반환한 리스트를 언패킹하여 개별 변수에 할당할 수 있음\n\n\n# 반환값과 패킹, 언패킹\ndef get_student_info():\n    return [\"Alice\", 20, \"Statistics\"]                      # 리스트로 패킹함\n\n# 패킹된 값 출력\ninfo = get_student_info()\nprint(info)\n\n# 언패킹하여 개별 변수에 할당\nname, age, major = get_student_info()\nprint(name)\nprint(age)\nprint(major)\n\n['Alice', 20, 'Statistics']\nAlice\n20\nStatistics\n\n\n\n\n\n\n\n\n문자열과 문법이 동일함\n인덱싱(indexing) : [index]를 사용하여 리스트의 특정 위치에 있는 원소에 접근함\n슬라이싱(slicing) : [(start index):(stop index)]를 사용하여 리스트의 일부 원소를 추출함\n\nlist[(start index):(end index)] = iterable를 사용하면 start:end로 지정한 부분이 iterable 객체의 모든 원소로 대체됨\n슬라이싱을 이용하여 기존 리스트의 일부를 삭제하거나, 새로운 원소를 추가 및 변경할 수 있음\n\n\n\n\n# 리스트 인덱싱1\nlst = [10, 20, 30, 40, 50]\nprint(lst[0])\n\n10\n\n\n\n# 리스트 인덱싱2\nlst = [10, 20, 30, 40, 50]\nprint(lst[-1])\n\n50\n\n\n\n# 리스트 접근 연산자 []를 이중으로 사용할 수 있음\nlst = [1, 3.14, \"Hello\", True, [11, 12, 13]]\nprint(lst[2])\nprint(lst[2][0])\n\nHello\nH\n\n\n\n# 리스트 슬라이싱1\nlst = [10, 20, 30, 40, 50]\nprint(lst[0:2])\n\n[10, 20]\n\n\n\n# 리스트 슬라이싱2\nlst = [10, 20, 30, 40, 50]\nprint(lst[:2])\nprint(lst[2:])\nprint(lst[::2])\n\n[10, 20]\n[30, 40, 50]\n[10, 30, 50]\n\n\n\n# 리스트는 가변형 객체이므로 인덱스를 이용한 수정이 가능함\nlst = [10, 20, 30, 40, 50]\nlst[2] = 3\nprint(lst)\n\n[10, 20, 3, 40, 50]\n\n\n\n# 슬라이싱을 이용한 원소 삭제\nlst = [10, 20, 30, 40, 50]\nlst[1:4] = []                              # 빈 리스트를 할당하면 해당 부분이 삭제됨\nprint(lst)\n\n[10, 50]\n\n\n\n# 슬라이싱을 이용한 원소 추가\nlst = [10, 20, 30, 40, 50]\nlst[1:1] = [6, 7]                          # 인덱스 1 위치에 [6, 7]의 원소를 개별적으로 추가\nprint(lst)\n\n[10, 6, 7, 20, 30, 40, 50]\n\n\n\n# 슬라이싱을 이용한 원소 수정\nlst = [10, 20, 30, 40, 50]\nlst[1:3] = [6, 7, 8]                       # 인덱스 1~2 부분을 [6, 7, 8]로 수정\nprint(lst)\n\n[10, 6, 7, 8, 40, 50]\n\n\n\n\n\n\n\n리스트 안에 또 다른 리스트가 포함된 구조\n2차원 리스트\n\n모든 내부 리스트가 동일한 길이를 가진 경우\n일반적으로 행(row)과 열(column)로 이루어짐\n행렬(matrix)처럼 활용하거나, 데이터를 일정한 구조로 관리할 때 유용함\n\n\n\n# 중첩 리스트\nnested_lst = [\n    [1, 2, 3],\n    [4, 5, 6, 7],\n    [8, 9]\n]\n\nprint(nested_lst)\n\n[[1, 2, 3], [4, 5, 6, 7], [8, 9]]\n\n\n\nfor items in nested_lst:\n    for item in items:\n        print(item)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2차원 리스트\nkor = [80, 82, 75, 95]\neng = [67, 95, 84, 83]\nmath = [74, 88, 82, 76]\nmidterm = [kor, eng, math]\nprint(midterm)\n\n[[80, 82, 75, 95], [67, 95, 84, 83], [74, 88, 82, 76]]\n\n\n\n# 2차원 리스트 인덱싱\nmidterm[0][3]\n\n95\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nappend()\n- 새로운 값을 기존 리스트의 맨 끝에 추가\n\n\nextend()\n- 새로운 리스트를 기존 리스트에 추가(덧셈 연산과 같은 효과)\n\n\ninsert()\n- 기존 리스트의 i번째 인덱스에 새로운 값을 추가 - i번째 인덱스를 기준으로 뒤쪽의 인덱스는 하나씩 밀림\n\n\n\n\n# 리스트에 한 개의 원소 추가1\nlst = [1, 2, 3]\nlst.append(4)                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 4]\n\n\n\n# 리스트에 한 개의 원소 추가2\n# 원본 값 변화 없이 리스트에 한 개의 원소를 추가하려면 전개 연산자 *를 사용하면 됨\nlst = [1, 2, 3]\nnew_lst = [*lst, 4]\nprint(lst)                                 # lst 원본 값이 변하지 않음\nprint(new_lst)\n\n[1, 2, 3]\n[1, 2, 3, 4]\n\n\n\n# append() 함수는 여러 개의 인수를 입력하거나, 연속으로 사용할 수 없음\nlst = [1, 2, 3]\n#lst.append(4,5)\n#lst.append(4).append(5)\n\n\n# 리스트에 여러 개의 원소 추가\nlst = [1, 2, 3]\nlst.extend([11, 12])                       # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst1 원본 값이 변함\n\n[1, 2, 3, 11, 12]\n\n\n\n# extend() 함수와 리스트 연결 연산자 +의 차이\nlst1 = [1, 2, 3]\nlst2 = [11, 12, 13]\nlst1 + lst2                                # 실행 결과가 출력됨\nprint(lst1)                                # lst1 원본 값이 변하지 않음\nprint(lst2)                                # lst2 원본 값이 변하지 않음\n\n[1, 2, 3]\n[11, 12, 13]\n\n\n\n# 특정 위치에 한 개의 원소 추가\nlst = [1, 2, 3]\nlst.insert(0, 100)                         # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[100, 1, 2, 3]\n\n\n\n# 특정 위치에 여러 개의 원소 추가 : 슬라이싱을 이용\nlst = [1, 2, 3]\nlst[1:1] = [11, 12]                        # 인덱스 1의 위치에 리스트 [11, 12]의 원소를 개별적으로 삽입\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 11, 12, 2, 3]\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\npop()\n- 특정 인덱스 값을 삭제하고 그 값을 반환 - 인덱스를 생략하면 마지막 원소를 삭제\n\n\ndel 키워드\n- 특정 인덱스 값을 삭제 - 리스트 객체 자체를 삭제 가능함\n\n\nremove()\n- 리스트에서 첫 번째로 일치하는 값을 삭제 - 값으로 삭제하므로 인덱스를 사용하지 않음\n\n\nclear()\n- 리스트의 모든 원소를 삭제\n\n\n\n\n# 특정 인덱스 값 삭제1\nlst = [1, 2, 3, 4, 5]\nresult = lst.pop(3)                        # 실행 결과로 삭제한 값을 반환\nprint(lst)                                 # lst 원본 값이 변함\nprint(result)\n\n[1, 2, 3, 5]\n4\n\n\n\n# 특정 인덱스 값 삭제2\nlst = [1, 2, 3, 4, 5]\nresult = lst.pop()                         # 인덱스를 생략하면 마지막 원소를 삭제 후 반환\nprint(lst)                                 # lst 원본 값이 변함\nprint(result)\n\n[1, 2, 3, 4]\n5\n\n\n\n# 특정 인덱스 값 삭제3\nlst = [1, 2, 3, 4, 5]\ndel lst[3]                                 # 실행 결과로 아무것도 반환하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 5]\n\n\n\n# 리스트 객체 삭제\nlst = [1, 2, 3, 4, 5]\ndel lst\n#print(lst)\n\n\n# 일치하는 값 삭제1\nlst = [1, 2, 3, 4, 5]\nlst.remove(4)                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 5]\n\n\n\n# 일치하는 값 삭제2\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nlst.remove(1)                              # 첫 번째로 일치하는 값만 삭제됨\nprint(lst)                                 # lst 원본 값이 변함\n\n[2, 3, 1, 4, 5, 1, 6, 7]\n\n\n\n# 리스트 모든 원소 삭제\nlst = [1, 2, 3, 4, 5]\nlst.clear()                                # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[]\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nreverse()\n- 리스트 원소를 역순으로 재배열\n\n\nsort()\n- 리스트 원소를 오름차순(default)으로 정렬 - 내림차순으로 정렬하려면 reverse=True로 설정\n\n\n\n\n# 리스트 역순 재배열\nlst = [52, 273, 103, 32, 275, 1, 7]\nlst.reverse()                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[7, 1, 275, 32, 103, 273, 52]\n\n\n\n# 리스트 정렬\nlst = [52, 273, 103, 32, 275, 1, 7]\nlst.sort()                                 # 실행 결과로 아무것도 출력하지 않음, 오름차순 정렬\nprint(lst)                                 # lst 원본 값이 변함\n\nlst.sort(reverse=True)                     # 내림차순 정렬\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 7, 32, 52, 103, 273, 275]\n[275, 273, 103, 52, 32, 7, 1]\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ncount()\n리스트 내부에 특정 값이 몇 번 나타나는지 개수를 반환\n\n\nindex()\n리스트 내부에 특정 값의 첫 번째 인덱스를 반환하며, 없으면 오류 발생\n\n\nin 연산자\n리스트 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\n\n\n# 특정 값 개수\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nprint(lst.count(1))\nprint(lst.count(9))\n\n3\n0\n\n\n\n# 특정 값의 첫 번쩨 인덱스\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nprint(lst.index(1))\n#print(lst.index(9))\n\n0\n\n\n\n# 특정 값 찾기\nlst = [1, 2, 3, 4, 5]\nprint(3 in lst)\nprint(6 in lst)\n\nTrue\nFalse\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nlen()\n리스트 원소의 개수(리스트 길이) 반환\n\n\nsum()\n리스트 원소의 합계 반환\n\n\nmax()\n리스트 원소 중 최대값 반환\n\n\nmin()\n리스트 원소 중 최소값 반환\n\n\n\n\nlst = [1, 2, 3, 4, 5]\nprint(len(lst))\nprint(sum(lst))\nprint(max(lst))\nprint(min(lst))\n\n5\n15\n5\n1\n\n\n\n\n\n\n\n\n[식 for 변수 in 반복범위 if 조건식]\n\n\n기존 리스트를 사용하여 간결하게 새로운 리스트를 생성하는 기법\n리스트와 for 문을 한 줄에 사용할 수 있어 코드가 더 직관적으로 작성됨\n필터링, 중첩 반복문, 이차원 리스트 등 다양한 방식으로 활용됨\n\n\n\n리스트 컴프리헨션은 수학에서 집합을 정의할 때 특정 조건을 만족하는 원소들의 집합으로 표현하는 방법과 유사함\n\n수학적 집합 : S = {x | x는 0 이상 10 이하의 정수}\n리스트 컴프리헨션 : [x for x in range(10)]\n\n\n\n## 0~9 정수 저장\n# 일반적인 반복문 + 리스트\nresult1 = []\nfor i in range(10):\n    result1.append(i)\n\nprint(result1)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n## 0~9 정수 저장\n# 리스트 컴프리헨션\nresult2 = [i for i in range(10)]\nprint(result2)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n## 짝수만 저장 (필터링, if 문과 함께 사용)\n# 일반적인 반복문 + 리스트\nresult1 = []\nfor i in range(10):\n    if i % 2 == 0:\n        result1.append(i)\n\nprint(result1)\n\n[0, 2, 4, 6, 8]\n\n\n\n## 짝수만 저장 (필터링, if 문과 함께 사용)\n# 리스트 컴프리헨션\nresult2 = [i for i in range(10) if i % 2 == 0]\nprint(result2)\n\n[0, 2, 4, 6, 8]\n\n\n\n## 두 개의 문자열 조합하여 새로운 리스트 생성 (중첩 반복문)\n# 일반적인 반복문 + 리스트\nword1 = \"Hello\"\nword2 = \"World\"\nresult1 = []\n\nfor i in word1:\n    for j in word2:\n        result1.append(i+j)\n\nprint(result1)\n\n['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']\n\n\n\n## 두 개의 문자열 조합하여 새로운 리스트 생성 (중첩 반복문)\n# 리스트 컴프리헨션\nword1 = \"Hello\"\nword2 = \"World\"\n\nresult2 = [i+j for i in word1 for j in word2]\nprint(result2)\n\n['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']\n\n\n\n# 리스트 컴프리헨션 (필터링 + 중첩 반복문)\ncase1 = [\"A\", \"B\", \"C\"]\ncase2 = [\"D\", \"E\", \"A\"]\nresult = [i + j for i in case1 for j in case2 if not(i==j)]\nprint(result)\n\n['AD', 'AE', 'BD', 'BE', 'BA', 'CD', 'CE', 'CA']\n\n\n\n## 리스트의 각 원소를 대문자, 소문자, 길이로 변환하여 이차원 리스트 생성 (이차원 리스트)\n# 일반적인 반복문 + 리스트\nwords = \"The quick brown fox jumps over the lazy dog\".split()\nword_info1 = []\n\nfor w in words:\n    word_info1.append([w.upper(), w.lower(), len(w)])\n\nword_info1\n\n[['THE', 'the', 3],\n ['QUICK', 'quick', 5],\n ['BROWN', 'brown', 5],\n ['FOX', 'fox', 3],\n ['JUMPS', 'jumps', 5],\n ['OVER', 'over', 4],\n ['THE', 'the', 3],\n ['LAZY', 'lazy', 4],\n ['DOG', 'dog', 3]]\n\n\n\n## 리스트의 각 원소를 대문자, 소문자, 길이로 변환하여 이차원 리스트 생성 (이차원 리스트)\n# 리스트 컴프리헨션\nwords = \"The quick brown fox jumps over the lazy dog\".split()\nword_info2 = [[w.upper(), w.lower(), len(w)] for w in words]\nword_info2\n\n[['THE', 'the', 3],\n ['QUICK', 'quick', 5],\n ['BROWN', 'brown', 5],\n ['FOX', 'fox', 3],\n ['JUMPS', 'jumps', 5],\n ['OVER', 'over', 4],\n ['THE', 'the', 3],\n ['LAZY', 'lazy', 4],\n ['DOG', 'dog', 3]]\n\n\n\n# [주의] 중 반복문에서 대괄호의 위치에 따라 리스트의 구조가 달라짐\ncase1 = [\"A\", \"B\", \"C\"]\ncase2 = [\"1\", \"2\", \"3\"]\n\n# 일차원 리스트, 앞의 for 문이 먼저 실행됨\nresult1 = [i + j for i in case1 for j in case2]\nprint(result1)\n\n# 이차원 리스트, 뒤의 for 문이 바깥쪽에서 먼저 실행됨\nresult2 = [[i + j for i in case1] for j in case2]\nprint(result2)\n\n['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']\n[['A1', 'B1', 'C1'], ['A2', 'B2', 'C2'], ['A3', 'B3', 'C3']]\n\n\n\n(과제) 리스트 컴프리헨션 실습\n\n문제 1. 1부터 10까지의 제곱수를 리스트로 만들기 - [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n문제 2. 문자열 words = [“apple”, “banana”, “cherry”, “durian”] 에서 첫 글자만 리스트로 만들기 - [‘a’, ‘b’, ‘c’, ‘d’]\n문제 3. 두 리스트 list1 = [1,2,3], list2 = [4,5,6] 의 각 요소를 곱하여 리스트로 만들기 - [4, 10, 18]\n문제 4. 1~20까지의 수 중에서 3의 배수만 리스트로 만들기 - [3, 6, 9, 12, 15, 18]\n문제 5. 문자열 words = [“alligator”, “bear”, “cat”, “dog”, “elephant”, “fox”] 에서 길이가 5 이상인 단어만 리스트로 만들기 - [“alligator”, “elephant”]"
  },
  {
    "objectID": "3_4_set.html",
    "href": "3_4_set.html",
    "title": "3. 자료구조",
    "section": "",
    "text": "세트(set)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 없는 집합 자료형(set data type)\n중복을 허용하지 않으며, 순서가 유지되지 않음\n\n리스트, 튜플과 달리 인덱싱과 슬라이싱이 불가능함\n\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n정수형, 부동소수점형, 문자열형, bool형, 튜플 등 해시 가능한(immutable) 자료형을 저장할 수 있는 컨테이너형 객체\n\n\n\n\n[참고] 해시(hash)\n\n데이터를 저장하거나 검색할 때 사용되는 고유한 숫자 값(해시 값)을 사용하는 과정\n세트와 딕셔너리는 내부적으로 해시 값을 사용하여 원소 또는 key에 빠르게 접근함(검색 속도가 빠름)\n해시 값은 변경되지 않아야 하므로, 불변형 객체만 사용할 수 있음\n\n\n\n\n세트 생성\n\n리터럴 방식(set literal)\n\n{}를 사용하여 세트를 직접 정의하는 방법\n{} 안에 원소(element)를 ,로 구분하여 나열함\n중복된 원소는 자동으로 제거됨\n\n생성자 방식(set constructor)\n\nset() 함수를 사용하여 세트를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 세트를 생성할 때 유용함\n빈 세트를 만들려면 반드시 set() 함수를 사용해야 함\n\n\n\n\n# 세트 생성1\nst = {1, 2, 3, 1, 1, 4}\nprint(st)\n\n{1, 2, 3, 4}\n\n\n\n# 세트 생성2\nst = set({1, 2, 3, 1, 1, 4})\nprint(st)\n\n{1, 2, 3, 4}\n\n\n\n# 세트 생성3 : 세트는 해시 가능한(immutable) 자료형을 저장할 수 있음\nst = {1, 3.14, \"Hello\", True, (1, 2, 3), \"Hello\", 1, 1, 1}\nprint(st)\n\n{1, 3.14, 'Hello', (1, 2, 3)}\n\n\n\n# 세트 생성4: iterable 객체 사용\nst = set(\"Hello\")\nprint(st)\n\n{'o', 'l', 'H', 'e'}\n\n\n\n# 세트 생성5 : iterable 객체 사용\nst1 = set([1, 2, 3, 1, 1, 4])\nst2 = set((1, 2, 3, 1, 1, 4))\nprint(st1)\nprint(st2)\n\n{1, 2, 3, 4}\n{1, 2, 3, 4}\n\n\n\n\n\n\n\n\n\n세트 전개 연산자 * : 세트의 개별 원소를 분리하여 다른 세트로 전개 - (예) {*세트}\n\n\n# 세트 전개\nst = {1, 2, 3, 1, 1, 4}\nprint({*st, *st})\nprint([11, 12, *st, 20])\n\n{1, 2, 3, 4}\n[11, 12, 1, 2, 3, 4, 20]\n\n\n\n\n\n\n\n\n\n연산\n연산자\n함수\n\n\n\n\n합집합\n|\nunion()\n\n\n교집합\n&\nintersection()\n\n\n차집합\n-\ndifference()\n\n\n대칭차집합\n^\nsymmetric_difference()\n\n\n부분집합 여부\n&lt;=\nissubset()\n\n\n\n\n\n\n# 세트 연산1\nA = {1, 2, 3}\nB = {3, 4, 5}\n\nprint(A | B)                                                # 합집합\nprint(A & B)                                                # 교집합\nprint(A - B)                                                # 차집합\nprint(A ^ B)                                                # 대칭차집합\nprint(A &lt;= B)                                               # 부분집합 여부\n\n{1, 2, 3, 4, 5}\n{3}\n{1, 2}\n{1, 2, 4, 5}\nFalse\n\n\n\n# 세트 연산2\nA = {1, 2, 3}\nB = {3, 4, 5}\n\nprint(A.union(B))\nprint(A.intersection(B))\nprint(A.difference(B))\nprint(A.symmetric_difference(B))\nprint(A.issubset(B))\n\n{1, 2, 3, 4, 5}\n{3}\n{1, 2}\n{1, 2, 4, 5}\nFalse\n\n\n\n# 세트 연산3 : 여러 개의 세트를 연쇄적으로 한 번에 연산 가능\nA = {1, 2, 3}\nB = {3, 4, 5}\nC = {5, 6, 7}\n\n# 연산자 사용\nprint(A | B | C)\nprint(A & B & C)\n\n# 메소드 사용\nprint(A.union(B, C))\nprint(A.intersection(B, C))\n\n{1, 2, 3, 4, 5, 6, 7}\nset()\n{1, 2, 3, 4, 5, 6, 7}\nset()\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nadd()\n- 새로운 값을 세트에 추가\n\n\nupdate()\n- 여러 개 값을 세트에 추가\n\n\npop()\n- 임의의 값을 삭제하고 그 값을 반환 - 어떤 값을 삭제할지 예측 불가능\n\n\nremove()\n- 세트에서 일치하는 값을 삭제 - 일치하는 값이 없으면 오류가 발생함\n\n\ndiscard()\n- 세트에서 일치하는 값을 삭제 - 일치하는 값이 없어도 오류가 발생하지 않음\n\n\nclear()\n- 세트의 모든 원소를 삭제\n\n\nin 연산자\n세트 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\n\n\n# 세트에 한 개의 원소 추가\nst = {1, 2, 3}\nst.add(6)                                  # 실행 결과로 아무것도 출력하지 않음\nprint(st)                                  # st 원본 값이 변함\n\n{1, 2, 3, 6}\n\n\n\n# 세트에 여러 개의 원소 추가\nst = {1, 2, 3}\nst.update([1, 2, 6])                       # 리스트 사용\nprint(st)\n\nst.update((1, 7))                          # 튜플 사용\nprint(st)\n\nst.update({8, 9})                          # 세트 사용\nprint(st)\n\n{1, 2, 3, 6}\n{1, 2, 3, 6, 7}\n{1, 2, 3, 6, 7, 8, 9}\n\n\n\n# 임의의 원소 삭제\nst = {1, 2, 3}\nresult = st.pop()                          # 임의의 원소를 삭제 후 반환\nprint(st)                                  # st 원본 값이 변함\nprint(result)\n\n{2, 3}\n1\n\n\n\n# 일치하는 값 삭제1\nst = {1, 2, 3}\nst.remove(3)\nprint(st)\n\n{1, 2}\n\n\n\n# 일치하는 값 삭제2 : remove() 함수는 일치하는 값이 없으면 오류가 발생함\n#st = {1, 2, 3}\n#st.remove(4)\n#print(st)\n\n\n# 일치하는 값 삭제3\nst = {1, 2, 3}\nst.discard(3)\nprint(st)\n\n{1, 2}\n\n\n\n# 일치하는 값 삭제4 : discard() 함수는 일치하는 값이 없어도 오류가 발생하지 않음\nst = {1, 2, 3}\nst.discard(4)\nprint(st)\n\n{1, 2, 3}\n\n\n\n# 세트 모든 원소 삭제\nst = {1, 2, 3}\nst.clear()\nprint(st)\n\nset()\n\n\n\n# 특정값 찾기\nst = {1, 2, 3}\nprint(3 in st)\nprint(6 in st)\n\nTrue\nFalse\n\n\n\n\n\n\n\n\n{식 for 변수 in 반복범위 if 조건식}\n\n\n리스트 컴프리헨션과 문법이 동일함\n자동으로 중복이 제거되므로 빠르고 편리함\n\n\n# 이메일 리스트에서 '@'가 포함된 유효한 이메일 주소만 추출\nemails = [\"user1@gmail.com\", \"user2\", \"test@yahoo.com\", \"invalid_email\", \"hello@naver.com\"]\nvalid_emails = {e for e in emails if \"@\" in emails}\nprint(valid_emails)\n\nset()\n\n\n\n# 문장에서 알파벳 문자만 추출 (중복 제거)\nsentence = \"Python is amazing! 123\"\nunique_chars = {char.lower() for char in sentence if char.isalpha()}\nprint(unique_chars)\n\n{'n', 'g', 'y', 'o', 'i', 'm', 'a', 'p', 'z', 'h', 's', 't'}\n\n\n\n# 주어진 숫자 리스트에서 짝수의 제곱을 저장하는 세트\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_squares = {n**2 for n in numbers if n % 2 == 0}\nprint(even_squares) \n\n{64, 100, 4, 36, 16}\n\n\n\n# 웹사이트 방문 기록에서 도메인만 추출 (중복 제거)\nurls = [\"https://google.com\", \"http://example.com\", \"https://google.com\", \"https://openai.com\"]\ndomains = {url.split(\"//\")[1] for url in urls}\nprint(domains)\n\n{'example.com', 'google.com', 'openai.com'}\n\n\n\n# 두 개의 리스트에서 공통된 단어만 저장 (중복 없이)\nwords1 = [\"apple\", \"banana\", \"cherry\", \"durian\"]\nwords2 = [\"banana\", \"durian\", \"fig\", \"grape\"]\ncommon_words = {word for word in words1 if word in words2}\nprint(common_words)  \n\n{'durian', 'banana'}"
  },
  {
    "objectID": "3_4_set.html#세트",
    "href": "3_4_set.html#세트",
    "title": "3. 자료구조",
    "section": "",
    "text": "세트(set)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 없는 집합 자료형(set data type)\n중복을 허용하지 않으며, 순서가 유지되지 않음\n\n리스트, 튜플과 달리 인덱싱과 슬라이싱이 불가능함\n\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n정수형, 부동소수점형, 문자열형, bool형, 튜플 등 해시 가능한(immutable) 자료형을 저장할 수 있는 컨테이너형 객체\n\n\n\n\n[참고] 해시(hash)\n\n데이터를 저장하거나 검색할 때 사용되는 고유한 숫자 값(해시 값)을 사용하는 과정\n세트와 딕셔너리는 내부적으로 해시 값을 사용하여 원소 또는 key에 빠르게 접근함(검색 속도가 빠름)\n해시 값은 변경되지 않아야 하므로, 불변형 객체만 사용할 수 있음\n\n\n\n\n세트 생성\n\n리터럴 방식(set literal)\n\n{}를 사용하여 세트를 직접 정의하는 방법\n{} 안에 원소(element)를 ,로 구분하여 나열함\n중복된 원소는 자동으로 제거됨\n\n생성자 방식(set constructor)\n\nset() 함수를 사용하여 세트를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 세트를 생성할 때 유용함\n빈 세트를 만들려면 반드시 set() 함수를 사용해야 함\n\n\n\n\n# 세트 생성1\nst = {1, 2, 3, 1, 1, 4}\nprint(st)\n\n{1, 2, 3, 4}\n\n\n\n# 세트 생성2\nst = set({1, 2, 3, 1, 1, 4})\nprint(st)\n\n{1, 2, 3, 4}\n\n\n\n# 세트 생성3 : 세트는 해시 가능한(immutable) 자료형을 저장할 수 있음\nst = {1, 3.14, \"Hello\", True, (1, 2, 3), \"Hello\", 1, 1, 1}\nprint(st)\n\n{1, 3.14, 'Hello', (1, 2, 3)}\n\n\n\n# 세트 생성4: iterable 객체 사용\nst = set(\"Hello\")\nprint(st)\n\n{'o', 'l', 'H', 'e'}\n\n\n\n# 세트 생성5 : iterable 객체 사용\nst1 = set([1, 2, 3, 1, 1, 4])\nst2 = set((1, 2, 3, 1, 1, 4))\nprint(st1)\nprint(st2)\n\n{1, 2, 3, 4}\n{1, 2, 3, 4}\n\n\n\n\n\n\n\n\n\n세트 전개 연산자 * : 세트의 개별 원소를 분리하여 다른 세트로 전개 - (예) {*세트}\n\n\n# 세트 전개\nst = {1, 2, 3, 1, 1, 4}\nprint({*st, *st})\nprint([11, 12, *st, 20])\n\n{1, 2, 3, 4}\n[11, 12, 1, 2, 3, 4, 20]\n\n\n\n\n\n\n\n\n\n연산\n연산자\n함수\n\n\n\n\n합집합\n|\nunion()\n\n\n교집합\n&\nintersection()\n\n\n차집합\n-\ndifference()\n\n\n대칭차집합\n^\nsymmetric_difference()\n\n\n부분집합 여부\n&lt;=\nissubset()\n\n\n\n\n\n\n# 세트 연산1\nA = {1, 2, 3}\nB = {3, 4, 5}\n\nprint(A | B)                                                # 합집합\nprint(A & B)                                                # 교집합\nprint(A - B)                                                # 차집합\nprint(A ^ B)                                                # 대칭차집합\nprint(A &lt;= B)                                               # 부분집합 여부\n\n{1, 2, 3, 4, 5}\n{3}\n{1, 2}\n{1, 2, 4, 5}\nFalse\n\n\n\n# 세트 연산2\nA = {1, 2, 3}\nB = {3, 4, 5}\n\nprint(A.union(B))\nprint(A.intersection(B))\nprint(A.difference(B))\nprint(A.symmetric_difference(B))\nprint(A.issubset(B))\n\n{1, 2, 3, 4, 5}\n{3}\n{1, 2}\n{1, 2, 4, 5}\nFalse\n\n\n\n# 세트 연산3 : 여러 개의 세트를 연쇄적으로 한 번에 연산 가능\nA = {1, 2, 3}\nB = {3, 4, 5}\nC = {5, 6, 7}\n\n# 연산자 사용\nprint(A | B | C)\nprint(A & B & C)\n\n# 메소드 사용\nprint(A.union(B, C))\nprint(A.intersection(B, C))\n\n{1, 2, 3, 4, 5, 6, 7}\nset()\n{1, 2, 3, 4, 5, 6, 7}\nset()\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nadd()\n- 새로운 값을 세트에 추가\n\n\nupdate()\n- 여러 개 값을 세트에 추가\n\n\npop()\n- 임의의 값을 삭제하고 그 값을 반환 - 어떤 값을 삭제할지 예측 불가능\n\n\nremove()\n- 세트에서 일치하는 값을 삭제 - 일치하는 값이 없으면 오류가 발생함\n\n\ndiscard()\n- 세트에서 일치하는 값을 삭제 - 일치하는 값이 없어도 오류가 발생하지 않음\n\n\nclear()\n- 세트의 모든 원소를 삭제\n\n\nin 연산자\n세트 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\n\n\n# 세트에 한 개의 원소 추가\nst = {1, 2, 3}\nst.add(6)                                  # 실행 결과로 아무것도 출력하지 않음\nprint(st)                                  # st 원본 값이 변함\n\n{1, 2, 3, 6}\n\n\n\n# 세트에 여러 개의 원소 추가\nst = {1, 2, 3}\nst.update([1, 2, 6])                       # 리스트 사용\nprint(st)\n\nst.update((1, 7))                          # 튜플 사용\nprint(st)\n\nst.update({8, 9})                          # 세트 사용\nprint(st)\n\n{1, 2, 3, 6}\n{1, 2, 3, 6, 7}\n{1, 2, 3, 6, 7, 8, 9}\n\n\n\n# 임의의 원소 삭제\nst = {1, 2, 3}\nresult = st.pop()                          # 임의의 원소를 삭제 후 반환\nprint(st)                                  # st 원본 값이 변함\nprint(result)\n\n{2, 3}\n1\n\n\n\n# 일치하는 값 삭제1\nst = {1, 2, 3}\nst.remove(3)\nprint(st)\n\n{1, 2}\n\n\n\n# 일치하는 값 삭제2 : remove() 함수는 일치하는 값이 없으면 오류가 발생함\n#st = {1, 2, 3}\n#st.remove(4)\n#print(st)\n\n\n# 일치하는 값 삭제3\nst = {1, 2, 3}\nst.discard(3)\nprint(st)\n\n{1, 2}\n\n\n\n# 일치하는 값 삭제4 : discard() 함수는 일치하는 값이 없어도 오류가 발생하지 않음\nst = {1, 2, 3}\nst.discard(4)\nprint(st)\n\n{1, 2, 3}\n\n\n\n# 세트 모든 원소 삭제\nst = {1, 2, 3}\nst.clear()\nprint(st)\n\nset()\n\n\n\n# 특정값 찾기\nst = {1, 2, 3}\nprint(3 in st)\nprint(6 in st)\n\nTrue\nFalse\n\n\n\n\n\n\n\n\n{식 for 변수 in 반복범위 if 조건식}\n\n\n리스트 컴프리헨션과 문법이 동일함\n자동으로 중복이 제거되므로 빠르고 편리함\n\n\n# 이메일 리스트에서 '@'가 포함된 유효한 이메일 주소만 추출\nemails = [\"user1@gmail.com\", \"user2\", \"test@yahoo.com\", \"invalid_email\", \"hello@naver.com\"]\nvalid_emails = {e for e in emails if \"@\" in emails}\nprint(valid_emails)\n\nset()\n\n\n\n# 문장에서 알파벳 문자만 추출 (중복 제거)\nsentence = \"Python is amazing! 123\"\nunique_chars = {char.lower() for char in sentence if char.isalpha()}\nprint(unique_chars)\n\n{'n', 'g', 'y', 'o', 'i', 'm', 'a', 'p', 'z', 'h', 's', 't'}\n\n\n\n# 주어진 숫자 리스트에서 짝수의 제곱을 저장하는 세트\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_squares = {n**2 for n in numbers if n % 2 == 0}\nprint(even_squares) \n\n{64, 100, 4, 36, 16}\n\n\n\n# 웹사이트 방문 기록에서 도메인만 추출 (중복 제거)\nurls = [\"https://google.com\", \"http://example.com\", \"https://google.com\", \"https://openai.com\"]\ndomains = {url.split(\"//\")[1] for url in urls}\nprint(domains)\n\n{'example.com', 'google.com', 'openai.com'}\n\n\n\n# 두 개의 리스트에서 공통된 단어만 저장 (중복 없이)\nwords1 = [\"apple\", \"banana\", \"cherry\", \"durian\"]\nwords2 = [\"banana\", \"durian\", \"fig\", \"grape\"]\ncommon_words = {word for word in words1 if word in words2}\nprint(common_words)  \n\n{'durian', 'banana'}"
  },
  {
    "objectID": "4_1_numpy.html",
    "href": "4_1_numpy.html",
    "title": "4. 라이브러리",
    "section": "",
    "text": "NumPy\n\nNumerical Python의 약자로, C언어로 구현된 Python 라이브러리\n고성능 수치 계산, 대규모 다차원 배열 및 행렬 연산에 최적화\n\n\n\n\n넘파이 배열(ndarray)\n\n리스트처럼 데이터를 모아 저장하는 자료구조\n모든 원소가 동일한 자료형으로 저장(효율적인 메모리 관리 및 빠른 연산)\n대규모 데이터 처리에 유리함\n반복문 없이 배열 간 연산이 가능한 브로드캐스팅 및 벡터화 연산 지원\n다양한 수학 함수, 선형대수, 난수 생성 기능 제공\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nnp.array()\n리스트, 튜플 등으로부터 배열 생성\n\n\nnp.zeros()\n모든 값이 0인 배열 생성\n\n\nnp.ones()\n모든 값이 1인 배열 생성\n\n\nnp.full()\n지정한 값으로 이루어진 배열 생성\n\n\nnp.arange()\n범위를 지정하여 연속적인 값의 배열 생성(range()와 비슷)\n\n\nnp.linspace()\n시작과 끝을 기준으로, 지정한 개수만큼 일정 간격의 값으로 배열 생성\n\n\nnp.eye()\n행과 열의 크기를 지정할 수 있는 단위행렬(2차원 배열) 생성\n\n\nnp.identity()\n정방 단위행렬(2차원 배열) 생성\n\n\n\n\nimport numpy as np\n\n\n# 넘파이 배열 생성1\narr1 = np.array([1, 2, 3])\narr2 = np.array((6, 7, 8, 9))\nprint(arr1)\nprint(arr2)\n\n[1 2 3]\n[6 7 8 9]\n\n\n\n# 넘파이 배열 생성2\narr1 = np.zeros(5)\narr2 = np.ones(3)\narr3 = np.full(2, 5)\nprint(arr1)\nprint(arr2)\nprint(arr3)\n\n[0. 0. 0. 0. 0.]\n[1. 1. 1.]\n[5 5]\n\n\n\n# 넘파이 배열 생성3\narr1 = np.arange(10)\narr2 = np.arange(3, 6)\narr3 = np.arange(1, 11, 2)\narr4 = np.arange(0, 1, 0.1)\nprint(arr1)\nprint(arr2)\nprint(arr3)\nprint(arr4)\n\n[0 1 2 3 4 5 6 7 8 9]\n[3 4 5]\n[1 3 5 7 9]\n[0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]\n\n\n\n# 넘파이 배열 생성4\narr = np.linspace(0, 1, 5)\nprint(arr)\n\n[0.   0.25 0.5  0.75 1.  ]\n\n\n\n# 넘파이 배열 생성5\narr1 = np.eye(3)\narr2 = np.eye(3, 4, k=1)\nprint(arr1)\nprint(arr2)\n\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n[[0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n\n\n\n# 넘파이 배열 생성6 : np.identity()는 np.eye()의 특수한 경우\narr = np.identity(4)\nprint(arr)\n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n\n\n\n\n\n\n\n\n\n속성\n설명\n\n\n\n\n.dtype\n배열 원소의 자료형\n\n\n.ndim\n배열의 차원 수\n\n\n.shape\n배열의 모양(행, 열)\n\n\n.size\n배열의 전체 원소 개수\n\n\n.itemsize\n원소 하나의 메모리 크기\n\n\n\n\n# 넘파이 배열의 속성\narr = np.array([[1, 2, 3], [4, 5, 6]])       # 2차원 배열\nprint(arr)\nprint(arr.dtype)\nprint(arr.ndim)\nprint(arr.shape)\nprint(arr.size)\nprint(arr.itemsize)\n\n[[1 2 3]\n [4 5 6]]\nint32\n2\n(2, 3)\n6\n4\n\n\n\n\n\n\n\n\n\n\n넘파이 배열의 차원\n\n관측하고자 하는 데이터의 속성의 수 또는 측정 항목의 수\n스칼라(scalar) : 0차원 배열, 배열에서 값을 표현하는 가장 기본 단위로 하나의 실수를 저장할 수 있음\n벡터(vector) : 1차원 배열, 스칼라 여러 개를 나열한 배열\n행렬(matrix) : 2차원 배열, 1차원 배열을 여러 개 묶은 배열\n텐서(tensor) : 3차원 이상의 배열, 벡터의 집합\n\n\n\n\narr0 = np.array(3.14)                        # 0차원 배열(스칼라)\narr1 = np.array([3.14])                      # 1차원 배열(벡터)\narr2 = np.array([[3.14]])                    # 2차원 배열(행렬)\narr3 = np.array([[[3.14]]])                  # 3차원 배열(텐서)\n\nprint(arr0.ndim, arr0.shape)\nprint(arr1.ndim, arr1.shape)\nprint(arr2.ndim, arr2.shape)\nprint(arr3.ndim, arr3.shape)\n\n0 ()\n1 (1,)\n2 (1, 1)\n3 (1, 1, 1)\n\n\n\n# 1차원 배열(벡터)\narr = np.array([1, 2, 3])\nprint(arr.ndim)\nprint(arr.shape)\n\n1\n(3,)\n\n\n\n# 2차원 배열(행렬)\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr.ndim)\nprint(arr.shape)\n\n2\n(2, 3)\n\n\n\n# 3차원 배열(텐서)\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[11, 12, 13], [14, 15, 16]]])\nprint(arr.ndim)\nprint(arr.shape)\n\n3\n(2, 2, 3)\n\n\n\n\n\n\n\n배열에서 데이터를 따라가는 방향\n\n차원이 있는 데이터에서 어느 방향으로 연산을 적용하는지 축으로 지정\n\naxis 0은 첫 번째 차원으로, 배열의 가장 바깥쪽 차원임\n\n차원이 늘어날수록 새로운 축이 axis=0가 되며, 기존 축들은 번호가 하나씩 뒤로 밀림\n\n축 번호는 배열의 차원에 따라 증가하며, 각 축은 shape에서 해당하는 차원의 크기를 나타냄\n\n예 : shape (2, 3, 4) → axis 0: 2(면), axis 1: 3(행), axis 2: 4(열)\n\n\n\n\n\n\n\n\n\n\n\n차원\n직관적인 구조\n축의 역할\n\n\n\n\n1차원\n벡터 → [1, 2, 3, 4]\naxis 0: 왼쪽 → 오른쪽\n\n\n2차원\n벡터들이 위아래로 쌓임 → 행렬\naxis 0: 위 → 아래(행) axis 1: 왼쪽 → 오른쪽(열)\n\n\n3차원\n행렬들이 앞뒤로 쌓임\naxis 0: 앞 → 뒤(면) axis 1: 위 → 아래(행) axis 2: 왼쪽 → 오른쪽(열)\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nsum()\n합계\n\n\nmean()\n평균\n\n\nstd()\n표준편차\n\n\nmin(), max()\n최소값, 최대값\n\n\ncumsum(), cumprod()\n누적 합계, 누적 곱\n\n\ntranspose()\n축 순서 변경\n\n\n\n\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\n# 합계\nprint(np.sum(arr))\nprint(np.sum(arr, axis=0))\nprint(np.sum(arr, axis=1))\n\n21\n[5 7 9]\n[ 6 15]\n\n\n\n# 누적합\nprint(np.cumsum(arr))\nprint(np.cumsum(arr, axis=0))\nprint(np.cumsum(arr, axis=1))\n\n[ 1  3  6 10 15 21]\n[[1 2 3]\n [5 7 9]]\n[[ 1  3  6]\n [ 4  9 15]]\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nreshape()\n배열을 데이터 변경없이 새로운 모양으로 변환\n\n\nflatten()\n다차원 배열을 1차원 배열로 복사하여 반환(원본 유지)\n\n\nravel()\n다차원 배열을 1차원 배열로 반환(가능하면 원본 공유, 더 효율적)\n\n\n\n\n# 1차원 배열 → 2차원 배열(3행 2열)\narr = np.array([1, 2, 3, 4, 5, 6])\n\nprint(arr.reshape(3, 2))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[[1 2]\n [3 4]\n [5 6]]\n[1 2 3 4 5 6]\n\n\n\n# 1차원 배열 → 3차원 배열\narr = np.arange(24)\n\nprint(arr.reshape(2, 3, 4))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[[[ 0  1  2  3]\n  [ 4  5  6  7]\n  [ 8  9 10 11]]\n\n [[12 13 14 15]\n  [16 17 18 19]\n  [20 21 22 23]]]\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]\n\n\n\n# 2차원 배열 → 1차원 배열 (복사본 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.flatten())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n\n\n\n# 2차원 배열 → 1차원 배열 (가능하면 뷰 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.ravel())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ntranspose()\n배열의 축 순서 변환(2차원 배열의 경우 행/열 전치)\n\n\nswqapaxes()\n지정한 두 축의 순서를 교환\n\n\n\n\n# 2차원 배열에서 transpose()\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.transpose())\n\n[[1 4]\n [2 5]\n [3 6]]\n\n\n\n# 3차원 배열에서 transpose()\narr = np.arange(24).reshape(2, 3, 4)\n\n# 축 순서 바꾸기 : (0, 1, 2) → (1, 0, 2)\nprint(arr.transpose(1, 0, 2))\nprint(arr.transpose(1, 0, 2).shape)\n\n[[[ 0  1  2  3]\n  [12 13 14 15]]\n\n [[ 4  5  6  7]\n  [16 17 18 19]]\n\n [[ 8  9 10 11]\n  [20 21 22 23]]]\n(3, 2, 4)\n\n\n\n# 3차원 배열에서 axis 0과 axis 2 교환\narr = np.array([\n    [[1, 2], [3, 4]],\n    [[5, 6], [7, 8]]\n])\n\nprint(np.swapaxes(arr, 0, 2))\nprint(np.swapaxes(arr, 0, 2).shape)\n\n[[[1 5]\n  [3 7]]\n\n [[2 6]\n  [4 8]]]\n(2, 2, 2)"
  },
  {
    "objectID": "4_1_numpy.html#numpy-라이브러리",
    "href": "4_1_numpy.html#numpy-라이브러리",
    "title": "4. 라이브러리",
    "section": "",
    "text": "NumPy\n\nNumerical Python의 약자로, C언어로 구현된 Python 라이브러리\n고성능 수치 계산, 대규모 다차원 배열 및 행렬 연산에 최적화\n\n\n\n\n넘파이 배열(ndarray)\n\n리스트처럼 데이터를 모아 저장하는 자료구조\n모든 원소가 동일한 자료형으로 저장(효율적인 메모리 관리 및 빠른 연산)\n대규모 데이터 처리에 유리함\n반복문 없이 배열 간 연산이 가능한 브로드캐스팅 및 벡터화 연산 지원\n다양한 수학 함수, 선형대수, 난수 생성 기능 제공\n\n\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nnp.array()\n리스트, 튜플 등으로부터 배열 생성\n\n\nnp.zeros()\n모든 값이 0인 배열 생성\n\n\nnp.ones()\n모든 값이 1인 배열 생성\n\n\nnp.full()\n지정한 값으로 이루어진 배열 생성\n\n\nnp.arange()\n범위를 지정하여 연속적인 값의 배열 생성(range()와 비슷)\n\n\nnp.linspace()\n시작과 끝을 기준으로, 지정한 개수만큼 일정 간격의 값으로 배열 생성\n\n\nnp.eye()\n행과 열의 크기를 지정할 수 있는 단위행렬(2차원 배열) 생성\n\n\nnp.identity()\n정방 단위행렬(2차원 배열) 생성\n\n\n\n\nimport numpy as np\n\n\n# 넘파이 배열 생성1\narr1 = np.array([1, 2, 3])\narr2 = np.array((6, 7, 8, 9))\nprint(arr1)\nprint(arr2)\n\n[1 2 3]\n[6 7 8 9]\n\n\n\n# 넘파이 배열 생성2\narr1 = np.zeros(5)\narr2 = np.ones(3)\narr3 = np.full(2, 5)\nprint(arr1)\nprint(arr2)\nprint(arr3)\n\n[0. 0. 0. 0. 0.]\n[1. 1. 1.]\n[5 5]\n\n\n\n# 넘파이 배열 생성3\narr1 = np.arange(10)\narr2 = np.arange(3, 6)\narr3 = np.arange(1, 11, 2)\narr4 = np.arange(0, 1, 0.1)\nprint(arr1)\nprint(arr2)\nprint(arr3)\nprint(arr4)\n\n[0 1 2 3 4 5 6 7 8 9]\n[3 4 5]\n[1 3 5 7 9]\n[0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]\n\n\n\n# 넘파이 배열 생성4\narr = np.linspace(0, 1, 5)\nprint(arr)\n\n[0.   0.25 0.5  0.75 1.  ]\n\n\n\n# 넘파이 배열 생성5\narr1 = np.eye(3)\narr2 = np.eye(3, 4, k=1)\nprint(arr1)\nprint(arr2)\n\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n[[0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n\n\n\n# 넘파이 배열 생성6 : np.identity()는 np.eye()의 특수한 경우\narr = np.identity(4)\nprint(arr)\n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n\n\n\n\n\n\n\n\n\n속성\n설명\n\n\n\n\n.dtype\n배열 원소의 자료형\n\n\n.ndim\n배열의 차원 수\n\n\n.shape\n배열의 모양(행, 열)\n\n\n.size\n배열의 전체 원소 개수\n\n\n.itemsize\n원소 하나의 메모리 크기\n\n\n\n\n# 넘파이 배열의 속성\narr = np.array([[1, 2, 3], [4, 5, 6]])       # 2차원 배열\nprint(arr)\nprint(arr.dtype)\nprint(arr.ndim)\nprint(arr.shape)\nprint(arr.size)\nprint(arr.itemsize)\n\n[[1 2 3]\n [4 5 6]]\nint32\n2\n(2, 3)\n6\n4\n\n\n\n\n\n\n\n\n\n\n넘파이 배열의 차원\n\n관측하고자 하는 데이터의 속성의 수 또는 측정 항목의 수\n스칼라(scalar) : 0차원 배열, 배열에서 값을 표현하는 가장 기본 단위로 하나의 실수를 저장할 수 있음\n벡터(vector) : 1차원 배열, 스칼라 여러 개를 나열한 배열\n행렬(matrix) : 2차원 배열, 1차원 배열을 여러 개 묶은 배열\n텐서(tensor) : 3차원 이상의 배열, 벡터의 집합\n\n\n\n\narr0 = np.array(3.14)                        # 0차원 배열(스칼라)\narr1 = np.array([3.14])                      # 1차원 배열(벡터)\narr2 = np.array([[3.14]])                    # 2차원 배열(행렬)\narr3 = np.array([[[3.14]]])                  # 3차원 배열(텐서)\n\nprint(arr0.ndim, arr0.shape)\nprint(arr1.ndim, arr1.shape)\nprint(arr2.ndim, arr2.shape)\nprint(arr3.ndim, arr3.shape)\n\n0 ()\n1 (1,)\n2 (1, 1)\n3 (1, 1, 1)\n\n\n\n# 1차원 배열(벡터)\narr = np.array([1, 2, 3])\nprint(arr.ndim)\nprint(arr.shape)\n\n1\n(3,)\n\n\n\n# 2차원 배열(행렬)\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr.ndim)\nprint(arr.shape)\n\n2\n(2, 3)\n\n\n\n# 3차원 배열(텐서)\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[11, 12, 13], [14, 15, 16]]])\nprint(arr.ndim)\nprint(arr.shape)\n\n3\n(2, 2, 3)\n\n\n\n\n\n\n\n배열에서 데이터를 따라가는 방향\n\n차원이 있는 데이터에서 어느 방향으로 연산을 적용하는지 축으로 지정\n\naxis 0은 첫 번째 차원으로, 배열의 가장 바깥쪽 차원임\n\n차원이 늘어날수록 새로운 축이 axis=0가 되며, 기존 축들은 번호가 하나씩 뒤로 밀림\n\n축 번호는 배열의 차원에 따라 증가하며, 각 축은 shape에서 해당하는 차원의 크기를 나타냄\n\n예 : shape (2, 3, 4) → axis 0: 2(면), axis 1: 3(행), axis 2: 4(열)\n\n\n\n\n\n\n\n\n\n\n\n차원\n직관적인 구조\n축의 역할\n\n\n\n\n1차원\n벡터 → [1, 2, 3, 4]\naxis 0: 왼쪽 → 오른쪽\n\n\n2차원\n벡터들이 위아래로 쌓임 → 행렬\naxis 0: 위 → 아래(행) axis 1: 왼쪽 → 오른쪽(열)\n\n\n3차원\n행렬들이 앞뒤로 쌓임\naxis 0: 앞 → 뒤(면) axis 1: 위 → 아래(행) axis 2: 왼쪽 → 오른쪽(열)\n\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nsum()\n합계\n\n\nmean()\n평균\n\n\nstd()\n표준편차\n\n\nmin(), max()\n최소값, 최대값\n\n\ncumsum(), cumprod()\n누적 합계, 누적 곱\n\n\ntranspose()\n축 순서 변경\n\n\n\n\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\n# 합계\nprint(np.sum(arr))\nprint(np.sum(arr, axis=0))\nprint(np.sum(arr, axis=1))\n\n21\n[5 7 9]\n[ 6 15]\n\n\n\n# 누적합\nprint(np.cumsum(arr))\nprint(np.cumsum(arr, axis=0))\nprint(np.cumsum(arr, axis=1))\n\n[ 1  3  6 10 15 21]\n[[1 2 3]\n [5 7 9]]\n[[ 1  3  6]\n [ 4  9 15]]\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nreshape()\n배열을 데이터 변경없이 새로운 모양으로 변환\n\n\nflatten()\n다차원 배열을 1차원 배열로 복사하여 반환(원본 유지)\n\n\nravel()\n다차원 배열을 1차원 배열로 반환(가능하면 원본 공유, 더 효율적)\n\n\n\n\n# 1차원 배열 → 2차원 배열(3행 2열)\narr = np.array([1, 2, 3, 4, 5, 6])\n\nprint(arr.reshape(3, 2))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[[1 2]\n [3 4]\n [5 6]]\n[1 2 3 4 5 6]\n\n\n\n# 1차원 배열 → 3차원 배열\narr = np.arange(24)\n\nprint(arr.reshape(2, 3, 4))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[[[ 0  1  2  3]\n  [ 4  5  6  7]\n  [ 8  9 10 11]]\n\n [[12 13 14 15]\n  [16 17 18 19]\n  [20 21 22 23]]]\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]\n\n\n\n# 2차원 배열 → 1차원 배열 (복사본 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.flatten())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n\n\n\n# 2차원 배열 → 1차원 배열 (가능하면 뷰 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.ravel())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ntranspose()\n배열의 축 순서 변환(2차원 배열의 경우 행/열 전치)\n\n\nswqapaxes()\n지정한 두 축의 순서를 교환\n\n\n\n\n# 2차원 배열에서 transpose()\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.transpose())\n\n[[1 4]\n [2 5]\n [3 6]]\n\n\n\n# 3차원 배열에서 transpose()\narr = np.arange(24).reshape(2, 3, 4)\n\n# 축 순서 바꾸기 : (0, 1, 2) → (1, 0, 2)\nprint(arr.transpose(1, 0, 2))\nprint(arr.transpose(1, 0, 2).shape)\n\n[[[ 0  1  2  3]\n  [12 13 14 15]]\n\n [[ 4  5  6  7]\n  [16 17 18 19]]\n\n [[ 8  9 10 11]\n  [20 21 22 23]]]\n(3, 2, 4)\n\n\n\n# 3차원 배열에서 axis 0과 axis 2 교환\narr = np.array([\n    [[1, 2], [3, 4]],\n    [[5, 6], [7, 8]]\n])\n\nprint(np.swapaxes(arr, 0, 2))\nprint(np.swapaxes(arr, 0, 2).shape)\n\n[[[1 5]\n  [3 7]]\n\n [[2 6]\n  [4 8]]]\n(2, 2, 2)"
  }
]