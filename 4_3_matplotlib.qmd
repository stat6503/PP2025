---
title: 4. 라이브러리
jupyter: python3
---

## 4.3. MatplotLib 라이브러리
### 4.3.1 데이터 시각화
+ 데이터 시각화(data visualization)
  + 데이터 분석 결과를 쉽게 이해할 수 있도록 표현하고 전달되는 과정
  + 복잡한 정보를 한 눈에 파악하고, 숨겨진 패턴이나 관계를 드러냄
  + 탐색적 자료 분석(EDA), 결과 해석, 의사결정 등에 폭넓게 활용

<br>

+ MatplotLib
  + 넘파이 배열을 기반으로 만들어진 다중 플랫폼 데이터 시각화 라이브러리
  + 다양한 운영체제와 그래픽 백엔드에서 안정적으로 작동



<br>

### 4.3.2 데이터 시각화 유형

|유형|설명|
|:---:|:------------|
|선 그래프 (line plot)|- 시계열 데이터의 추세 표현 <br>- 색상(`color`), 선 종류(`linestyle`), 마커(`marker`) 등|
|막대 그래프 (bar plot)|- 범주형 데이터의 값 비교 <br>- 색상(`color`), 너비(`width`), 정렬(`align`) 등|
|히스토그램 (histogram)|- 연속형 데이터의 분포 파악 <br>- 색상(`color`), 구간 수(`bins`), 누적 여부(`cumulative`) 등|
|산점도 (scatter plot)|- 두 연속형 변수 사이의 관계 표현 <br>- 색상(`c`), 점 크기(`s`), 투명도(`alpha`) 등|

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
```

```{python}
## 실습 데이터 : air_quality 데이터셋
air_quality = pd.read_csv("https://raw.githubusercontent.com/pandas-dev/pandas/main/doc/data/air_quality_no2_long.csv")
```

```{python}
# city: 측정 도시
# country: 측정 국가
# date.utc: 측정 일시(UTC)
# location: 측정 위치
# parameter: 측정 항목
# value: 측정 값
# unit: 측정 단위
print(air_quality.info())
```

```{python}
print(air_quality.head())
```

```{python}
air_quality['city'].value_counts()
```

```{python}
air_quality['parameter'].value_counts()
```

```{python}
# date.utc 열을 datetime 형식으로 변환
air_quality['date.utc'] = pd.to_datetime(air_quality['date.utc'])
```

```{python}
print(air_quality.info())
```

```{python}
print(air_quality.head())
```

```{python}
## 선 그래프
# 1) Paris의 NO2 농도 변화: 기본 선 그래프
paris_data = air_quality[air_quality["city"] == "Paris"]

plt.figure(figsize=(8, 3))
plt.plot(paris_data["date.utc"], paris_data["value"])
plt.title("NO₂ levels in Paris")
plt.xlabel("Date")
plt.ylabel("NO₂ (µg/m³)")
plt.tight_layout()
plt.show()
```

```{python}
## 선 그래프
# 2) Paris의 NO2 농도 변화: 리샘플링(1시간 → 일간), 커스터마이징(색상, 선 종류, 마커)
# 색상: r, g, b, c, m, y, k, w
# 선 종류: -, --, -., :
# 마커: o, +, D, s, ^, v, .
value_day = paris_data.set_index('date.utc')['value'].resample('D').mean()

plt.figure(figsize=(8, 3))
#plt.plot(value_day.index, value_day, color="green", linestyle="--", marker="o")
plt.plot(value_day.index, value_day, "g--o")
plt.title("NO₂ levels in Paris")
plt.xlabel("Date")
plt.ylabel("NO₂ (µg/m³)")
plt.tight_layout()
plt.show()
```

```{python}
## 선 그래프
# 3) 세 도시의 NO2 농도 변화
cities = ['Paris', 'London', 'Antwerpen']
colors = ['steelblue', 'green', 'indianred']

plt.figure(figsize=(8, 3))

for i, city in enumerate(cities):
    city_data = air_quality[air_quality["city"] == city]
    plt.plot(city_data['date.utc'], city_data['value'],
             label=city, color=colors[i],
             linewidth=1, alpha=0.7)

plt.title("NO₂ levels in Paris, London, and Antwerpen")
plt.xlabel("Date")
plt.ylabel("NO₂ (µg/m³)")
plt.legend(loc = 'upper right', fontsize=7)
plt.tight_layout()
plt.show()
```

```{python}
## 막대 그래프
# 1) 도시의 측정 빈도
city_counts = air_quality['city'].value_counts()

plt.figure(figsize=(5, 3))
plt.bar(city_counts.index, city_counts.values, color=['steelblue', 'seagreen', 'indianred'])
plt.title("Frequency of Measurements by City")
plt.xlabel("City")
plt.ylabel("Frequency")
plt.tight_layout()
plt.show()
```

```{python}
## 막대 그래프
# 2) 도시별 평균 NO₂ 농도
city_avg = air_quality.groupby('city')['value'].mean()

plt.figure(figsize=(5, 3))
plt.bar(city_avg.index, city_avg.values, color=['steelblue', 'seagreen', 'indianred'])
plt.title("Average NO₂ Levels by City")
plt.xlabel("City")
plt.ylabel("Average NO₂ (µg/m³)")
plt.tight_layout()
plt.show()
```

```{python}
## 히스토그램
# 1) Paris의 NO2 농도 분포
paris_data = air_quality[air_quality["city"] == "Paris"]

plt.figure(figsize=(5, 3))
plt.hist(paris_data["value"], bins=15)
plt.title("Distribution of NO₂ in Paris")
plt.xlabel("NO₂ (µg/m³)")
plt.ylabel("Frequency")
plt.tight_layout()
plt.show()
```

```{python}
## 히스토그램, 다중 그래프
# 2) 세 도시의 NO2 농도 분포
cities = ['Paris', 'London', 'Antwerpen']
colors = ['steelblue', 'green', 'indianred']

plt.figure(figsize=(8, 3))

for i, city in enumerate(cities):
    city_data = air_quality[air_quality["city"] == city]
    plt.subplot(1, 3, i+1)
    plt.hist(city_data['value'],
             label=city, color=colors[i])
    
    plt.xlabel("NO₂ (µg/m³)")
    plt.ylabel("Frequency")
    plt.legend(loc = 'upper right')
    plt.xlim(0, 100)

plt.tight_layout()
plt.show()
```

```{python}
## 산점도
# 전체 금액과 팁 금액 관계
import seaborn as sns
tips = sns.load_dataset("tips")

plt.figure(figsize=(4, 4))
plt.scatter(tips['total_bill'], tips['tip'],
           c=tips['time'].map({'Lunch': 'orange', 'Dinner': 'gray'}), alpha=0.7)
plt.title('Scatter Plot of Total Bill vs Tip')
plt.xlabel('Total Bill')
plt.ylabel('Tip')
plt.tight_layout()
```

<br>

### 4.3.3 이미지 데이터 처리
#### 4.3.3.1. 이미지 불러오기
+ 이미지(image)
  + 디지털 이미지는 수 많은 픽셀(pixel)로 이루어져 있으며, 각 픽셀은 숫자 하나 또는 세개(R, G, B)의 값을 가짐
    + 흑백 이미지 : 2차원 배열 → 행(높이), 열(너비)
    + 컬러 이미지(RGB) : 3차원 배열 → 행(높이), 열(너비), 채널
  + 이미지는 곧 숫자로 이루어진 배열이며, 넘파이 배열로 변환하여 수치 연산 가능
  + 이미지 데이터는 수치적으로 처리하거나 분석할 수 있으며, 머신러닝/딥러닝 모델에 입력하기 위해 배열 형태로 변환하는 것이 일반적임

<br>

+ 색의 3요소 RGB
  + 컬러 이미지는 보통 RGB 색상 모델을 따름
  + 각 픽셀은 R, G, B 세 가지 값(0~255)을 조합하여 하나의 색을 표현함 → 이 세 개의 값을 각각 하나의 채널(channel)이라 함
  + RGB 이미지는 관례적으로 (height, width, channel) 구조를 따름
    + 3차원 배열(높이, 너비, 3)에서 배열의 세 번째 축(axis=2)이 채널 방향임
    + `array[:, :, 0]` : R 채널
    + `array[:, :, 1]` : G 채널
    + `array[:, :, 2]` : B 채널

<br>

+ PIL 라이브러리
  + 다양한 이미지 파일 형식을 지원하는 이미지 처리 라이브러리(Pillow)
  + 이미지 불러오기, 배열 변환, 크기 조절, 회전, 흑백 전환 등 다양한 처리 가능

```{python}
from PIL import Image
```

+ 예제 이미지 : <a href="https://unsplash.com/ko/%EC%82%AC%EC%A7%84/%EB%AC%B4%EC%84%B1%ED%95%9C-%EB%85%B9%EC%83%89-%EB%93%A4%ED%8C%90%EC%9D%84-%EA%B0%80%EB%A1%9C%EC%A7%88%EB%9F%AC-%EB%8B%AC%EB%A6%AC%EB%8A%94-%EC%9E%91%EC%9D%80-%EA%B0%9C-Uv1G3yfL2Gg?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a>의 <a href="https://unsplash.com/ko/@stefanusfandhy12?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">stefanus fandhy</a>

```{python}
# 이미지 불러오기 및 시각화
img = Image.open('./images/puppy.jpg')
plt.imshow(img)
plt.axis('off')
plt.show()
```

```{python}
# 넘파이 배열로 변환
img_array = np.array(img)
print("이미지 배열 형태: ", img_array.shape)
```

```{python}
# 각 채널 이미지 시각화
color_maps = ['Reds', 'Greens', 'Blues']

plt.figure(figsize=(8, 5))

for i, cmap in enumerate(color_maps):
    plt.subplot(1, 3, i+1)
    plt.imshow(img_array[:, :, i], cmap=cmap)
    plt.title(f'{cmap} Channel')
    plt.axis('off')

plt.tight_layout()
plt.show()
```

```{python}
# 흑백 이미지 시각화 : 단순 평균(simple average) 방식
gray_img = img_array.mean(axis=2)

plt.figure(figsize=(4, 4))
plt.imshow(gray_img, cmap='gray')
plt.title('Grayscale Image')
plt.axis('off')
plt.show()
```

```{python}
# 흑백 이미지 시각화 : 가중 평균(weighted average) 방식
r = img_array[:, :, 0]
g = img_array[:, :, 1]
b = img_array[:, :, 2]
gray_img_weighted = r * 0.2989 + g * 0.5870 + b * 0.1140    # ITU-R BT.601 표준 가중치

plt.figure(figsize=(4, 4))
plt.imshow(gray_img_weighted, cmap='gray')
plt.title('Grayscale Image')
plt.axis('off')
plt.show()
```

<br>

#### 4.3.3.2. 색상 채널 처리
+ 컬러 이미지의 각 채널(R, G, B)은 배열의 세 번째 축(axis=2)으로 구분됨
+ 채널 분리: 각 채널별로 배열을 따로 저장 가능
+ 채널 합성: 분리한 채널 배열들을 다시 합쳐 원래 이미지로 복원 가능
+ 채널별 조작
  + 특정 채널 값에 덧셈, 곱셈 등 연산을 적용하여 색상을 강조하거나 조절할 수 있음
  + 이때 값이 0~255 범위를 벗어나지 않도록 주의해야 함

```{python}
# 채널 분리
r = img_array[:, :, 0]
g = img_array[:, :, 1]
b = img_array[:, :, 2]
```

```{python}
# 채널별 조작 : 빨강 채널 강조
# np.clip() : 넘파이 배열의 값들을 지정한 최소값, 최대값 사이로 제한하는 함수
# np.uint8 : 
r_enhanced = np.clip(r * 1.5, 0, 255).astype(np.uint8)

plt.figure(figsize=(4, 4))
plt.imshow(r_enhanced, cmap="Reds")
plt.title('Enhanced Reds Channel')
plt.axis('off')
plt.show()
```

```{python}
# 채널 합성
modified_img = np.stack([r_enhanced, g, b], axis=2)

plt.figure(figsize=(4, 4))
plt.imshow(modified_img)
plt.title('Modified Image')
plt.axis('off')
plt.show()
```

<br>

#### 4.3.3.3. 이미지 변형
+ 디지털 이미지의 크기, 방향, 위치 등을 변경하는 작업
+ 머신러닝/딥러닝에서 입력 이미지를 정해진 크기로 맞추거나, 데이터 증강(data augmentation)을 위해 변형을 적용함
+ PIL(Pillow) 라이브러리를 이용하면 다양한 변형 작업을 간단히 수행할 수 있음|

<br>

|구분|설명|
|:---:|:------------|
|크기 조절<br>(resize)|  - 이미지의 너비(width)와 높이(height)를 원하는 크기로 변경 <br>- 학습 모델에 입력되는 이미지 크기가 고정되어 있는 경우에 필수적인 전처리 작업 <br>- 보간법(interpolation)에 따라 이미지 품질에 차이가 발생할 수 있음|
|회전 및 뒤집기<br>(rotate & flip)|- 회전(rotation) : 이미지를 특정 각도만큼 회전 <br>- 좌우/상하 뒤집기(flip) : 이미지를 반전시켜 대칭 구조로 만듦 <br>- 데이터 다양성을 높이기 위한 증강 기법으로 자주 사용됨|
|잘라내기<br>(crop)|- 이미지의 일부분만 선택하여 잘라냄 <br>- 관심 영역(Region of Interest, ROI)만 추출할 때 유용 <br>- 정사각형으로 자르거나 특정 좌표를 기준으로 crop 가능|

```{python}
# 크기 조절 : 너비 200px, 높이 100px
resized_img = img.resize((200, 100))

plt.imshow(resized_img)
plt.title('Resized Image')
plt.axis('off')
plt.show()
```

```{python}
# 45도 회전
rotated_img = img.rotate(45)

plt.imshow(rotated_img)
plt.title('Rotated(45°) Image')
plt.axis('off')
plt.show()
```

```{python}
# 좌우 반전 뒤집기
flipped_img1 = img.transpose(Image.FLIP_LEFT_RIGHT)

plt.imshow(flipped_img1)
plt.title("Flipped (Left ↔ Right) Image")
plt.axis('off')
plt.show()
```

```{python}
# 상하 반전 뒤집기
flipped_img2 = img.transpose(Image.FLIP_TOP_BOTTOM)

plt.imshow(flipped_img2)
plt.title("Flipped (Top ↔ Bottom) Image")
plt.axis('off')
plt.show()
```

```{python}
np.array(img).shape
```

```{python}
# 잘라내기 : (left, top, right, bottom)
cropped_img = img.crop((2200, 1500, 3000, 2000))

plt.imshow(cropped_img)
plt.title("Croppeed Image")
plt.axis('off')
plt.show()
```

