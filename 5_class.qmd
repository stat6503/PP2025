---
title: 5. 클래스
jupyter: python3
---

## 5.1. 클래스와 객체
+ 객체지향 프로그래밍(Object-Oriented Programming; OOP)
  + 프로그램을 여러 개의 독립된 단위(객체)들의 모임으로 구성하는 프로그래밍 패러다임
  + 현실 세계에 존재하는 모든 것을 객체로 표현 → 프로그램이 더 직관적이고 이해하기 쉬워짐
  + 코드의 재사용성, 유지보수성, 확장성이 높아짐

<br>

+ 객체(object)
  + 현실 세계의 사물이나 개념을 코드로 구현한 것
  + 데이터를 저장하는 속성(attribute)과 기능을 수행하는 메소드(method)를 가짐
  + (예) 은행계좌
    + 속성 : 잔액
    + 메소드 : 입금, 출금

<br>

+ 클래스(class)
  + 객체를 생성하기 위한 일종의 설계도(template)
  + 공통된 속성(attribute)과 메소드(method)를 가지는 객체들을 하나의 구조로 정의
    + 같은 클래스에서 만들어진 객체들은 구조와 동작 방식이 동일함
  + 클래스로부터 만들어지는 객체를 그 클래스의 **인스턴스**(instance)라 함
  + (예) `Account` 클래스 → 여러 개의 은행계좌 객체를 생성할 수 있음

<br>

![](./images/fig5-1.png){width=50%}


<br>

## 5.2. 클래스 정의와 인스턴스 구성
+ 클래스 정의
  + `class` 키워드를 사용하여 정의함
  + 클래스 이름은 일반적으로 대문자로 시작(예 : `Account`, `Student`)
  + 클래스 본문에는 속성(변수)와 메소드(함수)를 정의함

<br>

+ 생성자 메소드 `__init__()`
  + 인스턴스가 생성될 때 자동으로 호출되는 특별한 메소드
  + 인스턴스마다 고유한 속성(인스턴스 변수)을 초기화하는 데 주로 사용됨
  + 인스턴스 변수는 `__init__()` 내부에서 `self.변수명` 형태로 정의되어 각 인스턴스마다 독립적인 값을 가짐
  + 첫 번째 매개변수는 항상 `self`로, 생성된 인스턴스 자신을 가리킴

|구분|설명|
|:---:|:------------|
|인스턴스 변수|- 메소드 내부에서 `self.변수이름` 형태로 정의 <br>- 인스턴스마다 독립적인 값을 가짐|
|인스턴스 메소드|- 클래스 내부에 정의된 함수 <br>- 첫 번째 매개변수로 `self`를 사용하여 해당 인스턴스에 접근함 <br>- 인스턴스를 통해 호출됨|

```{python}
## 클래스 정의1: 은행계좌
# 잔액의 초기값은 항상 0으로 설정
class Account:
    # 클래스 내부에 정의한 변수(클래스 변수)는 모든 인스턴스가 공유함 (권장하지 않음)
    # → 인스턴스마다 독립적인 속성을 가지려면 생성자 메소드 __init__()에서 인스턴스 변수를 정의해야 함
    # balance = 0

    # 생성자 메소드
    def __init__(self):                      # 첫 번째 매개변수는 반드시 self여야 함
        self.balance = 0                     # (속성) 잔액, 인스턴스마다 독립적

    # (메소드) 입금 기능
    def deposit(self, amount):               # 첫 번째 매개변수는 반드시 self여야 함
        self.balance += amount               # 인스턴스 변수에 접근하기 위해 self.balance 사용
        return self.balance

    # (메소드) 출금 기능
    def withdraw(self, amount):
        self.balance -= amount
        return self.balance
```

```{python}
# 인스턴스 생성
my_acc = Account()
```

```{python}
# 인스턴스 속성 확인
print(my_acc.balance)
```

```{python}
# 인스턴스 메소드 사용1
print(my_acc.deposit(10000))
```

```{python}
# 인스턴스 메소드 사용2
print(my_acc.withdraw(3000))
```

```{python}
# 인스턴스 속성 확인
print(my_acc.balance)
```

```{python}
## 클래스 정의2: 은행계좌
# 잔액의 초기값을 인스턴스를 생성할 때 직접 입력받아 설정(입력히지 않으면 0)
class Account:
    # 생성자 메소드
    def __init__(self, amount=0):
        self.balance = amount                # (속성) 잔액

    def deposit(self, amount):               # (메소드) 입금 기능
        self.balance += amount
        return self.balance
        
    def withdraw(self, amount):              # (메소드) 출금 기능
        self.balance -= amount
        return self.balance
```

```{python}
# 인스턴스 생성 및 속성 확인
my_acc = Account(50000)
print(my_acc.balance)
```

<br>

## 5.3. 매직 메소드
### 5.3.1. 매직 메소드 소개
+ 매직 메소드(magic method)
  + 이름 앞뒤에 `___`(double underscore)가 붙는 특별한 메소드
  + Python 내부 동작과 자동으로 연결되며, 다양한 상황에서 자동 호출됨
    + (예) `print(인스턴스)` → `__str__()` 호출
    + (예) `for x in 인스턴스` → `__iter__()` 호출
  + 오버라이드하면 내가 정의한 클래스가 Python 기본 동작과 자연스럽게 연동됨
  + 클래스 사용성과 직관성을 크게 향상시킴

<br>

### 5.3.2. 문자열 표현 메소드 `__str__()`, `__repr__()`
+ `__str__()` 메소드
  + 인스턴스를 `print()`하거나 `str()`로 변환할 때 자동으로 호출되는 메소드
  + 인스턴스의 상태를 사람이 읽기 쉬운 문자열 형태로 반환함
  + 디버깅이나 결과 출력 시 인스턴스 정보를 명확히 확인할 수 있도록 도와줌

<br>

+ `__repr__()` 메소드
  + 인스턴스를 대화형 환경에서 출력하거나 `repr()`로 변환할 때 자동으로 호출되는 메소드
  + 인스턴스의 상태를 개발자가 이해하기 쉽고, 가능하면 인스턴스 재생성이 가능한 정확한 문자열 형태로 반환함
    + `repr()` 함수 : 인스턴스의 표준 문자열 표현을 반환하며, `eval()` 함수에 전달 시 일반적으로 원래 인스턴스가 생성됨
    + 일반적으로 `eval(repr(obj)) == obj`이 성립하도록 설계함
  + 주로 디버깅, 로깅, 인스턴스 재생성 코드 출력 등에 유용하게 사용됨
  + `__str__()` 메소드가 정의되지 않은 경우 `__repr__()`의 반환값이 대신 사용됨(반대는 성립 ×)

```{python}
## 클래스 정의: 책
class Book:
    def __init__(self, title, author, price):
        self.title = title                   # (속성) 책 제목
        self.author = author                 # (속성) 저자 이름
        self.price = price                   # (속성) 가격

    # 가격 할인 적용 후 price 값 변경(소수점 이하 버림)
    def apply_discount(self, percent):       # (메소드) 가격 할인 적용 (percent : 0~100)
        self.price = int(self.price * (1 - percent / 100))

    # 사람이 읽기 좋은 문자열 표현
    def __str__(self):
        return f"Book(title: '{self.title}', author: '{self.author}', price: {self.price})"

    # 개발자용 문자열 표현
    def __repr__(self):
        return f"Book('{self.title}', '{self.author}', {self.price})"
```

```{python}
# 인스턴스 생성
my_book = Book("Python Programming", "Park", 30000)
```

```{python}
# 인스턴스를 문자열로 출력1: __str__() 메소드 자동 호출
print(my_book)
```

```{python}
# 인스턴스를 문자열로 출력2: __repr__() 메소드 자동 호출
my_book
```

```{python}
# 인스턴스를 문자열로 출력2: __repr__() 메소드 자동 호출
repr(my_book)
```

```{python}
# eval() 함수로 repr() 결과를 실행하여 새로운 인스턴스 생성
my_book.apply_discount(10)
new_book = eval(repr(my_book))
print(new_book)
```

<br>

### 5.3.3. 시퀀스 동작 메소드 `__len__()`, `__getitem__()`, `__iter__()`
+ 리스트, 튜플처럼 순서가 존재하는 자료형(sequence data type)에서 동작하는 매직 메소드
+ 사용자 정의 클래스에 시퀀스 특성을 부여하며, `len()`, 인덱싱, 반복문 등과 자연스럽게 연동됨

<br>

|유형|설명|
|:---:|:------------|
|__len__() 메소드|- 인스턴스를 `len()`로 변환할 때 자동으로 호출되는 메소드 <br>- 객체가 포함하고 있는 요소의 개수를 정수형으로 반환함|
|__getitem__() 메소드|- 인스턴스를 인덱싱(`인스턴스[index]`)할 때 자동으로 호출되는 메소드 <br>- 특정 위치의 값을 반환하며, 슬라이싱 처리도 가능하게 만들 수 있음|
|__iter__() 메소드|- for 문에서 사용할 수 있는 iterable 객체를 반환하는 메소드 <br>- 일반적으로 `return iter(내부_시퀀스)` 형태로 구현함|

```{python}
## 클래스 정의: 음악 플레이리스트
class Playlist:
    def __init__(self, name, songs):
        self.name = name                     # (속성) 플레이리스트 이름
        self.songs = songs                   # (속성) 노래 목록 (리스트)
        
    def add_song(self, song):                # (메소드) 노래 추가
        self.songs.append(song)

    def __len__(self):
        return len(self.songs)

    def __getitem__(self, index):
        return self.songs[index]

    def __iter__(self):
        return iter(self.songs)
```

<br>

## 4.4. 클래스와 리스트
+ 여러 개의 인스턴스를 관리하기 위해 리스트를 사용하면 효율적임
  + 인덱스를 사용하여 특정 인스턴스에 접근 가능
  + 반복문을 통해 리스트 내 모든 인스턴스에 접근하여 메소드를 호출하거나 속성을 조회할 수 있음

```{python}
# 클래스 정의: 은행계좌
class Account:
    def __init__(self, owner, amount=0):
        self.owner = owner                   # (속성) 계좌 소유주
        self.balance = amount                # (속성) 잔액

    def deposit(self, amount):               # 입금 메소드
        self.balance += amount
        return self.balance

    def withdraw(self, amount):              # 출금 메소드
        self.balance -= amount
        return self.balance

    def __str__(self):
        return f"Account(owner: '{self.owner}', balance: {self.balance})"

    def __repr__(self):
        return f"Account(owner='{self.owner}', balance={self.balance})"
```

```{python}
# 여러 인스턴스를 리스트에 저장
accounts = [
    Account("Kim", 10000),
    Account("Lee", 20000),
    Account("Park", 15000)
]
```

```{python}
# 모든 계좌에 일괄적으로 입금 처리
for acc in accounts:
    acc.deposit(5000)
```

```{python}
# 계좌 정보 출력
for acc in accounts:
    print(acc)
```

